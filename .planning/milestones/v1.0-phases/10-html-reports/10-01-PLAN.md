---
phase: 10-html-reports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/output/html_output.zig
  - src/main.zig
autonomous: true
requirements:
  - OUT-HTML-01
  - OUT-HTML-02

must_haves:
  truths:
    - "Running with --format html produces a complete self-contained HTML document"
    - "HTML output includes inline CSS and JavaScript with no external references"
    - "HTML dashboard shows project health score with letter grade"
    - "HTML dashboard shows top 5 hotspot function cards with metric details"
    - "HTML dashboard shows distribution bar (healthy/warning/error file counts)"
    - "HTML dashboard shows summary stats (total files, functions, errors, warnings)"
    - "HTML respects prefers-color-scheme for auto light/dark mode"
    - "All user-provided strings (function names, file paths) are HTML-escaped"
  artifacts:
    - path: "src/output/html_output.zig"
      provides: "HTML report builder module"
      min_lines: 200
    - path: "src/main.zig"
      provides: "Format dispatch for html"
      contains: "html_output"
  key_links:
    - from: "src/main.zig"
      to: "src/output/html_output.zig"
      via: "format dispatch branch"
      pattern: "html_output\\.buildHtmlReport"
    - from: "src/output/html_output.zig"
      to: "src/output/console.zig"
      via: "FileThresholdResults import"
      pattern: "FileThresholdResults"
---

<objective>
Create the core HTML report module and wire it into the main.zig format dispatch pipeline.

Purpose: Establishes the self-contained HTML report generation infrastructure (OUT-HTML-01) and implements the project summary dashboard with health score, grade, hotspot cards, distribution bar, and summary stats (OUT-HTML-02).

Output: `src/output/html_output.zig` module with `buildHtmlReport` function producing a complete HTML document, wired into main.zig via `--format html`.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-html-reports/10-RESEARCH.md
@.planning/phases/10-html-reports/10-CONTEXT.md
@src/output/sarif_output.zig
@src/output/json_output.zig
@src/output/console.zig
@src/main.zig
@src/metrics/cyclomatic.zig
@src/metrics/scoring.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create html_output.zig with core module, CSS/JS, dashboard, and hotspot sections</name>
  <files>src/output/html_output.zig</files>
  <action>
Create `src/output/html_output.zig` following the exact same module pattern as `sarif_output.zig` and `json_output.zig`.

**Public API:**
- `pub fn buildHtmlReport(allocator, file_results, warning_count, error_count, project_score, tool_version) ![]u8` — returns heap-allocated HTML string. Caller owns the slice.

**Helper functions (private):**
- `writeHtmlEscaped(w, s)` — HTML-escape user strings: `<` → `&lt;`, `>` → `&gt;`, `&` → `&amp;`, `"` → `&quot;`
- `scoreToGrade(score: f64) []const u8` — `>=90=A, >=80=B, >=65=C, >=50=D, else=F`
- `computeFileHealthScore(results: []const ThresholdResult) f64` — average of `health_score` fields; 100.0 for empty
- `scoreToColorClass(score: f64) []const u8` — returns "ok", "warning", or "error" based on score (>=80, >=50, <50)
- `writeHead(w, allocator, tool_version)` — writes `<head>` with `<style>` block containing all CSS
- `writeDashboard(w, allocator, file_results, project_score, warning_count, error_count)` — writes dashboard section
- `writeHotspots(w, allocator, file_results)` — top 5 worst functions as cards
- `writeDistributionBar(w, allocator, file_results)` — CSS flexbox bar with healthy/warning/error segments
- `writeFooter(w, tool_version)` — "Generated by ComplexityGuard" with timestamp

**CSS (embedded as const string literal):**
PicoCSS-inspired minimal styling:
- Use CSS custom properties for theming: `--color-ok`, `--color-warning`, `--color-error`, `--bg`, `--text`, `--surface`, `--border`
- `@media (prefers-color-scheme: dark)` overrides for dark mode
- Threshold colors: muted green for healthy, subtle yellow for warnings, strong red for errors
- Responsive layout: max-width container, flexible grid for hotspot cards
- Distribution bar: flexbox with colored segments
- Hotspot cards: bordered cards showing function name, file, metric scores, violated thresholds
- Typography: system font stack, clean spacing

**JavaScript (embedded as const string literal):**
This plan embeds placeholder JS that will be extended in Plan 02 for sort/expand. For now, include only the basic structure (IIFE wrapper, any utility functions).

**Dashboard HTML structure:**
```
<main>
  <section class="dashboard">
    <div class="score-panel">
      <div class="health-score">{score} {grade}</div>
      <div class="distribution-bar">...</div>
      <div class="summary-stats">
        Files: N | Functions: N | Errors: N | Warnings: N
      </div>
    </div>
    <div class="hotspots">
      <h2>Top Hotspots</h2>
      <!-- up to 5 cards -->
      <div class="hotspot-card {status-class}">
        <h3>{function_name}</h3>
        <p class="hotspot-file">{file_path}</p>
        <div class="hotspot-metrics">
          Cyclomatic: N | Cognitive: N | Halstead Vol: N | ...
        </div>
        <div class="hotspot-violations">
          <!-- violated thresholds highlighted -->
        </div>
      </div>
    </div>
  </section>
</main>
```

**Hotspot selection algorithm:**
Collect all ThresholdResult items across all files (pairing each with its file path). Sort by health_score ascending (lowest = worst). Take first 5. Use bubble sort (small list, matches codebase pattern from console.zig).

**String building pattern (Zig 0.14/0.15):**
```zig
var buf = std.ArrayList(u8).empty;
defer buf.deinit(allocator);
const w = buf.writer(allocator);
// ... write HTML ...
return try allocator.dupe(u8, buf.items);
```

**Inline tests:**
- `test "scoreToGrade"` — verify all grade thresholds (90=A, 80=B, 65=C, 50=D, 49=F)
- `test "computeFileHealthScore"` — empty results → 100.0; known values → correct average
- `test "writeHtmlEscaped"` — verify `<`, `>`, `&`, `"` are escaped
- `test "scoreToColorClass"` — verify score → class mapping
- `test "buildHtmlReport basic"` — verify output starts with `<!DOCTYPE html>`, contains key sections, has no external references (no `<link`, no `<script src`)
  </action>
  <verify>Run `zig build test` — all new tests pass. Grep html_output.zig for `<link` and `<script src` to confirm no external references.</verify>
  <done>html_output.zig exists with buildHtmlReport producing a complete self-contained HTML document. Dashboard section renders health score with grade, distribution bar, summary stats, and top 5 hotspot cards. All user strings are HTML-escaped. CSS includes light/dark mode via prefers-color-scheme. All inline tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Wire html_output into main.zig format dispatch and test import</name>
  <files>src/main.zig</files>
  <action>
**Wire the HTML output module into main.zig:**

1. Add import at the top of main.zig alongside existing output imports:
   ```zig
   const html_output = @import("output/html_output.zig");
   ```

2. Add format dispatch branch after the SARIF branch (line ~599), before the `else` console block:
   ```zig
   } else if (std.mem.eql(u8, effective_format, "html")) {
       const html_str = try html_output.buildHtmlReport(
           arena_allocator,
           file_results,
           total_warnings,
           total_errors,
           project_score,
           version,
       );

       if (cli_args.output_file) |output_path| {
           const file = try std.fs.cwd().createFile(output_path, .{});
           defer file.close();
           try file.writeAll(html_str);
       } else {
           try stdout.writeAll(html_str);
       }
   }
   ```

   Note: For HTML, when --output-file is specified, write only to file (not stdout). When not specified, write to stdout. This differs from JSON which writes to both — HTML output is typically large and piping to file is the primary use case.

3. Add html_output.zig to the test import block at the bottom of main.zig:
   ```zig
   _ = @import("output/html_output.zig");
   ```

**Verify the full build works:**
Run `zig build` to confirm compilation. Run `zig build test` to confirm all tests pass including the new html_output tests.
  </action>
  <verify>Run `zig build` (no compile errors). Run `zig build test` (all tests pass). Run `zig build run -- --format html tests/fixtures/` and verify HTML output is produced to stdout.</verify>
  <done>main.zig dispatches to html_output.buildHtmlReport when --format html is used. HTML report is written to stdout or --output-file. Test imports include html_output.zig. Build and all tests pass.</done>
</task>

</tasks>

<verification>
1. `zig build test` — all existing tests pass plus new html_output tests
2. `zig build run -- --format html tests/fixtures/` — produces HTML output to stdout
3. `zig build run -- --format html --output-file report.html tests/fixtures/` — creates report.html
4. Open report.html in browser — shows dashboard with health score, grade, distribution bar, hotspot cards
5. HTML contains no `<link` or `<script src` external references (fully self-contained)
6. Inspect in both light and dark browser themes — colors adapt via prefers-color-scheme
</verification>

<success_criteria>
- html_output.zig module exists with buildHtmlReport, all helper functions, embedded CSS/JS, and inline tests
- main.zig format dispatch handles "html" format correctly
- Generated HTML is self-contained (inline CSS/JS, no external references)
- Dashboard displays health score + letter grade, distribution bar, summary stats, top 5 hotspot cards
- All user-provided strings are HTML-escaped
- prefers-color-scheme media query enables auto light/dark mode
- `zig build test` passes with no failures
</success_criteria>

<output>
After completion, create `.planning/phases/10-html-reports/10-01-SUMMARY.md`
</output>
