---
phase: 03-file-discovery-parsing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/discovery/walker.zig
  - src/discovery/filter.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tool recursively discovers .ts, .tsx, .js, .jsx files in a directory"
    - "Tool excludes .d.ts declaration files from discovery"
    - "Tool excludes node_modules and other common non-source directories"
    - "Tool supports include/exclude patterns from config"
  artifacts:
    - path: "src/discovery/walker.zig"
      provides: "Recursive directory traversal collecting file paths"
      exports: ["discoverFiles", "DiscoveryResult"]
    - path: "src/discovery/filter.zig"
      provides: "File extension filtering and path exclusion logic"
      exports: ["isTargetFile", "isExcludedDir", "FilterConfig"]
  key_links:
    - from: "src/discovery/walker.zig"
      to: "src/discovery/filter.zig"
      via: "import and call isTargetFile/isExcludedDir"
      pattern: "@import.*filter"
    - from: "src/discovery/walker.zig"
      to: "std.fs.Dir.walk"
      via: "stdlib directory iteration"
      pattern: "dir\\.walk"
---

<objective>
Create the file discovery subsystem that recursively walks directories to find
TypeScript and JavaScript source files, filtering by extension and excluding
non-source directories.

Purpose: File discovery is independent of tree-sitter parsing and can be built
and tested in parallel with Plan 01. This separation lets us verify directory
traversal correctness using the existing test fixtures.

Output: src/discovery/walker.zig and src/discovery/filter.zig providing a
discoverFiles() function that returns a list of source file paths.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-file-discovery-parsing/03-RESEARCH.md
@src/main.zig
@src/cli/config.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create file extension filter module</name>
  <files>
    src/discovery/filter.zig
    src/main.zig
  </files>
  <action>
    Create `src/discovery/filter.zig` with the following:

    1. Define `FilterConfig` struct:
       ```
       pub const FilterConfig = struct {
           include_patterns: ?[]const []const u8 = null,  // from config files.include
           exclude_patterns: ?[]const []const u8 = null,  // from config files.exclude
       };
       ```

    2. Define target extensions as a comptime array:
       ```
       const TARGET_EXTENSIONS = [_][]const u8{ ".ts", ".tsx", ".js", ".jsx" };
       ```

    3. Create `isTargetFile(path: []const u8) bool`:
       - Check path ends with any TARGET_EXTENSIONS using `std.mem.endsWith()`
       - Exclude `.d.ts` files: if path ends with `.d.ts`, return false (check BEFORE `.ts` match)
       - Exclude `.d.tsx` files similarly (rare but consistent)

    4. Create `isExcludedDir(name: []const u8) bool`:
       - Return true for: "node_modules", ".git", "dist", "build", ".next", "coverage",
         "__pycache__", ".svn", ".hg", "vendor" (common non-source directories)
       - Use a comptime array of excluded names and `std.mem.eql()` comparison

    5. Create `shouldIncludeFile(path: []const u8, config: FilterConfig) bool`:
       - If config.include_patterns is null and config.exclude_patterns is null,
         just return `isTargetFile(path)`
       - If include_patterns is set, check if path matches any include pattern
         using simple `std.mem.endsWith()` for extension patterns (e.g., "*.ts")
         and `std.mem.indexOf()` for substring patterns. This is intentionally
         simple -- full glob matching deferred to later phase per research recommendation.
       - If exclude_patterns is set, check if path matches any exclude pattern
         and return false if so
       - Always check isTargetFile as the base filter

    6. Add inline tests:
       - `isTargetFile("foo.ts")` -> true
       - `isTargetFile("foo.tsx")` -> true
       - `isTargetFile("foo.js")` -> true
       - `isTargetFile("foo.jsx")` -> true
       - `isTargetFile("foo.d.ts")` -> false (declaration file)
       - `isTargetFile("foo.css")` -> false
       - `isTargetFile("foo.zig")` -> false
       - `isTargetFile("types.d.ts")` -> false
       - `isExcludedDir("node_modules")` -> true
       - `isExcludedDir("src")` -> false
       - `isExcludedDir(".git")` -> true

    7. Update src/main.zig test block to add `_ = @import("discovery/filter.zig");`
  </action>
  <verify>
    Run `zig build test` -- all filter tests pass. Extension matching is correct,
    .d.ts exclusion works, directory exclusion works.
  </verify>
  <done>
    src/discovery/filter.zig exists with isTargetFile, isExcludedDir, shouldIncludeFile,
    and FilterConfig. All tests pass including edge cases (.d.ts, non-source extensions).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create recursive directory walker</name>
  <files>
    src/discovery/walker.zig
    src/main.zig
  </files>
  <action>
    Create `src/discovery/walker.zig` with the following:

    1. Define `DiscoveryResult` struct:
       ```
       pub const DiscoveryResult = struct {
           files: [][]const u8,       // owned paths (caller must free each + slice)
           skipped_count: u32,        // files that matched extension but were excluded
           dir_count: u32,            // directories traversed

           pub fn deinit(self: *DiscoveryResult, allocator: Allocator) void {
               for (self.files) |path| {
                   allocator.free(path);
               }
               allocator.free(self.files);
           }
       };
       ```

    2. Define `DiscoveryError`:
       ```
       pub const DiscoveryError = error{
           DirectoryNotFound,
           PermissionDenied,
       } || std.mem.Allocator.Error || std.fs.Dir.OpenError;
       ```

    3. Create `discoverFiles(allocator: Allocator, paths: []const []const u8, filter_config: filter.FilterConfig) !DiscoveryResult`:
       - For each path in paths:
         - If path is a file (check with std.fs.cwd().statFile()), add directly if it matches filter
         - If path is a directory, walk recursively
       - For directory walking:
         - Open directory with `std.fs.cwd().openDir(path, .{ .iterate = true })`
         - Create walker with arena allocator for internal state
         - Iterate with `walker.next()`, skip non-files
         - Use `filter.isExcludedDir()` to skip excluded directories by checking path components
         - Use `filter.shouldIncludeFile()` to filter matching files
         - CRITICAL: Copy entry.path with `allocator.dupe(u8, entry.path)` -- walker reuses buffer
         - Prepend the base path to create relative-to-cwd paths
       - Return DiscoveryResult with collected files, counts

    4. Handle the Zig 0.15.2 walker API correctly:
       - `std.fs.Dir.walk()` in Zig 0.15.2 takes an allocator argument
       - Use `var walker = try dir.walk(arena_alloc);`
       - walker.next() returns `?Walker.Entry` where entry has `.path` and `.kind`
       - Check `entry.kind == .file` to skip directories/symlinks
       - For directory exclusion, check if any component of entry.path matches excluded dirs
         using `std.mem.indexOf(u8, entry.path, "node_modules")` etc., or split on path separator

    5. Add inline tests using the existing tests/fixtures/ directory:
       - Discover files in "tests/fixtures/typescript" -> should find 4 .ts files
       - Discover files in "tests/fixtures/javascript" -> should find 2 .js files
       - Discover files in "tests/fixtures" -> should find all 6 files
       - Discover single file path "tests/fixtures/typescript/simple_function.ts" -> 1 file
       - Empty directory -> returns 0 files (create temp dir in test)
       - FilterConfig with exclude pattern -> respects exclusion
       - Verify DiscoveryResult.deinit() frees all memory (use testing.allocator)

    6. Update src/main.zig test block to add `_ = @import("discovery/walker.zig");`
  </action>
  <verify>
    Run `zig build test` -- all walker tests pass. Discovery finds correct files in
    tests/fixtures/ directory tree. Memory is properly freed (testing.allocator catches leaks).
  </verify>
  <done>
    src/discovery/walker.zig exists with discoverFiles() function. It recursively walks
    directories, filters by extension (via filter.zig), excludes .d.ts and node_modules,
    copies paths correctly, and returns DiscoveryResult. Tests verify against real
    tests/fixtures/ files. No memory leaks.
  </done>
</task>

</tasks>

<verification>
- `zig build test` passes all tests (filter + walker + existing)
- Discovery correctly finds .ts/.tsx/.js/.jsx files in tests/fixtures/
- .d.ts files are excluded
- node_modules directories are excluded
- Single file paths work (not just directories)
- No memory leaks (testing.allocator)
</verification>

<success_criteria>
File discovery subsystem recursively walks directories, filters by extension,
excludes declaration files and non-source directories, and returns owned paths.
Tests verify against real fixture files in tests/fixtures/.
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-discovery-parsing/03-02-SUMMARY.md`
</output>
