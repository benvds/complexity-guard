---
phase: 03-file-discovery-parsing
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - src/parser/parse.zig
  - src/main.zig
  - tests/fixtures/typescript/syntax_error.ts
  - tests/fixtures/typescript/react_component.tsx
  - tests/fixtures/javascript/jsx_component.jsx
autonomous: true

must_haves:
  truths:
    - "Tool parses .ts files via tree-sitter TypeScript grammar"
    - "Tool parses .tsx files via tree-sitter TSX grammar"
    - "Tool parses .js files via tree-sitter JavaScript grammar"
    - "Tool parses .jsx files via tree-sitter JavaScript grammar"
    - "Tool handles syntax errors gracefully (reports error, continues with other files)"
    - "Tool integrates discovery and parsing into main.zig analysis flow"
  artifacts:
    - path: "src/parser/parse.zig"
      provides: "High-level parse orchestration: file reading, language selection, parsing, error reporting"
      exports: ["parseFile", "parseFiles", "ParseResult", "ParseError"]
    - path: "tests/fixtures/typescript/react_component.tsx"
      provides: "TSX fixture for parser verification"
    - path: "tests/fixtures/javascript/jsx_component.jsx"
      provides: "JSX fixture for parser verification"
    - path: "tests/fixtures/typescript/syntax_error.ts"
      provides: "Intentionally broken TypeScript for error handling verification"
  key_links:
    - from: "src/parser/parse.zig"
      to: "src/parser/tree_sitter.zig"
      via: "import Parser, Language, Tree"
      pattern: "@import.*tree_sitter"
    - from: "src/parser/parse.zig"
      to: "src/discovery/filter.zig"
      via: "selectLanguage uses extension logic"
      pattern: "endsWith.*\\.ts"
    - from: "src/main.zig"
      to: "src/parser/parse.zig"
      via: "import and call parseFiles"
      pattern: "@import.*parse"
    - from: "src/main.zig"
      to: "src/discovery/walker.zig"
      via: "import and call discoverFiles"
      pattern: "@import.*walker"
---

<objective>
Create the parse orchestration module that reads discovered files, selects the correct
tree-sitter language grammar, parses each file, and reports results. Wire discovery +
parsing into main.zig so the tool actually discovers and parses files end-to-end.

Purpose: This is the integration plan that connects file discovery (Plan 02) with
tree-sitter bindings (Plan 01) into a working pipeline. After this plan, running
`complexity-guard src/` will discover files, parse them, and report what was found.

Output: src/parser/parse.zig with parseFile/parseFiles, updated main.zig with real
analysis flow, test fixtures for .tsx and .jsx, fixture with syntax errors.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-file-discovery-parsing/03-RESEARCH.md
@.planning/phases/03-file-discovery-parsing/03-01-SUMMARY.md
@.planning/phases/03-file-discovery-parsing/03-02-SUMMARY.md
@src/main.zig
@src/core/types.zig
@src/parser/tree_sitter.zig
@src/discovery/walker.zig
@src/discovery/filter.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for TSX, JSX, and syntax errors</name>
  <files>
    tests/fixtures/typescript/react_component.tsx
    tests/fixtures/javascript/jsx_component.jsx
    tests/fixtures/typescript/syntax_error.ts
  </files>
  <action>
    Create three new test fixture files:

    1. `tests/fixtures/typescript/react_component.tsx` -- A simple React component:
       ```tsx
       // Fixture: React component with JSX (TSX)
       // Expected: Parses as TSX, contains function and JSX elements
       import React from 'react';

       interface Props {
         name: string;
         count: number;
       }

       export function Greeting({ name, count }: Props): JSX.Element {
         if (count > 10) {
           return <div className="warning">Too many: {count}</div>;
         }
         return (
           <div className="greeting">
             <h1>Hello, {name}!</h1>
             <p>Count: {count}</p>
           </div>
         );
       }

       export const Badge: React.FC<{ label: string }> = ({ label }) => (
         <span className="badge">{label}</span>
       );
       ```

    2. `tests/fixtures/javascript/jsx_component.jsx` -- A JSX component:
       ```jsx
       // Fixture: JavaScript component with JSX
       // Expected: Parses as JavaScript, contains JSX elements
       import React from 'react';

       export function Card({ title, children }) {
         return (
           <div className="card">
             <h2>{title}</h2>
             <div className="card-body">{children}</div>
           </div>
         );
       }

       export const List = ({ items }) => (
         <ul>
           {items.map((item, i) => (
             <li key={i}>{item}</li>
           ))}
         </ul>
       );
       ```

    3. `tests/fixtures/typescript/syntax_error.ts` -- Intentionally broken TypeScript:
       ```ts
       // Fixture: TypeScript with syntax errors
       // Expected: Tree-sitter produces tree with ERROR nodes but still parseable
       // Used to verify graceful error handling (PARSE-05)

       export function validFunction(x: number): number {
         return x * 2;
       }

       // Intentional syntax error: missing closing brace
       export function brokenFunction(y: string) {
         if (y.length > 0) {
           console.log(y);
         // missing closing brace for function

       export function anotherValidFunction(): void {
         console.log("still valid");
       }
       ```
  </action>
  <verify>
    Verify fixture files exist and contain valid content:
    `ls tests/fixtures/typescript/react_component.tsx tests/fixtures/javascript/jsx_component.jsx tests/fixtures/typescript/syntax_error.ts`
  </verify>
  <done>
    Three fixture files exist: .tsx component, .jsx component, and .ts with syntax errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create parse orchestration module and wire into main.zig</name>
  <files>
    src/parser/parse.zig
    src/main.zig
  </files>
  <action>
    Create `src/parser/parse.zig` that orchestrates file parsing:

    1. Define `ParseResult` struct:
       ```
       pub const ParseResult = struct {
           path: []const u8,           // file path (borrowed, not owned)
           tree: ?tree_sitter.Tree,    // parsed tree (null if parse failed completely)
           language: tree_sitter.Language,  // which grammar was used
           has_errors: bool,           // true if tree contains ERROR/MISSING nodes
           source: []const u8,         // file contents (owned by caller)
       };
       ```

    2. Define `FileParseError` struct for error reporting:
       ```
       pub const FileParseError = struct {
           path: []const u8,
           message: []const u8,
       };
       ```

    3. Define `ParseSummary` struct:
       ```
       pub const ParseSummary = struct {
           results: []ParseResult,       // successfully parsed files
           errors: []FileParseError,     // files that failed to parse
           total_files: u32,
           successful_parses: u32,
           files_with_errors: u32,       // parsed but had syntax errors
           failed_parses: u32,           // could not parse at all

           pub fn deinit(self: *ParseSummary, allocator: Allocator) void {
               for (self.results) |*result| {
                   if (result.tree) |*tree| tree.deinit();
                   allocator.free(result.source);
               }
               allocator.free(self.results);
               allocator.free(self.errors);
           }
       };
       ```

    4. Create `selectLanguage(path: []const u8) !tree_sitter.Language`:
       - `.tsx` -> .tsx
       - `.ts` -> .typescript  (check .tsx first since .ts is suffix of .tsx)
       - `.jsx` -> .javascript
       - `.js` -> .javascript
       - Else -> return error.UnsupportedFileType

    5. Create `parseFile(allocator: Allocator, base_dir: ?[]const u8, relative_path: []const u8) !ParseResult`:
       - Construct full path by joining base_dir and relative_path if base_dir is non-null
       - Read file contents using `std.fs.cwd().readFileAlloc(allocator, full_path, 10 * 1024 * 1024)` (10MB max)
       - Select language from file extension
       - Create parser, set language, parse source string
       - Check root node for errors via `ts_node_has_error()`
       - Return ParseResult with tree, language, has_errors flag
       - On file read error, return the error (caller handles)
       - Parser and tree ownership: the Tree is MOVED into ParseResult (do NOT defer ts_tree_delete
         inside this function -- the caller owns the tree via ParseResult)
       - But DO defer ts_parser_delete -- parser is only needed during parsing

    6. Create `parseFiles(allocator: Allocator, file_paths: []const []const u8) !ParseSummary`:
       - Iterate over all file paths
       - Call parseFile for each
       - Collect results and errors
       - Count successful, errored, and failed parses
       - If parseFile returns error, create FileParseError entry and continue with next file
       - Return ParseSummary

    7. Add inline tests:
       - Parse "tests/fixtures/typescript/simple_function.ts" -> success, no errors, typescript language
       - Parse "tests/fixtures/typescript/react_component.tsx" -> success, tsx language
       - Parse "tests/fixtures/javascript/callback_patterns.js" -> success, javascript language
       - Parse "tests/fixtures/javascript/jsx_component.jsx" -> success, javascript language
       - Parse "tests/fixtures/typescript/syntax_error.ts" -> success (tree returned), has_errors = true
       - selectLanguage routing tests for each extension
       - parseFiles on multiple paths -> correct counts in ParseSummary
       - parseFiles with nonexistent file -> appears in errors, other files still parsed
       - Memory cleanup: ParseSummary.deinit() frees all trees and sources (testing.allocator)

    8. Update `src/main.zig`:
       - Import walker and parse modules
       - Replace the placeholder "analysis not yet implemented" block with:
         a. Create FilterConfig from cfg.files (include/exclude from config)
         b. Call `walker.discoverFiles(arena_allocator, analysis_paths, filter_config)`
         c. Call `parse.parseFiles(arena_allocator, discovery_result.files)`
         d. Print summary: "Discovered N files, parsed M successfully, K with errors, J failed"
         e. If verbose mode, print each file path and its parse status
       - Handle errors appropriately with stderr messages
       - The arena allocator handles cleanup (no manual free needed for CLI lifecycle)

    9. Update src/main.zig test block to add `_ = @import("parser/parse.zig");`
  </action>
  <verify>
    Run `zig build test` -- all tests pass including parse module tests.
    Run `zig build run -- tests/fixtures/` -- tool discovers and parses fixture files, prints summary.
    Run `zig build run -- tests/fixtures/typescript/simple_function.ts` -- parses single file.
    Run `zig build run -- nonexistent/` -- graceful error handling.
  </verify>
  <done>
    src/parser/parse.zig exists with parseFile, parseFiles, ParseResult, ParseSummary.
    main.zig calls discovery + parsing and prints results.
    Running `complexity-guard tests/fixtures/` discovers 6+ files, parses all, reports results.
    Syntax errors are reported but don't stop analysis of other files.
    All four file types (.ts, .tsx, .js, .jsx) parse with correct language grammar.
    No memory leaks in tests.
  </done>
</task>

</tasks>

<verification>
- `zig build test` passes all tests (tree_sitter + filter + walker + parse + existing)
- `zig build run -- tests/fixtures/` discovers and parses all fixture files
- TSX files use TSX grammar (not TypeScript grammar)
- JSX files use JavaScript grammar
- Syntax error fixture reports errors but parsing continues
- Summary output shows correct counts
- No memory leaks (testing.allocator in all tests)
- Single file mode works: `zig build run -- tests/fixtures/typescript/simple_function.ts`
</verification>

<success_criteria>
End-to-end pipeline works: user runs `complexity-guard <path>`, tool discovers TS/JS files,
parses each with correct tree-sitter grammar, reports summary. Syntax errors are graceful.
All four file types (.ts, .tsx, .js, .jsx) are handled. This satisfies PARSE-01 through
PARSE-06 requirements.
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-discovery-parsing/03-03-SUMMARY.md`
</output>
