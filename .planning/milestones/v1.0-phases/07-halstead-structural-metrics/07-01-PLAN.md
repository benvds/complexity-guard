---
phase: 07-halstead-structural-metrics
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/metrics/halstead.zig
  - tests/fixtures/typescript/halstead_cases.ts
autonomous: true
requirements:
  - HALT-01
  - HALT-02
  - HALT-03
  - HALT-04

must_haves:
  truths:
    - "Halstead walker classifies JS/TS leaf nodes as operators, operands, or skip"
    - "TypeScript type-only syntax is excluded from Halstead counts (TS scores same as equivalent JS)"
    - "Decorators (@Component, @Injectable) count as operators"
    - "Empty functions and zero-operand edge cases produce zeroed metrics without panicking"
    - "Halstead formulas (vocabulary, volume, difficulty, effort, time, bugs) compute correctly from base counts"
  artifacts:
    - path: "src/metrics/halstead.zig"
      provides: "Halstead token classification, counting, and formula computation"
      exports: ["HalsteadMetrics", "HalsteadConfig", "calculateHalstead", "computeHalsteadMetrics", "analyzeFunctions"]
    - path: "tests/fixtures/typescript/halstead_cases.ts"
      provides: "Annotated test fixture for Halstead metric validation"
      min_lines: 30
  key_links:
    - from: "src/metrics/halstead.zig"
      to: "src/parser/tree_sitter.zig"
      via: "tree_sitter.Node API for AST traversal"
      pattern: "tree_sitter\\.Node"
    - from: "src/metrics/halstead.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "isFunctionNode, extractFunctionInfo, walkAndAnalyze pattern"
      pattern: "cyclomatic\\.isFunctionNode"
---

<objective>
Implement Halstead metrics core: token classification (operators vs operands), base count accumulation (n1, n2, N1, N2), and derived metric computation (vocabulary, volume, difficulty, effort, time, bugs).

Purpose: Enable information-theoretic complexity measurement per function. Halstead metrics quantify the "mental effort" to understand code based on operator/operand diversity and frequency.
Output: `src/metrics/halstead.zig` module with full TDD coverage, `tests/fixtures/typescript/halstead_cases.ts` fixture.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-halstead-structural-metrics/07-RESEARCH.md
@.planning/phases/07-halstead-structural-metrics/07-CONTEXT.md
@src/metrics/cyclomatic.zig
@src/metrics/cognitive.zig
@src/parser/tree_sitter.zig
</context>

<feature>
  <name>Halstead Metrics Core</name>
  <files>src/metrics/halstead.zig, tests/fixtures/typescript/halstead_cases.ts</files>
  <behavior>
    **Token Classification (HALT-01):**
    Walk function body AST, classifying LEAF nodes only (childCount() == 0) by nodeType():

    Operators (use the text from source as the distinct key):
    - Arithmetic: +, -, *, /, %, **
    - Comparison: ==, !=, ===, !==, <, >, <=, >=
    - Logical: &&, ||, ??
    - Assignment: =, +=, -=, *=, /=, %=, **=, &&=, ||=, ??=, <<=, >>=, >>>=, &=, |=, ^=
    - Bitwise: &, |, ^, ~, <<, >>, >>>
    - Unary keywords: typeof, void, delete, await, yield
    - Unary symbols: !, ++, --
    - Control flow keywords: if, else, for, while, do, switch, case, default, break, continue, return, throw, try, catch, finally, new, in, of, instanceof
    - Punctuation-operators: , (comma separator)
    - Decorators: @ (locked decision: decorators are runtime operators)

    Operands (use the text from source as the distinct key):
    - identifier (variable/function names)
    - number, string, template_string, regex (literals)
    - true, false, null, undefined (special literals)
    - this keyword
    - property_identifier (object property names like obj.prop)

    Skip entirely (neither operator nor operand):
    - TypeScript type nodes: type_annotation, type_identifier, generic_type, type_parameters, type_parameter, predefined_type, union_type, intersection_type, array_type, object_type, tuple_type, function_type, readonly_type, type_query, as_expression (skip entire subtree), satisfies_expression (skip entire subtree)
    - interface_declaration, type_alias_declaration: skip entire node
    - Comments: comment
    - Structural punctuation: {, }, ;, (, ), [, ], =>, :, ?
    - Note: ( and ) are structural in tree-sitter — function calls are represented as call_expression nodes, not by counting parens. The call_expression parent is what matters, but since we only classify leaves, we skip parens and let the function name (identifier) count as operand. Ternary ? and : are leaf tokens under ternary_expression — skip them individually but count ternary_expression node type "?:" as one operator when entering the ternary node (special case: count non-leaf node as operator).

    Special handling:
    - ternary_expression: When entering this non-leaf node, add one operator occurrence with key "?:" before recursing into children. The leaf ? and : tokens are skipped.
    - Nested function boundaries: Stop recursion at function nodes (same scope isolation as cyclomatic/cognitive).

    **Base Counts (HALT-02):**
    - n1 = distinct operators count (HashMap size)
    - n2 = distinct operands count (HashMap size)
    - N1 = total operator occurrences
    - N2 = total operand occurrences
    - Use std.StringHashMap(void) for distinct tracking (keys = operator/operand text)

    **Derived Metrics (HALT-03):**
    - Vocabulary: n = n1 + n2
    - Length: N = N1 + N2
    - Volume: V = N * log2(n) using std.math.log2
    - Difficulty: D = (n1/2) * (N2/n2), 0 if n2 == 0
    - Effort: E = V * D
    - Time: T = E / 18 (seconds)
    - Bugs: B = V / 3000

    **Edge Cases (HALT-04):**
    - Empty function body (n1=0, n2=0): all derived metrics = 0
    - Only operators, no operands (n2=0): difficulty=0, effort=0, time=0, bugs = V/3000
    - Only operands, no operators (n1=0): difficulty=0, effort=0, time=0, bugs = V/3000

    **Test cases:**
    - simpleAssignment: `const result = x + 1; return result;`
      operators: {=, +, return} (n1=3), operands: {result, x, 1} (n2=3)
      N1=3, N2=4 (result appears twice), vocab=6, len=7, volume=7*log2(6)~18.09
    - withTypeAnnotations: `return age > 0;` (types excluded)
      operators: {return, >} (n1=2), operands: {age, 0} (n2=2)
      Should score identical whether TS or JS
    - emptyFunction: `function empty(): void {}` -> all zeros
    - singleExpressionArrow: `const add = (a, b) => a + b;`
      operators: {=, +} (n1=2), operands: {add, a, b} (n2=3), N1=2, N2=5
  </behavior>
  <implementation>
    1. Create `src/metrics/halstead.zig` with:
       - HalsteadMetrics struct (n1, n2, n1_total, n2_total, vocabulary, length, volume, difficulty, effort, time, bugs — all stored as the appropriate type)
       - HalsteadConfig struct with threshold pairs (volume, difficulty, effort, bugs) using industry defaults from research: volume_warning=500/error=1000, difficulty_warning=10/error=20, effort_warning=5000/error=10000, bugs_warning=0.5/error=2.0
       - isTypeOnlyNode() function with the full TypeScript skip-list
       - isOperatorToken() and isOperandToken() classification functions
       - classifyNode() recursive walker that processes leaf nodes and handles ternary_expression special case
       - calculateHalstead(allocator, function_body_node, source) -> HalsteadMetrics
       - computeHalsteadMetrics(n1, n2, N1, N2) -> HalsteadMetrics (pure formula computation with edge case guards)
       - analyzeFunctions(allocator, root, config, source) -> []HalsteadFunctionResult following the walkAndAnalyze pattern from cyclomatic.zig

    2. Create `tests/fixtures/typescript/halstead_cases.ts` with annotated test cases:
       - simpleAssignment (basic operators + operands)
       - withTypeAnnotations (verify type exclusion)
       - emptyFunction (edge case: all zeros)
       - singleExpressionArrow (arrow function)
       - complexLogic (multiple operator types: logical, comparison, assignment)
       - decoratorCase (verify @ counts as operator)

    3. Write tests in halstead.zig below // TESTS comment:
       - computeHalsteadMetrics formula correctness tests (known inputs -> known outputs)
       - Edge case: zero operands -> difficulty = 0, no panic
       - Edge case: zero vocabulary -> all metrics = 0
       - isTypeOnlyNode returns true for all TS type nodes
       - Integration test: parse fixture file, run calculateHalstead on known function, verify base counts
       - Type exclusion test: TS function with types should produce same Halstead as equivalent JS function

    Memory management: Use arena allocator passed through. StringHashMap instances created inside calculateHalstead are deferred with deinit(). Only the final HalsteadMetrics struct (all primitives) is returned.

    Import in main.zig test block: `_ = @import("metrics/halstead.zig");`
  </implementation>
</feature>

<verification>
```bash
zig build test 2>&1 | head -20
# All tests pass, no memory leaks reported by std.testing.allocator
```
- Halstead formula tests produce mathematically correct results
- Empty function produces all-zero metrics without panic
- TypeScript type annotations do not affect Halstead scores
- analyzeFunctions returns same-order results as cyclomatic/cognitive walkers
</verification>

<success_criteria>
- src/metrics/halstead.zig exists with HalsteadMetrics, HalsteadConfig, calculateHalstead, analyzeFunctions
- All Halstead formula edge cases handled (zero operands, zero vocabulary)
- TypeScript type-only syntax excluded from counts (locked decision honored)
- Decorators counted as operators (locked decision honored)
- Tests pass with std.testing.allocator (no leaks)
- tests/fixtures/typescript/halstead_cases.ts has annotated test cases
</success_criteria>

<output>
After completion, create `.planning/phases/07-halstead-structural-metrics/07-01-SUMMARY.md`
</output>
