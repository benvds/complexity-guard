---
phase: 09-sarif-output
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/output/sarif_output.zig
  - src/main.zig
autonomous: true
requirements:
  - OUT-SARIF-01
  - OUT-SARIF-02
  - OUT-SARIF-03
  - OUT-SARIF-04

must_haves:
  truths:
    - "Running --format sarif produces valid SARIF 2.1.0 JSON with $schema, version, and runs array"
    - "Each metric violation produces a separate SARIF result with correct ruleId, level, and physicalLocation"
    - "SARIF startColumn values are 1-indexed (internal 0-indexed start_col + 1)"
    - "Violations-only: passing functions produce no SARIF results"
    - "Baseline ratchet failures produce file-level SARIF results at startLine 1"
    - "--metrics filtering limits which metric violations appear in SARIF output"
    - "Empty project produces valid SARIF with empty results array"
  artifacts:
    - path: "src/output/sarif_output.zig"
      provides: "SARIF 2.1.0 struct definitions, rule constants, build and serialize functions"
      contains: "SarifLog"
    - path: "src/main.zig"
      provides: "Format dispatch for sarif alongside json and console"
      contains: "sarif"
  key_links:
    - from: "src/output/sarif_output.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "ThresholdResult and ThresholdStatus imports"
      pattern: "cyclomatic\\.ThresholdResult"
    - from: "src/output/sarif_output.zig"
      to: "src/output/console.zig"
      via: "FileThresholdResults import"
      pattern: "console\\.FileThresholdResults"
    - from: "src/main.zig"
      to: "src/output/sarif_output.zig"
      via: "import and format dispatch branch"
      pattern: "sarif_output"
---

<objective>
Implement the SARIF 2.1.0 output module and wire it into the main pipeline as a new `--format sarif` option.

Purpose: Enable GitHub Code Scanning integration by outputting analysis results in SARIF format, mapping metric violations to inline PR annotations.

Output: Working `src/output/sarif_output.zig` module with SARIF struct types, 10 rule definitions, build/serialize functions, inline tests, and `main.zig` format dispatch wiring.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-sarif-output/09-CONTEXT.md
@.planning/phases/09-sarif-output/09-RESEARCH.md

Key source files:
@src/output/json_output.zig — follow this pattern for struct-based JSON serialization
@src/output/console.zig — FileThresholdResults type used as input
@src/output/exit_codes.zig — worstStatusAll, ThresholdStatus helpers
@src/metrics/cyclomatic.zig — ThresholdResult struct definition, ThresholdStatus enum, validateThreshold
@src/main.zig — format dispatch logic to extend
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SARIF output module with struct types, rule definitions, and build/serialize functions</name>
  <files>src/output/sarif_output.zig</files>
  <action>
Create `src/output/sarif_output.zig` following the pattern established by `json_output.zig`.

**SARIF Struct Definitions:**

Define Zig structs that map 1:1 to the SARIF 2.1.0 JSON schema. Use `@"$schema"` syntax for the `$schema` field (Zig keyword escaping — `std.json.Stringify` correctly serializes this as `"$schema"` in output):

```
SarifLog { @"$schema", version, runs }
SarifRun { tool, results }
SarifTool { driver }
SarifDriver { name, version, informationUri, rules }
SarifRule { id, name, shortDescription, fullDescription, defaultConfiguration, helpUri, help }
SarifConfiguration { level }
SarifMessage { text }
SarifResult { ruleId, ruleIndex, level, message, locations }
SarifLocation { physicalLocation }
SarifPhysicalLocation { artifactLocation, region }
SarifArtifactLocation { uri }
SarifRegion { startLine, startColumn, endLine }
```

Use `[]const u8` for string fields, `u32` for numeric fields, `[]const T` for arrays.

**SarifThresholds struct:**

Create a `SarifThresholds` struct that aggregates all threshold values needed for message formatting:
```
cyclomatic_warning: u32, cyclomatic_error: u32
cognitive_warning: u32, cognitive_error: u32
halstead_volume_warning: f64, halstead_volume_error: f64
halstead_difficulty_warning: f64, halstead_difficulty_error: f64
halstead_effort_warning: f64, halstead_effort_error: f64
halstead_bugs_warning: f64, halstead_bugs_error: f64
line_count_warning: u32, line_count_error: u32
param_count_warning: u32, param_count_error: u32
nesting_depth_warning: u32, nesting_depth_error: u32
```

**Rule Definitions (10 rules, fixed order):**

Create a function `buildRules(allocator)` or use comptime arrays to define the 10 rules. Each rule has:
- `id`: `"complexity-guard/cyclomatic"`, `"complexity-guard/cognitive"`, `"complexity-guard/halstead-volume"`, `"complexity-guard/halstead-difficulty"`, `"complexity-guard/halstead-effort"`, `"complexity-guard/halstead-bugs"`, `"complexity-guard/line-count"`, `"complexity-guard/param-count"`, `"complexity-guard/nesting-depth"`, `"complexity-guard/health-score"`
- `name`: PascalCase version (e.g., `"CyclomaticComplexity"`, `"HalsteadVolume"`, `"HealthScore"`)
- `shortDescription.text`: Brief (e.g., `"Cyclomatic complexity exceeded threshold"`)
- `fullDescription.text`: Full explanation with formula and interpretation
- `defaultConfiguration.level`: `"warning"` for all function-level metrics, `"warning"` for health-score
- `helpUri`: Use `"https://github.com/AstroTechDev/complexity-guard/blob/main/docs/cyclomatic-complexity.md"` pattern for cyclomatic/cognitive/halstead/structural/health-score pages
- `help.text`: Actionable remediation advice

Rule index constants (comptime):
```
RULE_CYCLOMATIC = 0, RULE_COGNITIVE = 1, RULE_HALSTEAD_VOLUME = 2,
RULE_HALSTEAD_DIFFICULTY = 3, RULE_HALSTEAD_EFFORT = 4, RULE_HALSTEAD_BUGS = 5,
RULE_LINE_COUNT = 6, RULE_PARAM_COUNT = 7, RULE_NESTING_DEPTH = 8, RULE_HEALTH_SCORE = 9
```

**Build Function:**

```zig
pub fn buildSarifOutput(
    allocator: Allocator,
    file_results: []const console.FileThresholdResults,
    tool_version: []const u8,
    baseline_failed: bool,
    baseline_value: ?f64,
    project_score: f64,
    selected_metrics: ?[]const []const u8,
    thresholds: SarifThresholds,
) !SarifLog
```

Implementation:
1. Build the `rules` array (all 10 rules, or filtered by `selected_metrics` — simpler to always include all 10)
2. Iterate each file, each function result within:
   - For each metric (cyclomatic, cognitive, halstead-volume, halstead-difficulty, halstead-effort, halstead-bugs, line-count, param-count, nesting-depth):
     - Check `isMetricEnabled(selected_metrics, metric_family)` — use same logic as console.zig: cyclomatic/cognitive standalone, halstead-* under "halstead", line-count/param-count/nesting-depth under "structural"
     - If the metric's status is `.warning` or `.@"error"`, emit a `SarifResult`:
       - `ruleId`: e.g., `"complexity-guard/cyclomatic"`
       - `ruleIndex`: corresponding constant
       - `level`: map ThresholdStatus `.warning` -> `"warning"`, `.@"error"` -> `"error"`
       - `message.text`: Score + threshold format per locked decision, e.g., `"Cyclomatic complexity is 15 (warning threshold: 10, error threshold: 20)"`. Use `std.fmt.allocPrint` to build message strings.
       - `locations[0].physicalLocation.artifactLocation.uri`: `fr.path` (already relative)
       - `locations[0].physicalLocation.region.startLine`: `result.start_line` (already 1-indexed)
       - `locations[0].physicalLocation.region.startColumn`: `result.start_col + 1` (CRITICAL: convert 0-indexed to 1-indexed)
       - `locations[0].physicalLocation.region.endLine`: `result.end_line` (full function body span)
3. After all function-level results, check `baseline_failed`:
   - If true, iterate file_results to find files where health score is below baseline. For each such file, emit a `SarifResult` with:
     - `ruleId`: `"complexity-guard/health-score"`
     - `ruleIndex`: `RULE_HEALTH_SCORE` (9)
     - `level`: `"error"` (baseline failures are errors per exit code priority)
     - `message.text`: e.g., `"File health score: 42.5 (baseline: 60.0). Worst contributors: cyclomatic (3 violations), cognitive (2 violations)"`. Count violations per metric family. Use `std.fmt.allocPrint`.
     - Location: `startLine: 1`, `startColumn: 1`, `endLine: 1` (file-level)
4. Assemble the `SarifLog`:
   - `@"$schema"`: `"https://json.schemastore.org/sarif-2.1.0.json"`
   - `version`: `"2.1.0"`
   - `runs`: single-element array with the run

**Serialize Function:**

```zig
pub fn serializeSarifOutput(allocator: Allocator, output: SarifLog) ![]u8
```

Use `std.json.Stringify.valueAlloc(allocator, output, .{ .whitespace = .indent_2 })` exactly as `json_output.zig` does.

**isMetricEnabled helper (duplicate from console.zig to avoid circular imports):**
```zig
fn isMetricEnabled(metrics: ?[]const []const u8, metric: []const u8) bool {
    const list = metrics orelse return true;
    for (list) |m| {
        if (std.mem.eql(u8, m, metric)) return true;
    }
    return false;
}
```

**Inline Tests (below `// TESTS` comment):**

1. `test "buildSarifOutput: produces valid SARIF envelope"` — empty file_results, verify $schema, version, runs[0].tool.driver.name
2. `test "buildSarifOutput: no results for passing functions"` — all-ok ThresholdResult, verify results array is empty
3. `test "buildSarifOutput: cyclomatic violation produces result"` — ThresholdResult with status=.warning, verify ruleId, level, message contains threshold values
4. `test "buildSarifOutput: column is 1-indexed"` — start_col=4 in ThresholdResult, verify startColumn=5 in SARIF
5. `test "buildSarifOutput: multiple metrics produce multiple results"` — function with 2+ violations, verify result count
6. `test "buildSarifOutput: baseline failure produces file-level result"` — baseline_failed=true, verify health-score ruleId and startLine=1
7. `test "buildSarifOutput: metrics filtering limits results"` — selected_metrics=["cyclomatic"], verify only cyclomatic results appear
8. `test "serializeSarifOutput: produces valid JSON"` — serialize and parse back, verify key fields

Use `std.testing.allocator` in all tests. Follow existing test patterns from json_output.zig (create ThresholdResult array literals, build FileThresholdResults, call build function, verify fields).
  </action>
  <verify>
Run `zig build test` — all existing tests pass plus 8 new sarif_output tests pass. No memory leaks (std.testing.allocator detects leaks).
  </verify>
  <done>
sarif_output.zig exists with SarifLog struct hierarchy, 10 rule definitions, buildSarifOutput function that maps violations to SARIF results with correct column indexing (+1), baseline failure handling, and --metrics filtering. All 8 inline tests pass. Serialization produces valid JSON with $schema field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire SARIF output into main.zig format dispatch and register test imports</name>
  <files>src/main.zig</files>
  <action>
**Add import:**
At the top of main.zig, add:
```zig
const sarif_output = @import("output/sarif_output.zig");
```

**Add format dispatch:**
In main.zig around line 496, the current format dispatch is:
```zig
if (std.mem.eql(u8, effective_format, "json")) {
    // JSON output
} else {
    // Console output (default)
}
```

Change to:
```zig
if (std.mem.eql(u8, effective_format, "json")) {
    // JSON output (existing, unchanged)
    ...
} else if (std.mem.eql(u8, effective_format, "sarif")) {
    // SARIF output
    const sarif_thresholds = sarif_output.SarifThresholds{
        .cyclomatic_warning = cycl_config.warning_threshold,
        .cyclomatic_error = cycl_config.error_threshold,
        .cognitive_warning = cog_config.warning_threshold,
        .cognitive_error = cog_config.error_threshold,
        .halstead_volume_warning = hal_config.volume_warning,
        .halstead_volume_error = hal_config.volume_error,
        .halstead_difficulty_warning = hal_config.difficulty_warning,
        .halstead_difficulty_error = hal_config.difficulty_error,
        .halstead_effort_warning = hal_config.effort_warning,
        .halstead_effort_error = hal_config.effort_error,
        .halstead_bugs_warning = hal_config.bugs_warning,
        .halstead_bugs_error = hal_config.bugs_error,
        .line_count_warning = str_config.function_length_warning,
        .line_count_error = str_config.function_length_error,
        .param_count_warning = str_config.params_count_warning,
        .param_count_error = str_config.params_count_error,
        .nesting_depth_warning = str_config.nesting_depth_warning,
        .nesting_depth_error = str_config.nesting_depth_error,
    };

    const sarif_result = try sarif_output.buildSarifOutput(
        arena_allocator,
        file_results,
        version,
        baseline_failed,
        cfg.baseline,
        project_score,
        parsed_metrics,
        sarif_thresholds,
    );
    const sarif_str = try sarif_output.serializeSarifOutput(arena_allocator, sarif_result);

    try stdout.writeAll(sarif_str);
    try stdout.writeAll("\n");

    // Also write to file if specified
    if (cli_args.output_file) |output_path| {
        const file = try std.fs.cwd().createFile(output_path, .{});
        defer file.close();
        try file.writeAll(sarif_str);
        try file.writeAll("\n");
    }
} else {
    // Console output (default)
    ...
}
```

Note: `baseline_failed` is computed later in main.zig (around line 558). The SARIF output needs this value. Move the baseline check BEFORE the format dispatch section, or pass it in. Looking at the code flow:
- Line 482: effective_format determined
- Line 496: format dispatch (JSON/console)
- Line 552-584: baseline_failed computed
- Line 586: exit code determined

The baseline check needs to happen BEFORE the format dispatch for SARIF. Restructure: move the baseline ratchet check block (lines 558-584) to BEFORE the format dispatch (before line 496). This also means the stderr messages about baseline failure still print before SARIF output, which is correct (stderr vs stdout separation).

**Register test imports:**
In the `test {}` block at the bottom of main.zig, add:
```zig
_ = @import("output/sarif_output.zig");
```

**Important:** Do NOT change any existing JSON or console output behavior. Only add the new `else if` branch.
  </action>
  <verify>
Run `zig build test` — all tests pass including sarif_output tests discovered via main.zig test block. Run `zig build run -- --format sarif tests/fixtures/` and verify SARIF JSON is emitted to stdout with $schema, version, runs array. Pipe output through a JSON validator (parse with `zig build run -- --format sarif tests/fixtures/ | python3 -c "import sys,json; json.load(sys.stdin); print('Valid JSON')"` or similar).
  </verify>
  <done>
main.zig imports sarif_output, dispatches to SARIF serialization when --format sarif is used, passes all threshold configs via SarifThresholds struct, baseline check runs before format dispatch, test imports registered. Running `complexity-guard --format sarif .` produces valid SARIF 2.1.0 JSON on stdout.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` — all tests pass (existing + 8 new sarif_output tests)
2. `zig build run -- --format sarif tests/fixtures/` — produces valid SARIF JSON to stdout
3. SARIF output contains `"$schema": "https://json.schemastore.org/sarif-2.1.0.json"` and `"version": "2.1.0"`
4. SARIF output contains `runs[0].tool.driver.rules` with 10 rule entries
5. SARIF output contains violation results with 1-indexed startColumn values
6. `zig build run -- --format sarif --metrics cyclomatic tests/fixtures/` — only cyclomatic results appear
7. `zig build run -- --format json tests/fixtures/` — JSON output unchanged (regression check)
8. `zig build run -- tests/fixtures/` — console output unchanged (regression check)
</verification>

<success_criteria>
- sarif_output.zig implements SARIF 2.1.0 format with all 10 rules, violation mapping, and column conversion
- main.zig dispatches to SARIF output when --format sarif is specified
- All tests pass with no memory leaks
- Output is valid JSON parseable by standard JSON parsers
- Existing JSON and console output formats are unaffected
</success_criteria>

<output>
After completion, create `.planning/phases/09-sarif-output/09-01-SUMMARY.md`
</output>
