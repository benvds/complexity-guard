---
phase: 01-project-foundation
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/core/types.zig
  - src/core/json.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "FunctionResult struct holds function name, location, and all metric placeholder fields"
    - "FileResult struct holds file path, line count, and a slice of FunctionResults"
    - "ProjectResult struct holds project-level summary and a slice of FileResults"
    - "All three core structs serialize to valid JSON via std.json"
    - "JSON output can be parsed back into equivalent struct values (round-trip)"
  artifacts:
    - path: "src/core/types.zig"
      provides: "FunctionResult, FileResult, ProjectResult struct definitions"
      contains: "FunctionResult"
    - path: "src/core/json.zig"
      provides: "JSON serialization helpers for core types"
      contains: "serializeResult"
    - path: "src/main.zig"
      provides: "Updated entry point importing core modules"
      contains: '@import("core/types.zig")'
  key_links:
    - from: "src/core/json.zig"
      to: "src/core/types.zig"
      via: "imports core types for serialization"
      pattern: '@import\("types\.zig"\)'
    - from: "src/main.zig"
      to: "src/core/types.zig"
      via: "imports core module to pull tests into build"
      pattern: '@import\("core'
    - from: "src/core/json.zig"
      to: "std.json"
      via: "uses stdlib JSON serialization"
      pattern: "std\\.json\\.stringify"
---

<objective>
Implement core data structures (FunctionResult, FileResult, ProjectResult) with JSON serialization using TDD.

Purpose: These types are the backbone of every subsequent phase -- metrics produce them, formatters consume them, and the CLI outputs them. Getting the shape right with tests first ensures every future phase has a stable contract to build against.
Output: Tested, JSON-serializable core types with inline tests proving round-trip fidelity.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation/01-RESEARCH.md
@.planning/phases/01-project-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD core data structures (RED then GREEN)</name>
  <files>src/core/types.zig, src/main.zig</files>
  <action>
**This task follows TDD red-green-refactor per user decision.**

**RED phase -- write failing tests first:**

Create `src/core/types.zig` with ONLY test blocks and empty/minimal struct stubs. The tests should describe the expected shape and behavior:

1. `FunctionResult` must have fields:
   - `name: []const u8` -- function name
   - `start_line: u32` -- 1-indexed line number
   - `end_line: u32` -- 1-indexed line number
   - `start_col: u32` -- 0-indexed column
   - `params_count: u32` -- number of parameters
   - `line_count: u32` -- function body length
   - `cyclomatic: ?u32` -- null until Phase 4 computes it
   - `cognitive: ?u32` -- null until Phase 5 computes it
   - `halstead_volume: ?f64` -- null until Phase 6 computes it
   - `halstead_difficulty: ?f64` -- null until Phase 6 computes it
   - `halstead_effort: ?f64` -- null until Phase 6 computes it
   - `nesting_depth: u32` -- max nesting depth
   - `health_score: ?f64` -- null until Phase 7 computes it

2. `FileResult` must have fields:
   - `path: []const u8` -- relative file path
   - `total_lines: u32` -- total line count
   - `function_count: u32` -- number of functions found
   - `functions: []const FunctionResult` -- array of function results
   - `health_score: ?f64` -- null until Phase 7
   - `export_count: u32` -- number of exports

3. `ProjectResult` must have fields:
   - `files_analyzed: u32` -- count of files
   - `total_functions: u32` -- count across all files
   - `total_lines: u32` -- sum of all file lines
   - `files: []const FileResult` -- array of file results
   - `health_score: ?f64` -- null until Phase 7
   - `grade: ?[]const u8` -- null until Phase 7 (A-F)

Write tests that:
- Create a FunctionResult with known values and verify each field
- Create a FileResult containing 2 FunctionResults and verify function_count matches
- Create a ProjectResult containing 2 FileResults and verify totals
- Verify that nullable metric fields default to null

Run `zig build test` -- tests should FAIL (red) because struct stubs are incomplete.

**GREEN phase -- implement structs:**

Fill in the struct definitions to make all tests pass. Use Zig conventions:
- Use `pub const` for struct definitions
- Use `?` optional types for metrics not yet computed
- Keep structs simple -- no methods yet beyond what tests require
- Use `[]const` for slice types (immutable by default)

Add a `pub const version = "0.1.0";` constant in types.zig for the project version.

Update `src/main.zig` to `@import("core/types.zig")` so that `zig build test` discovers and runs the core type tests. The import must be referenced (not just declared) -- use `_ = @import("core/types.zig");` in a test block or `comptime` block if needed to ensure test discovery.

Run `zig build test` -- all tests must PASS (green).

**REFACTOR phase:**

Review struct field ordering for logical grouping (identity fields first, then structural metrics, then computed metrics). Add doc comments to each struct explaining its role. No functional changes.

Run `zig build test` -- must still PASS.
  </action>
  <verify>
Run `zig build test` -- must pass with 0 failures. Verify test output shows the core type tests ran (look for test names in output with `zig build test 2>&1`).
  </verify>
  <done>
FunctionResult, FileResult, and ProjectResult structs exist with all specified fields. Inline tests verify struct creation and field access. All tests pass. main.zig imports core types so tests are discovered by `zig build test`.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD JSON serialization (RED then GREEN)</name>
  <files>src/core/json.zig, src/main.zig</files>
  <action>
**Continues TDD red-green-refactor cycle.**

**RED phase -- write failing tests first:**

Create `src/core/json.zig` with test blocks that describe JSON serialization behavior:

1. Test that a FunctionResult serializes to JSON containing expected keys:
   - `{"name":"myFunc","start_line":1,"end_line":10,...}`
   - Verify JSON string contains `"name"`, `"start_line"`, `"cyclomatic":null` (nullable fields)

2. Test that a FileResult with nested FunctionResults serializes correctly:
   - JSON must contain `"functions"` array with nested objects
   - `"function_count"` must be present as a number

3. Test that a ProjectResult serializes to valid JSON:
   - Must contain `"files"` array, `"files_analyzed"`, `"health_score":null`

4. Test round-trip: serialize a FunctionResult to JSON, then parse it back, verify fields match.

5. Test pretty-print: verify that serialization with whitespace formatting produces indented output.

Use `std.testing.allocator` for all allocations (automatic leak detection).

Write a `pub fn serializeResult` function stub that takes an allocator and any core type, returns `![]u8`. Use `std.json.stringify` internally.

Write a `pub fn serializeResultPretty` function stub for formatted output.

Run `zig build test` -- new tests should FAIL.

**GREEN phase -- implement serialization:**

Implement `serializeResult` using `std.json.stringify(value, .{}, writer)` pattern:
- Allocate an `std.ArrayList(u8)` as the buffer
- Write JSON into it via `stringify`
- Return owned slice via `toOwnedSlice()`
- Caller owns the returned memory

Implement `serializeResultPretty` using `std.json.stringify(value, .{ .whitespace = .{ .indent_level = 0, .indent = .{ .space = 2 } } }, writer)` for 2-space indentation.

IMPORTANT: The exact `std.json.stringify` API may differ between Zig versions. Check the installed Zig version and consult `zig std` or source if the `.whitespace` option format differs. Adapt to the actual API available.

Update `src/main.zig` to `@import("core/json.zig")` so tests are discovered.

Run `zig build test` -- all tests must PASS.

**REFACTOR:**

Extract any repeated test setup (creating sample FunctionResult/FileResult/ProjectResult) into helper functions within the test blocks. This establishes the pattern for the test helpers plan (Plan 03).
  </action>
  <verify>
Run `zig build test` -- must pass with 0 failures. Run `zig build run` -- must still print version. Manually verify JSON output looks correct by adding a temporary debug print in a test if needed.
  </verify>
  <done>
Core types serialize to valid JSON. Round-trip test proves serialization fidelity. Pretty-print produces readable indented output. All tests pass including both types.zig and json.zig test suites.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes with all core type and JSON tests
2. FunctionResult has 13+ fields covering identity, structure, and metric placeholders
3. FileResult contains a slice of FunctionResults
4. ProjectResult contains a slice of FileResults
5. JSON serialization produces valid JSON strings for all three types
6. Round-trip (serialize then parse) preserves field values
7. Nullable metric fields serialize as `null` in JSON
</verification>

<success_criteria>
- All three core structs defined with complete field sets
- JSON serialization works for all types including nested structures
- Round-trip serialization test passes
- TDD commits follow red-green-refactor pattern
- main.zig imports all core modules for test discovery
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation/01-02-SUMMARY.md`
</output>
