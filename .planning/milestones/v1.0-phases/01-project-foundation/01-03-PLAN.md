---
phase: 01-project-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/test_helpers.zig
  - src/main.zig
  - tests/fixtures/typescript/simple_function.ts
  - tests/fixtures/typescript/complex_nested.ts
  - tests/fixtures/typescript/class_with_methods.ts
  - tests/fixtures/typescript/async_patterns.ts
  - tests/fixtures/javascript/express_middleware.js
  - tests/fixtures/javascript/callback_patterns.js
autonomous: true

must_haves:
  truths:
    - "Test helper builders create valid FunctionResult/FileResult/ProjectResult instances with minimal boilerplate"
    - "Test fixtures contain representative TypeScript and JavaScript code snippets for future metric validation"
    - "Fixture files are loadable at comptime or runtime from the tests/fixtures/ directory"
    - "Helper functions use std.testing.allocator for automatic leak detection"
  artifacts:
    - path: "src/test_helpers.zig"
      provides: "Builder functions for creating test data"
      contains: "createTestFunction"
    - path: "tests/fixtures/typescript/simple_function.ts"
      provides: "Basic TypeScript function fixture"
      contains: "function"
    - path: "tests/fixtures/typescript/complex_nested.ts"
      provides: "Deeply nested control flow fixture"
      contains: "if"
    - path: "tests/fixtures/javascript/express_middleware.js"
      provides: "Express-style middleware fixture"
      contains: "function"
  key_links:
    - from: "src/test_helpers.zig"
      to: "src/core/types.zig"
      via: "imports core types to build test instances"
      pattern: '@import\("core/types\.zig"\)'
    - from: "src/main.zig"
      to: "src/test_helpers.zig"
      via: "imports test helpers for test discovery"
      pattern: '@import\("test_helpers\.zig"\)'
---

<objective>
Create test infrastructure: builder helpers for constructing test data and real-world TypeScript/JavaScript fixtures for future metric validation.

Purpose: Per user decision, the project needs "tooling for easy generation of test cases" and "real-world TypeScript/JavaScript snippets from open-source projects for integration and validation tests." This plan delivers both, making TDD natural for all subsequent phases.
Output: Reusable test builders and a curated fixture library that future metric phases will validate against.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation/01-RESEARCH.md
@.planning/phases/01-project-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test helper builders</name>
  <files>src/test_helpers.zig, src/main.zig</files>
  <action>
Create `src/test_helpers.zig` with builder functions that reduce boilerplate when creating test data. Per user decision: "Create tooling for easy generation of test cases (helpers, builders, or scripts to scaffold tests quickly)."

Import types from `core/types.zig`. Create the following public helper functions:

1. `pub fn createTestFunction(allocator, name) FunctionResult` -- creates a FunctionResult with sensible defaults:
   - name: from parameter
   - start_line: 1, end_line: 10, start_col: 0
   - params_count: 0, line_count: 10, nesting_depth: 0
   - All metric fields (cyclomatic, cognitive, halstead_*, health_score): null

2. `pub fn createTestFunctionFull(allocator, opts) FunctionResult` -- creates a FunctionResult from a config struct that allows overriding any default. Use a struct with optional fields:
   ```
   const TestFunctionOpts = struct {
       name: []const u8 = "testFunc",
       start_line: u32 = 1,
       end_line: u32 = 10,
       // ... all fields with defaults
   };
   ```

3. `pub fn createTestFile(allocator, path, functions) FileResult` -- creates a FileResult wrapping given functions, auto-computing function_count from the slice length.

4. `pub fn createTestProject(allocator, files) ProjectResult` -- creates a ProjectResult wrapping given files, auto-computing files_analyzed, total_functions, and total_lines from the files slice.

5. `pub fn expectJsonContains(json_str, expected_substring) !void` -- convenience assertion that a JSON string contains an expected key or value substring. Wraps `std.mem.indexOf` with a descriptive error message on failure.

Include inline tests for each helper function:
- Test that createTestFunction returns valid defaults
- Test that createTestFunctionFull overrides work
- Test that createTestFile auto-computes function_count
- Test that createTestProject auto-computes totals
- Test that expectJsonContains passes for present substrings and fails for absent ones

Update `src/main.zig` to add `_ = @import("test_helpers.zig");` in a test block to ensure test discovery.

Use `std.testing.allocator` in all tests for automatic leak detection.
  </action>
  <verify>
Run `zig build test` -- must pass with 0 failures including all test_helpers tests. Verify helper functions are usable: a test should create a FunctionResult in 1 line (not 15 lines of field initialization).
  </verify>
  <done>
Test helpers create valid core type instances with minimal code. Builder pattern with defaults makes writing new tests for future phases fast and natural. All helper tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create real-world test fixtures</name>
  <files>tests/fixtures/typescript/simple_function.ts, tests/fixtures/typescript/complex_nested.ts, tests/fixtures/typescript/class_with_methods.ts, tests/fixtures/typescript/async_patterns.ts, tests/fixtures/javascript/express_middleware.js, tests/fixtures/javascript/callback_patterns.js</files>
  <action>
Create hand-crafted test fixtures per user decision: "Hand-crafted synthetic examples for unit tests" and "Real-world TypeScript/JavaScript snippets from open-source projects for integration and validation tests."

Create directory structure:
```
tests/fixtures/
  typescript/
  javascript/
```

**TypeScript fixtures (hand-crafted, synthetic):**

1. `simple_function.ts` -- A basic function with no branching (cyclomatic = 1, cognitive = 0):
```typescript
export function greet(name: string): string {
  return `Hello, ${name}!`;
}
```

2. `complex_nested.ts` -- Deeply nested control flow (high cyclomatic and cognitive):
```typescript
export function processData(items: any[], config: any): any[] {
  const results: any[] = [];
  for (const item of items) {
    if (item.active) {
      if (item.type === 'premium') {
        if (config.premiumEnabled) {
          for (const sub of item.subscriptions) {
            if (sub.valid && sub.expiresAt > Date.now()) {
              results.push({ ...item, status: 'active-premium' });
            } else if (sub.renewable) {
              results.push({ ...item, status: 'renewable' });
            }
          }
        }
      } else {
        if (item.score > config.threshold || item.override) {
          results.push({ ...item, status: 'qualified' });
        }
      }
    }
  }
  return results;
}
```

3. `class_with_methods.ts` -- A class with constructor, getters, methods:
```typescript
export class UserService {
  private users: Map<string, User> = new Map();

  constructor(private readonly db: Database) {}

  async findById(id: string): Promise<User | null> {
    const cached = this.users.get(id);
    if (cached) {
      return cached;
    }
    const user = await this.db.query('SELECT * FROM users WHERE id = ?', [id]);
    if (user) {
      this.users.set(id, user);
    }
    return user ?? null;
  }

  async updateEmail(id: string, email: string): Promise<boolean> {
    const user = await this.findById(id);
    if (!user) {
      throw new Error(`User ${id} not found`);
    }
    if (!this.isValidEmail(email)) {
      throw new Error('Invalid email format');
    }
    user.email = email;
    await this.db.update('users', { id }, { email });
    return true;
  }

  private isValidEmail(email: string): boolean {
    return email.includes('@') && email.includes('.');
  }
}

interface User {
  id: string;
  email: string;
  name: string;
}

interface Database {
  query(sql: string, params: any[]): Promise<any>;
  update(table: string, where: any, data: any): Promise<void>;
}
```

4. `async_patterns.ts` -- Promise chains, async/await, error handling:
```typescript
export async function fetchUserData(
  userId: string,
  options: { includeProfile?: boolean; includeOrders?: boolean } = {}
): Promise<{ user: any; profile?: any; orders?: any[] }> {
  const user = await fetch(`/api/users/${userId}`).then(r => {
    if (!r.ok) {
      throw new Error(`Failed to fetch user: ${r.status}`);
    }
    return r.json();
  });

  const result: { user: any; profile?: any; orders?: any[] } = { user };

  if (options.includeProfile) {
    try {
      result.profile = await fetch(`/api/users/${userId}/profile`).then(r => r.json());
    } catch (err) {
      console.warn('Failed to fetch profile:', err);
      result.profile = null;
    }
  }

  if (options.includeOrders) {
    const orders = await fetch(`/api/users/${userId}/orders`)
      .then(r => r.json())
      .then((data: any[]) => data.filter(o => o.status !== 'cancelled'))
      .catch(() => []);
    result.orders = orders;
  }

  return result;
}
```

**JavaScript fixtures (real-world style):**

5. `express_middleware.js` -- Express-style middleware with nested callbacks:
```javascript
function errorHandler(err, req, res, next) {
  if (err.type === 'validation') {
    res.status(400).json({ error: err.message, fields: err.fields });
  } else if (err.type === 'auth') {
    if (err.code === 'TOKEN_EXPIRED') {
      res.status(401).json({ error: 'Token expired', action: 'refresh' });
    } else if (err.code === 'FORBIDDEN') {
      res.status(403).json({ error: 'Access denied' });
    } else {
      res.status(401).json({ error: 'Authentication required' });
    }
  } else {
    console.error('Unhandled error:', err);
    res.status(500).json({ error: 'Internal server error' });
  }
}

function rateLimiter(options) {
  const store = new Map();
  return function(req, res, next) {
    const key = req.ip || req.connection.remoteAddress;
    const now = Date.now();
    const record = store.get(key) || { count: 0, resetAt: now + options.windowMs };

    if (now > record.resetAt) {
      record.count = 0;
      record.resetAt = now + options.windowMs;
    }

    record.count++;
    store.set(key, record);

    if (record.count > options.max) {
      res.status(429).json({ error: 'Too many requests' });
      return;
    }

    next();
  };
}

module.exports = { errorHandler, rateLimiter };
```

6. `callback_patterns.js` -- Nested callbacks and mixed patterns:
```javascript
function processQueue(queue, config, callback) {
  const results = [];
  let processed = 0;

  queue.forEach(function(item, index) {
    setTimeout(function() {
      try {
        if (item.priority > config.threshold) {
          processHighPriority(item, function(err, result) {
            if (err) {
              if (config.strict) {
                callback(err);
                return;
              }
              results.push({ item, error: err.message });
            } else {
              results.push({ item, result });
            }
            processed++;
            if (processed === queue.length) {
              callback(null, results);
            }
          });
        } else {
          results.push({ item, result: 'skipped' });
          processed++;
          if (processed === queue.length) {
            callback(null, results);
          }
        }
      } catch (e) {
        callback(e);
      }
    }, index * config.delay);
  });
}

function processHighPriority(item, callback) {
  // Simulated async processing
  if (!item.data) {
    callback(new Error('No data'));
    return;
  }
  callback(null, { processed: true, id: item.id });
}

module.exports = { processQueue, processHighPriority };
```

Each fixture should include a comment header noting its purpose and expected complexity characteristics (for future validation):
```
// Fixture: [name]
// Purpose: [what this tests]
// Expected complexity: cyclomatic ~N, cognitive ~N, nesting ~N
```

These files are NOT compiled by Zig -- they are test data that future phases will parse with tree-sitter and validate metric calculations against.
  </action>
  <verify>
Verify all fixture files exist: `find tests/fixtures -type f | sort`. Verify TypeScript fixtures have valid syntax by checking they contain expected keywords. Verify each fixture has a comment header with expected complexity notes.
  </verify>
  <done>
6 fixture files created spanning simple to complex TypeScript and JavaScript patterns. Each fixture has documented expected complexity characteristics for future validation. Directory structure ready for additional fixtures as needed.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes with all tests including test_helpers
2. Test helper builders create instances with 1-3 lines of code (not 15+ lines of field init)
3. createTestProject auto-computes totals from child FileResults
4. 6 fixture files exist in tests/fixtures/ with TypeScript and JavaScript examples
5. Fixture files cover: simple functions, nested control flow, classes, async patterns, middleware, callbacks
6. Each fixture has a comment header documenting expected complexity
</verification>

<success_criteria>
- Test helpers reduce test setup boilerplate to 1-3 lines per instance
- Fixture library provides representative code for future metric validation
- TDD for future phases is natural: import helpers, create expected results, write assertions
- All tests pass with zero memory leaks (std.testing.allocator)
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation/01-03-SUMMARY.md`
</output>
