---
phase: 08-composite-health-score
plan: 01
type: tdd
wave: 1
depends_on: []
requirements: [COMP-01, COMP-02, COMP-03]
files_modified:
  - src/metrics/scoring.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "sigmoidScore returns 100 when x is 0"
    - "sigmoidScore returns ~50 when x equals warning threshold"
    - "sigmoidScore returns ~20 when x equals error threshold"
    - "sigmoidScore degrades smoothly (no hard cutoffs)"
    - "Effective weights exclude duplication and normalize remaining to 1.0"
    - "Weight of 0 excludes metric from computation"
    - "All weights zero returns 100.0 (no metrics = perfect)"
    - "Function score is weighted average of normalized sub-scores"
    - "File score is average of function scores, empty file returns 100"
    - "Project score is function-count-weighted average of file scores"
    - "Partial weight override normalizes correctly"
  artifacts:
    - path: "src/metrics/scoring.zig"
      provides: "Sigmoid normalization, weight redistribution, function/file/project score computation"
      exports: ["sigmoidScore", "resolveEffectiveWeights", "computeFunctionScore", "computeFileScore", "computeProjectScore", "EffectiveWeights", "ScoreBreakdown", "MetricThresholds"]
  key_links:
    - from: "src/metrics/scoring.zig"
      to: "src/cli/config.zig"
      via: "imports WeightsConfig for weight resolution"
      pattern: "config\\.WeightsConfig"
    - from: "src/main.zig"
      to: "src/metrics/scoring.zig"
      via: "test import for discovery"
      pattern: "@import\\(\"metrics/scoring.zig\"\\)"
---

<objective>
Create the core scoring module with sigmoid normalization, weight redistribution, and composite score computation at function, file, and project levels.

Purpose: This is the mathematical foundation for the entire health score system. All normalization curves, weight handling, and score aggregation logic lives here. TDD ensures the math is correct before wiring into the pipeline.

Output: `src/metrics/scoring.zig` with all scoring functions, fully tested with inline tests. Main.zig updated with test import.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-composite-health-score/08-CONTEXT.md
@.planning/phases/08-composite-health-score/08-RESEARCH.md
@src/metrics/cyclomatic.zig (ThresholdResult struct, ThresholdStatus, validateThreshold, validateThresholdF64)
@src/cli/config.zig (WeightsConfig struct, ThresholdPair, ThresholdsConfig, Config, defaults())
@src/main.zig (test import block at bottom)
</context>

<feature>
  <name>Scoring module: normalization + composite computation</name>
  <files>src/metrics/scoring.zig, src/main.zig</files>
  <behavior>
    Sigmoid normalization:
    - sigmoidScore(0, 10, k) -> ~100 (near-zero complexity = near-perfect)
    - sigmoidScore(10, 10, k) -> 50.0 exactly (at warning threshold = midpoint)
    - sigmoidScore(20, 10, k) -> ~20 (at error threshold = low but not zero)
    - sigmoidScore(50, 10, k) -> very low but > 0 (smooth degradation, never exactly 0)
    - k derived from warning/error: k = ln(4) / (error - warning)

    Normalize individual metrics:
    - normalizeCyclomatic(5, 10, 20) -> high score (below warning)
    - normalizeCyclomatic(10, 10, 20) -> 50.0
    - normalizeCyclomatic(20, 10, 20) -> ~20.0
    - normalizeCognitive(3, 15, 25) -> high score
    - normalizeHalstead(100.0, 500.0, 1000.0) -> high score
    - normalizeStructural(ThresholdResult with low values, thresholds) -> high score (average of 3 sub-metrics)

    Weight redistribution:
    - Default weights (0.20 cycl, 0.30 cog, 0.15 hal, 0.15 str) -> normalized to 1.0 (duplication excluded)
    - All custom weights -> normalized to 1.0
    - Partial override {"cyclomatic": 0.5} -> 0.5 for cycl, rest use defaults, normalize all to 1.0
    - Weight of 0.0 for a metric -> excluded from denominator
    - All weights 0 -> returns equal weights (0.25 each) as fallback

    Function score:
    - computeFunctionScore(ThresholdResult, EffectiveWeights, MetricThresholds) -> 0-100

    File score:
    - computeFileScore([scores]) -> average
    - computeFileScore([]) -> 100.0 (empty file)

    Project score:
    - computeProjectScore([file_scores], [function_counts]) -> function-count-weighted average
    - computeProjectScore([], []) -> 100.0 (no files)
  </behavior>
  <implementation>
    Create src/metrics/scoring.zig with:

    1. **Types:** MetricThresholds struct (all warning/error pairs), EffectiveWeights struct (4 f64 fields), ScoreBreakdown struct (4 sub-scores + effective weights)

    2. **sigmoidScore(x: f64, x0: f64, k: f64) f64** - core formula: `100.0 / (1.0 + @exp(k * (x - x0)))`

    3. **computeSteepness(warning: f64, err: f64) f64** - derives k: `@log(4.0) / (err - warning)`. Guard against division by zero (if warning == error, return a large k like 1.0).

    4. **Normalization functions** for each metric family:
       - normalizeCyclomatic(value: u32, warning: u32, err: u32) f64
       - normalizeCognitive(value: u32, warning: u32, err: u32) f64
       - normalizeHalstead(volume: f64, warning: f64, err: f64) f64
       - normalizeStructural(tr: ThresholdResult, thresholds: MetricThresholds) f64
         (averages function_length, params_count, nesting_depth sub-scores)

    5. **resolveEffectiveWeights(weights: ?WeightsConfig) EffectiveWeights** - Takes optional WeightsConfig from config. Defaults: cyclomatic=0.20, cognitive=0.30, halstead=0.15, structural=0.15. Duplication always excluded. Normalizes remaining to sum to 1.0. If all zero, returns 0.25 each.

    6. **computeFunctionScore(tr: ThresholdResult, weights: EffectiveWeights, thresholds: MetricThresholds) ScoreBreakdown** - Computes each sub-score, applies weights, returns breakdown with total and per-metric contributions.

    7. **computeFileScore(function_scores: []const f64) f64** - Average of scores. Empty = 100.0.

    8. **computeProjectScore(file_scores: []const f64, function_counts: []const u32) f64** - Function-count-weighted average. No functions = 100.0.

    Import config module for WeightsConfig. Import cyclomatic for ThresholdResult.

    Add `_ = @import("metrics/scoring.zig");` to main.zig test block for discovery.

    Follow RED-GREEN-REFACTOR: write tests first, then implement, then clean up.
  </implementation>
</feature>

<verification>
`zig build test` passes with all scoring tests green. Tests cover:
- Sigmoid boundary values (0, warning, error, extreme)
- Each normalization function
- Weight redistribution (defaults, partial, zero, all-zero)
- Function score computation
- File score (normal + empty)
- Project score (normal + empty + weighted)
</verification>

<success_criteria>
- src/metrics/scoring.zig exists with all functions listed above
- All tests pass with `zig build test`
- sigmoidScore(x0, x0, k) returns exactly 50.0 for any valid x0/k
- Empty file/project edge cases return 100.0
- Duplication weight is always excluded
- main.zig imports scoring.zig for test discovery
</success_criteria>

<output>
After completion, create `.planning/phases/08-composite-health-score/08-01-SUMMARY.md`
</output>
