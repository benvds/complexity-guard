---
phase: 14-tech-debt-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/metrics/cyclomatic.zig
  - src/metrics/cognitive.zig
  - src/metrics/halstead.zig
  - src/metrics/structural.zig
  - tests/fixtures/naming-edge-cases.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "Arrow functions assigned to const/let/var show the variable name (e.g., 'handler' not '<anonymous>')"
    - "Class methods show 'ClassName.methodName' format in all output"
    - "Object literal methods show 'objKey.methodName' or 'keyName' format"
    - "Anonymous callbacks show context name (e.g., 'map callback')"
    - "Default exports show 'default export' as function name"
    - "Dead arrow_function branch in cognitive.zig visitNode is removed"
  artifacts:
    - path: "src/metrics/cyclomatic.zig"
      provides: "Enhanced extractFunctionInfo with class/object/callback/export context; enhanced walkAndAnalyze with class_declaration, pair, call_expression, export_statement parent tracking"
    - path: "src/metrics/cognitive.zig"
      provides: "Dead code removed from visitNode; walkAndAnalyze enhanced with same parent context as cyclomatic"
    - path: "src/metrics/halstead.zig"
      provides: "walkAndAnalyze enhanced with same parent context as cyclomatic"
    - path: "src/metrics/structural.zig"
      provides: "walkAndAnalyze enhanced with same parent context as cyclomatic"
    - path: "tests/fixtures/naming-edge-cases.ts"
      provides: "TypeScript fixture with class methods, object methods, callbacks, default export for naming tests"
  key_links:
    - from: "src/metrics/cyclomatic.zig extractFunctionInfo"
      to: "src/metrics/cognitive.zig, halstead.zig, structural.zig"
      via: "cyclomatic.extractFunctionInfo() called from all walkers"
      pattern: "cyclomatic\\.extractFunctionInfo"
    - from: "walkAndAnalyze parent_context"
      to: "extractFunctionInfo override"
      via: "parent_context name overrides extractFunctionInfo result"
      pattern: "parent_context.*ctx\\.name"
---

<objective>
Improve function name extraction to use actual names instead of placeholders, and remove unreachable dead code from cognitive.zig.

Purpose: Function names like `<anonymous>` provide poor developer experience in output. Class methods should show `ClassName.method`, callbacks should show `map callback`, and default exports should be labeled. The dead arrow_function branch in cognitive.zig's visitNode is unreachable code that confuses maintainers.

Output: Enhanced function naming across all four metric walkers; dead code removed from cognitive.zig; test fixture for naming edge cases.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-tech-debt-cleanup/14-RESEARCH.md
@src/metrics/cyclomatic.zig
@src/metrics/cognitive.zig
@src/metrics/halstead.zig
@src/metrics/structural.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance extractFunctionInfo and all four walkAndAnalyze functions for rich function naming</name>
  <files>
    src/metrics/cyclomatic.zig
    src/metrics/cognitive.zig
    src/metrics/halstead.zig
    src/metrics/structural.zig
    tests/fixtures/naming-edge-cases.ts
  </files>
  <action>
**Create test fixture** `tests/fixtures/naming-edge-cases.ts` with examples covering all naming patterns:
- `const handler = () => {}` (variable-assigned arrow — already works via parent_context)
- `class Foo { bar() {} static baz() {} }` (class methods)
- `const obj = { handler: () => {}, process() {} }` (object literal methods)
- `arr.map(() => { return x; })` (anonymous callback in call expression)
- `export default function() {}` (default export)
- Regular named function `function myFunc() {}` (baseline — already works)

**Enhance `extractFunctionInfo` in cyclomatic.zig** (lines 128-195):

The function currently takes only `(node, source)` and returns `<anonymous>` for arrow/function expressions. Add a `parent_context` parameter to receive richer naming context from the walker.

Add a new `FunctionContext` field or extend the existing one to carry:
- `class_name: ?[]const u8` — set when walking inside `class_declaration` or `class` node
- `object_key: ?[]const u8` — set when walking inside `pair` node (object literal)
- `call_name: ?[]const u8` — set when the function is an argument inside `call_expression`
- `is_default_export: bool` — set when parent is `export_statement` with "default" keyword

Update the FunctionContext struct used in cyclomatic.zig (currently only has `name` and `kind` fields). Add these new optional fields. Keep backward compatibility — existing `name` field still works for `variable_declarator` context.

**Function naming logic in `extractFunctionInfo`** (or in the walker after extractFunctionInfo returns):

1. **Class methods** (`method_definition` inside `class_declaration`/`class`): When `extractFunctionInfo` returns kind="method" and class_name is set in parent_context, compose name as `"ClassName.methodName"`. The method name comes from extractFunctionInfo's existing property_identifier lookup. The class name comes from the walker tracking `class_declaration` parent context. Use `std.fmt.bufPrint` with a stack buffer (e.g., `var buf: [512]u8 = undefined;`) and store the composed name. Since the source text is borrowed and lives for the duration of analysis, the composed name needs to be stored somewhere stable — use the source slices directly for class name and method name, and format them together using a buffer that persists in the result.

   **Important:** The composed "ClassName.methodName" string needs stable memory. Since results use `[]const u8` slices pointing into the source, and we need to concatenate two slices with a dot, allocate the composed name using the allocator passed to `walkAndAnalyze`. Use `std.fmt.allocPrint(allocator, "{s}.{s}", .{ class_name, method_name })` and store the result. The caller (main.zig) already manages memory lifetime. Add the allocated slice to the results ArrayList so it gets cleaned up.

2. **Object literal methods** (`pair` inside `object`): When a `pair` node's value is a function, the pair's key is the method name. Track `pair` key name in child_context similar to `variable_declarator`. The key is the `property_identifier` or `string` first child of `pair`. Use this as the function name directly (no prefix needed unless inside a variable assignment, in which case use `varName.keyName`).

3. **Anonymous callbacks** (`arrow_function` or `function` inside `call_expression` arguments): Track the callee name when entering `call_expression`. For member expressions like `arr.map(...)`, extract the last segment ("map"). For simple identifiers like `forEach(...)`, use the identifier. Set child_context with `call_name = "map"` (or whatever the callee is). In the function naming step, when a function has no name from extractFunctionInfo AND no variable_declarator name AND has call_name set, use `"{callee} callback"` format. Use `std.fmt.allocPrint(allocator, "{s} callback", .{call_name})`.

4. **Default exports** (`export_statement` with "default" child): When walking an `export_statement` node, check if it has a child with node type "default" (the keyword). If so, set `is_default_export = true` in child_context. When a function has no other name and is_default_export is true, use `"default export"` as the name.

5. **addEventListener special case**: Per CONTEXT.md, `addEventListener('click', fn)` should produce "click handler". When processing `call_expression`, if the callee is "addEventListener", read the first argument (a string literal). Extract the string content (without quotes) and format as `"{event} handler"`. This is a special case only for addEventListener-pattern calls. Use `std.fmt.allocPrint(allocator, "{s} handler", .{event_name})`.

**Update all four `walkAndAnalyze` functions** to track the new parent contexts:

All four walkers (cyclomatic.zig, cognitive.zig, halstead.zig, structural.zig) follow the identical pattern:
- They have a `child_context` variable (type varies: `FunctionContext`, `WalkContext`, `FunctionNameContext`)
- They currently only check for `variable_declarator`
- They pass `child_context` when recursing into children

Add these additional context checks AFTER the existing `variable_declarator` check in each walker:

```
// Track class name for "ClassName.method" naming
else if (std.mem.eql(u8, node_type, "class_declaration") or std.mem.eql(u8, node_type, "class")) {
    // Find identifier child = class name
    // Set child_context.class_name
}
// Track object literal pair key for method naming
else if (std.mem.eql(u8, node_type, "pair")) {
    // Find property_identifier or string child = key name
    // Set child_context.object_key (or use as name directly)
}
// Track call expression callee for "X callback" naming
else if (std.mem.eql(u8, node_type, "call_expression")) {
    // Find callee identifier (first child or last segment of member_expression)
    // Set child_context.call_name
    // Special case: addEventListener → read first string arg for "{event} handler"
}
// Track default export
else if (std.mem.eql(u8, node_type, "export_statement")) {
    // Check for "default" keyword child
    // Set child_context.is_default_export = true
}
```

Each walker's context struct needs to be extended to carry the new fields. Since each walker has its own struct type:
- cyclomatic.zig: `FunctionContext` — add `class_name`, `object_key`, `call_name`, `is_default_export`
- cognitive.zig: `WalkContext` — same fields
- halstead.zig: `FunctionContext` — same fields
- structural.zig: `FunctionNameContext` — same fields

Then in the function-node branch where `parent_context` is checked, apply the naming priority:
1. Explicit variable name from `variable_declarator` (existing — highest priority)
2. Class method: `ClassName.methodName` (compose from class_name + extractFunctionInfo name)
3. Object key: use object_key as name
4. Callback: `calleeName callback` (or `eventName handler` for addEventListener)
5. Default export: `"default export"`
6. Fall through to extractFunctionInfo's result (named functions) or `<anonymous>`

**Note on memory:** For composed names (ClassName.method, X callback, X handler), use `std.fmt.allocPrint(allocator, ...)`. The allocator in walkAndAnalyze is the arena allocator from main.zig, so these allocations are cleaned up when the arena is freed. No additional defer needed.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard && zig build test 2>&1 | tail -20</automated>
    <manual>Run `zig build run -- tests/fixtures/naming-edge-cases.ts` and verify function names in output show ClassName.method, map callback, default export, etc. instead of &lt;anonymous&gt;</manual>
  </verify>
  <done>
    - Arrow functions assigned to variables show variable name (already worked, still works)
    - Class methods show "ClassName.methodName" in all four metric outputs
    - Object literal function values show key name
    - Callbacks in map/forEach/etc. show "callee callback" format
    - addEventListener callbacks show "event handler" format
    - Default exports show "default export"
    - All existing tests pass (no regressions)
    - Naming is consistent across cyclomatic, cognitive, halstead, and structural outputs
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove dead arrow_function branch from cognitive.zig visitNode</name>
  <files>
    src/metrics/cognitive.zig
  </files>
  <action>
Delete the unreachable `arrow_function` branch in `visitNode()` (lines 143-162 approximately). This code is dead because `isFunctionNode(node)` at line 67 returns true for `arrow_function` and exits early, so the `arrow_function` check at line 145 can never be reached.

The correct arrow callback handling is in `visitNodeWithArrows()` / `visitArrowCallback()` (around lines 296-339), which is called from `calculateCognitiveComplexity()`.

After deletion:
1. Run `zig build test` to verify no test failures
2. If any tests fail related to arrow_function in visitNode, they are testing dead code — remove those tests too
3. The comments in the dead block (lines 148-159) that explain why the branch is unreachable serve as confirmation this deletion is correct

Leave the `isFunctionNode` early return at line 67 unchanged — it is the correct scope isolation behavior.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard && zig build test 2>&1 | tail -20</automated>
    <manual>Grep for "arrow_function" in visitNode function to confirm the dead branch is gone</manual>
  </verify>
  <done>
    - Lines 143-162 (approximate) removed from cognitive.zig visitNode
    - No test failures — arrow callback tests via calculateCognitiveComplexity still pass
    - visitNode no longer contains unreachable code paths
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes with zero failures
2. `zig build run -- tests/fixtures/naming-edge-cases.ts` shows rich function names instead of `<anonymous>`
3. `zig build run -- tests/fixtures/` shows existing test files still produce correct results
4. No `<anonymous>` appears for functions that have discoverable names (variable-assigned, class methods, object methods, callbacks, default exports)
5. Grep for dead arrow_function block in cognitive.zig visitNode returns no matches
</verification>

<success_criteria>
- All existing tests pass (zero regressions)
- Function names in output use actual names per CONTEXT.md decisions
- Dead code removed from cognitive.zig
- Naming consistent across all four metric outputs (cyclomatic, cognitive, halstead, structural)
</success_criteria>

<output>
After completion, create `.planning/phases/14-tech-debt-cleanup/14-01-SUMMARY.md`
</output>
