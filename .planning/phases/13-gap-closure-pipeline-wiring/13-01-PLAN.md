---
phase: 13-gap-closure-pipeline-wiring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/main.zig
  - src/output/exit_codes.zig
  - src/pipeline/parallel.zig
autonomous: true
requirements:
  - CYCL-09
  - CFG-04
  - CLI-07
  - CLI-08

must_haves:
  truths:
    - "Config file cyclomatic thresholds override the hardcoded defaults (warning=10, error=20)"
    - "--metrics flag gates which metric families drive exit codes (not just display)"
    - "--no-duplication flag prevents duplication detection from running"
    - "--save-baseline writes duplication weight (0.20) in the default config file"
  artifacts:
    - path: "src/main.zig"
      provides: "buildCyclomaticConfig helper, --no-duplication gate in duplication_enabled block, duplication weight in writeDefaultConfigWithBaseline"
      contains: "buildCyclomaticConfig"
    - path: "src/output/exit_codes.zig"
      provides: "Metric-filtered countViolations overload"
      contains: "worstStatusForMetrics"
    - path: "src/pipeline/parallel.zig"
      provides: "Parallel path passes parsed_metrics to countViolations"
      contains: "countViolationsFiltered"
  key_links:
    - from: "src/main.zig"
      to: "src/output/exit_codes.zig"
      via: "countViolationsFiltered call with parsed_metrics"
      pattern: "countViolationsFiltered.*parsed_metrics"
    - from: "src/pipeline/parallel.zig"
      to: "src/output/exit_codes.zig"
      via: "countViolationsFiltered call with ctx.parsed_metrics"
      pattern: "countViolationsFiltered.*ctx\\.parsed_metrics"
    - from: "src/main.zig buildCyclomaticConfig"
      to: "src/metrics/cyclomatic.zig CyclomaticConfig"
      via: "builds config from ThresholdsConfig.cyclomatic ThresholdPair"
      pattern: "buildCyclomaticConfig.*thresholds"
---

<objective>
Close all four pipeline wiring gaps identified by the v1.0 milestone audit: (1) cyclomatic config thresholds from config file, (2) --metrics gating of exit codes, (3) --no-duplication flag wiring, (4) duplication weight in --save-baseline default config.

Purpose: These are the last requirement gaps blocking v1.0 release — four small wiring bugs where config fields exist but are never read at the right call sites.
Output: All four gaps closed with inline tests in the same files. `zig build test` passes.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-gap-closure-pipeline-wiring/13-RESEARCH.md
@src/main.zig
@src/output/exit_codes.zig
@src/pipeline/parallel.zig
@src/metrics/cyclomatic.zig
@src/cli/config.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire four pipeline gaps in main.zig, exit_codes.zig, and parallel.zig</name>
  <files>
    src/main.zig
    src/output/exit_codes.zig
    src/pipeline/parallel.zig
  </files>
  <action>
    **Gap 1 (CYCL-09): buildCyclomaticConfig helper in main.zig**

    Add a `pub fn buildCyclomaticConfig(thresholds: config_mod.ThresholdsConfig) cyclomatic.CyclomaticConfig` function in `main.zig`, placed right after `buildStructuralConfig` (line ~97). Mirror the existing `buildHalsteadConfig`/`buildStructuralConfig` pattern:
    - Read `thresholds.cyclomatic: ?ThresholdPair` for `warning` and `error` fields
    - Fall back to `CyclomaticConfig.default()` for all other fields (`count_logical_operators`, `count_nullish_coalescing`, `count_optional_chaining`, `count_ternary`, `count_default_params`, `switch_case_mode`)
    - Only override `warning_threshold` and `error_threshold` from config

    Then replace line 229 (`const cycl_config = cyclomatic.CyclomaticConfig.default();`) with:
    ```zig
    const cycl_config = if (cfg.analysis) |analysis|
        if (analysis.thresholds) |thresholds| buildCyclomaticConfig(thresholds) else cyclomatic.CyclomaticConfig.default()
    else
        cyclomatic.CyclomaticConfig.default();
    ```

    This ensures `metric_thresholds` (used for scoring sigmoid) and `sarif_thresholds` both automatically pick up the config values since they already read from `cycl_config`.

    **Gap 2 (CLI-07): --metrics gating in exit code counting**

    In `src/output/exit_codes.zig`, add:
    1. A local `isMetricEnabled` helper (duplicate the pattern from parallel.zig line 57-63 — this is the established pattern to avoid circular imports per Phase 07-03 decision).
    2. A new `pub fn worstStatusForMetrics(result: cyclomatic.ThresholdResult, metrics: ?[]const []const u8) cyclomatic.ThresholdStatus` function that only considers enabled metric families. When `metrics` is null, consider all (same as `worstStatusAll`).
    3. A new `pub fn countViolationsFiltered(threshold_results: []const cyclomatic.ThresholdResult, metrics: ?[]const []const u8) struct { warnings: u32, errors: u32 }` function that uses `worstStatusForMetrics` instead of `worstStatusAll`.

    IMPORTANT: Do NOT modify the existing `worstStatusAll` or `countViolations` functions. The existing `worstStatusAll` is used in `console.zig` for verbosity filtering where all-metrics behavior is correct (Phase 07-05 decision). Add new functions alongside.

    Then in `src/main.zig`, change the sequential path call (line ~459):
    ```zig
    // Before:
    const violations = exit_codes.countViolations(cycl_results);
    // After:
    const violations = exit_codes.countViolationsFiltered(cycl_results, parsed_metrics);
    ```

    And in `src/pipeline/parallel.zig`, change line 240:
    ```zig
    // Before:
    const violations = exit_codes.countViolations(cycl_results);
    // After:
    const violations = exit_codes.countViolationsFiltered(cycl_results, ctx.parsed_metrics);
    ```

    **Gap 3 (CLI-08): --no-duplication gate in duplication_enabled block**

    In `src/main.zig`, add a `no_duplication` check at the TOP of the `duplication_enabled` block (lines 276-288), before the existing `duplication_enabled` check:
    ```zig
    const duplication_enabled: bool = blk: {
        // --no-duplication overrides everything
        if (cfg.analysis) |a| {
            if (a.no_duplication) |nd| {
                if (nd) break :blk false;
            }
        }
        // existing logic continues...
        if (cfg.analysis) |a| {
            if (a.duplication_enabled) |de| {
    ```

    **Gap 4 (CFG-04): duplication weight in writeDefaultConfigWithBaseline**

    In `src/main.zig` function `writeDefaultConfigWithBaseline` (lines 38-43), add the duplication weight to the weights object:
    ```zig
    try writer.writeAll("    \"structural\": 0.15,\n");  // add trailing comma
    try writer.writeAll("    \"duplication\": 0.20\n");   // new line
    ```
    Change the existing `"structural": 0.15\n"` line to add a trailing comma.
  </action>
  <verify>
    Run `zig build test` — all existing tests pass (no regressions from signature changes since we added new functions rather than modifying existing ones).
    Run `zig build` — binary compiles without errors.
  </verify>
  <done>
    All four code changes are in place: buildCyclomaticConfig wired, countViolationsFiltered added, --no-duplication gate added, duplication weight added to default config. Existing tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add targeted tests for all four gap fixes</name>
  <files>
    src/main.zig
    src/output/exit_codes.zig
  </files>
  <action>
    Add inline tests verifying each gap fix:

    **In `src/output/exit_codes.zig`** (below existing tests):

    1. `test "worstStatusForMetrics: null metrics considers all families"` — create a ThresholdResult with halstead_volume_status=.warning, pass metrics=null, expect .warning (same as worstStatusAll).

    2. `test "worstStatusForMetrics: cyclomatic-only ignores halstead warning"` — create a ThresholdResult with status=.ok (cyclomatic ok), halstead_volume_status=.warning. Pass metrics=&[_][]const u8{"cyclomatic"}. Expect .ok (halstead ignored).

    3. `test "worstStatusForMetrics: cognitive-only ignores structural"` — create a ThresholdResult with cognitive_status=.warning, nesting_depth_status=.@"error". Pass metrics=&[_][]const u8{"cognitive"}. Expect .warning (structural ignored).

    4. `test "countViolationsFiltered: filters by enabled metrics"` — create two ThresholdResult items: one with cyclomatic .ok but halstead_volume .warning, another with cyclomatic .warning. Pass metrics=&[_][]const u8{"cyclomatic"}. Expect 1 warning, 0 errors (the halstead warning on the first result is ignored).

    5. `test "countViolationsFiltered: null metrics matches countViolations"` — create results with mixed statuses. Call both `countViolations` and `countViolationsFiltered(results, null)`. Assert both return the same counts.

    **In `src/main.zig`** (below existing tests):

    6. `test "buildCyclomaticConfig: applies config thresholds"` — create a ThresholdsConfig with cyclomatic = ThresholdPair{ .warning = 15, .@"error" = 30 }. Call buildCyclomaticConfig. Assert warning_threshold == 15, error_threshold == 30.

    7. `test "buildCyclomaticConfig: falls back to defaults for null"` — create a ThresholdsConfig with cyclomatic = null. Call buildCyclomaticConfig. Assert warning_threshold == 10, error_threshold == 20 (the CyclomaticConfig defaults).

    8. `test "buildCyclomaticConfig: partial override (warning only)"` — create a ThresholdsConfig with cyclomatic = ThresholdPair{ .warning = 12, .@"error" = null }. Call buildCyclomaticConfig. Assert warning_threshold == 12, error_threshold == 20 (default).

    For all tests, use `std.testing.expectEqual` with `@as(T, value)` for type coercion per Zig conventions in CLAUDE.md.
  </action>
  <verify>
    Run `zig build test` — all new tests pass alongside existing tests.
    Count: 8 new test cases total (5 in exit_codes.zig, 3 in main.zig).
  </verify>
  <done>
    All four gap fixes have dedicated test coverage. Tests verify: cyclomatic config from config file, --metrics exit code gating, and metric-filtered counting matches unfiltered when metrics is null.
  </done>
</task>

</tasks>

<verification>
1. `zig build` compiles without errors
2. `zig build test` — all tests pass (existing + 8 new)
3. Manual spot-check: grep for `CyclomaticConfig.default()` in main.zig line 229 area — should NOT appear (replaced by buildCyclomaticConfig)
4. Manual spot-check: grep for `countViolations(cycl_results)` without `Filtered` — should NOT appear in main.zig or parallel.zig (replaced by countViolationsFiltered)
5. Manual spot-check: grep for `no_duplication` in main.zig duplication_enabled block — should appear
6. Manual spot-check: grep for `duplication.*0.20` in writeDefaultConfigWithBaseline — should appear
</verification>

<success_criteria>
- `zig build test` passes with zero failures
- `zig build` produces working binary
- buildCyclomaticConfig reads ThresholdsConfig.cyclomatic and overrides warning/error thresholds
- countViolationsFiltered filters exit code counting by parsed_metrics
- duplication_enabled block checks cfg.analysis.no_duplication before other logic
- writeDefaultConfigWithBaseline includes "duplication": 0.20 in weights
- No regressions: existing worstStatusAll and countViolations functions unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/13-gap-closure-pipeline-wiring/13-01-SUMMARY.md`
</output>
