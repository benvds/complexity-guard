---
phase: 19-cli-config-and-output-formats
plan: 02
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - rust/src/output/console.rs
  - rust/src/output/json_output.rs
  - rust/src/output/mod.rs
  - rust/src/main.rs
autonomous: true
requirements:
  - OUT-01
  - OUT-02

must_haves:
  truths:
    - "Console output shows ESLint-style format with file path header, violation lines with line:col/level/message/rule-id, and summary"
    - "JSON output matches Zig schema exactly — same field names, nesting, array ordering"
    - "Color output respects --color, --no-color flags and NO_COLOR/FORCE_COLOR env vars"
    - "Quiet mode shows errors only, verbose mode shows all functions including ok"
  artifacts:
    - path: "rust/src/output/console.rs"
      provides: "ESLint-style colored console output renderer"
      contains: "pub fn render_console"
    - path: "rust/src/output/json_output.rs"
      provides: "JSON output with exact Zig schema field names"
      contains: "pub fn render_json"
  key_links:
    - from: "rust/src/output/console.rs"
      to: "rust/src/types.rs"
      via: "reads FileAnalysisResult and FunctionAnalysisResult"
      pattern: "FileAnalysisResult"
    - from: "rust/src/output/json_output.rs"
      to: "rust/src/types.rs"
      via: "serializes analysis results to JSON envelope"
      pattern: "serde_json::to_string"
    - from: "rust/src/output/mod.rs"
      to: "rust/src/output/console.rs"
      via: "format dispatch"
      pattern: "render_console"
---

<objective>
Implement console (ESLint-style) and JSON output format renderers.

Purpose: These are the two most commonly used output formats. Console is the default for interactive use; JSON is used for CI integration and programmatic consumption. Both must match the Zig binary output exactly.
Output: Two complete output renderers dispatched by --format flag.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-cli-config-and-output-formats/19-RESEARCH.md
@.planning/phases/19-cli-config-and-output-formats/19-01-SUMMARY.md
@rust/src/types.rs
@rust/src/output/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement console output renderer with ESLint-style format and color support</name>
  <files>
    rust/Cargo.toml
    rust/src/output/console.rs
    rust/src/output/mod.rs
  </files>
  <action>
Add owo-colors dependency to Cargo.toml:
```toml
owo-colors = "4"
```

Create `rust/src/output/console.rs` implementing `pub fn render_console(files: &[FileAnalysisResult], duplication: Option<&DuplicationResult>, config: &ResolvedConfig, writer: &mut dyn std::io::Write) -> anyhow::Result<()>`.

The output format must match Zig ESLint-style exactly (from 19-RESEARCH.md "Console Output Format"):
```
src/example.ts
  10:0  warning  Cyclomatic complexity 12 exceeds warning threshold 10  complexity-guard/cyclomatic
  25:4  error    Cognitive complexity 31 exceeds error threshold 30     complexity-guard/cognitive

1 file, 2 functions, 1 warning, 1 error
Health score: 72.4
```

Key formatting rules:
- File path line: plain text, no color
- Violation line: `  {line}:{col}  {level}  {message}  {rule-id}` — line/col in dim, "warning" in yellow, "error" in red, rule-id in dim
- Summary line: bold counts
- Health score: green >= 80, yellow >= 60, red < 60
- Verbose mode (from config): show all functions including ok status
- Quiet mode (from config): errors only, suppress warnings and ok
- Determine violations by comparing each metric to thresholds from config (warning and error thresholds for cyclomatic, cognitive, halstead_volume, halstead_difficulty, halstead_effort, halstead_bugs, nesting_depth, line_count, params_count)

Implement color detection logic matching Zig shouldUseColor:
1. `--no-color` → no color
2. `--color` → color
3. `NO_COLOR` env → no color
4. `FORCE_COLOR` or `YES_COLOR` env → color
5. stdout.is_terminal() → color

Use owo-colors `OwoColorize` trait methods. When color is disabled, output plain text without ANSI codes — use `owo_colors::set_override(false)` at program start if no color.

Update `rust/src/output/mod.rs` to export console module and add format dispatch function.

Add unit tests:
- Verify a file with violations produces correct ESLint format lines
- Verify summary line counts are correct
- Verify quiet mode suppresses warnings
- Verify verbose mode includes ok functions
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test output::console -- --nocapture 2>&1 | tail -20</automated>
  </verify>
  <done>Console output matches Zig ESLint-style format exactly. Color respects all flag/env combinations. Quiet and verbose modes work correctly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON output renderer with exact Zig schema parity</name>
  <files>
    rust/src/output/json_output.rs
    rust/src/output/mod.rs
    rust/src/main.rs
  </files>
  <action>
Create `rust/src/output/json_output.rs` with serde Serialize structs matching the exact Zig JSON schema from 19-RESEARCH.md "JSON Output Schema":

```rust
#[derive(serde::Serialize)]
pub struct JsonOutput { version, timestamp, summary, files, metadata, duplication }
pub struct JsonSummary { files_analyzed, total_functions, warnings, errors, status, health_score }
pub struct JsonFileOutput { path, functions, file_length, export_count }
pub struct JsonFunctionOutput { name, start_line, end_line, start_col, cyclomatic, cognitive, halstead_volume, halstead_difficulty, halstead_effort, halstead_bugs, nesting_depth, line_count, params_count, health_score, status }
pub struct JsonMetadata { elapsed_ms, thread_count }
```

Field names MUST match Zig exactly (all snake_case — serde's default matches). The `status` field is computed per-function: "error" if any metric exceeds error threshold, "warning" if any exceeds warning, else "ok". The summary `status` is: "error" if any function has errors, "warning" if any has warnings, else "pass".

Implement `pub fn render_json(files: &[FileAnalysisResult], duplication: Option<&DuplicationResult>, config: &ResolvedConfig, elapsed_ms: u64) -> anyhow::Result<String>` that:
1. Converts FileAnalysisResult/FunctionAnalysisResult into JsonOutput structs
2. Computes status fields by comparing metrics against thresholds
3. Sets `timestamp` to current Unix epoch seconds
4. Sets `version` to `env!("CARGO_PKG_VERSION")`
5. Serializes with `serde_json::to_string_pretty`

The `duplication` field in JsonOutput is `Option<JsonDuplicationOutput>` — serialized as `null` when None (matching Zig behavior).

Update `rust/src/output/mod.rs` to export json_output and add JSON to format dispatch.

Wire format dispatch into `rust/src/main.rs` — when `--format json` is specified, call render_json and print to stdout (or file if `--output` specified).

Add unit tests:
- Verify JSON output deserializes back and has correct field names
- Verify status computation: "ok", "warning", "error" per function
- Verify summary status: "pass", "warning", "error"
- Verify duplication is null when not provided
- Verify timestamp is present and reasonable
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test output::json_output -- --nocapture 2>&1 | tail -20</automated>
  </verify>
  <done>JSON output matches Zig schema exactly — same field names, nesting structure, array ordering. Status fields computed correctly from thresholds. Duplication field serializes as null when absent.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without warnings
2. `cargo test` — all tests pass including new console and JSON output tests
3. Console output format matches ESLint-style with correct spacing, colors, and summary
4. JSON output field names match Zig schema exactly (snake_case, no renames needed)
5. `--format console` and `--format json` dispatch correctly
</verification>

<success_criteria>
- Console output matches Zig ESLint-style format (column layout, severity labels, per-function and per-file sections)
- JSON output matches Zig schema exactly (field names, nesting, array ordering)
- Color detection follows Zig priority chain (flags > env vars > TTY)
- Quiet and verbose modes work for console output
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-cli-config-and-output-formats/19-02-SUMMARY.md`
</output>
