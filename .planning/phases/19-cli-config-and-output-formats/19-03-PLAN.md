---
phase: 19-cli-config-and-output-formats
plan: 03
type: execute
wave: 2
depends_on: ["19-01"]
files_modified:
  - rust/src/output/sarif_output.rs
  - rust/src/output/html_output.rs
  - rust/src/output/assets/report.css
  - rust/src/output/assets/report.js
  - rust/src/output/assets/report.html
  - rust/src/output/mod.rs
  - rust/src/main.rs
autonomous: true
requirements:
  - OUT-03
  - OUT-04

must_haves:
  truths:
    - "SARIF 2.1.0 output is valid JSON with correct camelCase field names and all 11 rule definitions"
    - "SARIF output would be accepted by GitHub Code Scanning (schema URL, version, runs, results present)"
    - "HTML report is fully self-contained — no external requests, CSS and JS embedded inline"
    - "HTML report includes duplication section when duplication results are present"
  artifacts:
    - path: "rust/src/output/sarif_output.rs"
      provides: "SARIF 2.1.0 output with hand-rolled structs"
      contains: "pub fn render_sarif"
    - path: "rust/src/output/html_output.rs"
      provides: "Self-contained HTML report renderer"
      contains: "pub fn render_html"
    - path: "rust/src/output/assets/report.css"
      provides: "Embedded CSS for HTML report"
    - path: "rust/src/output/assets/report.js"
      provides: "Embedded JS for HTML report (sortTable, treemap, charts)"
    - path: "rust/src/output/assets/report.html"
      provides: "HTML template for minijinja rendering"
  key_links:
    - from: "rust/src/output/sarif_output.rs"
      to: "rust/src/types.rs"
      via: "converts FileAnalysisResult to SARIF results"
      pattern: "FileAnalysisResult"
    - from: "rust/src/output/html_output.rs"
      to: "rust/src/output/assets/"
      via: "include_str! embedding"
      pattern: "include_str!"
    - from: "rust/src/output/mod.rs"
      to: "rust/src/output/sarif_output.rs"
      via: "format dispatch"
      pattern: "render_sarif"
---

<objective>
Implement SARIF 2.1.0 and self-contained HTML output format renderers.

Purpose: SARIF enables GitHub Code Scanning integration. HTML provides standalone shareable reports. Both are critical for CI/CD and reporting workflows matching the Zig binary capabilities.
Output: Two complete output renderers for --format sarif and --format html.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-cli-config-and-output-formats/19-RESEARCH.md
@.planning/phases/19-cli-config-and-output-formats/19-01-SUMMARY.md
@rust/src/types.rs
@rust/src/output/mod.rs
@src/output/sarif_output.zig
@src/output/html_output.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SARIF 2.1.0 output with hand-rolled serde structs</name>
  <files>
    rust/src/output/sarif_output.rs
    rust/src/output/mod.rs
  </files>
  <action>
Create `rust/src/output/sarif_output.rs` with hand-rolled SARIF structs (NOT using serde-sarif — per STATE.md concern about pre-1.0 stability).

Define structs with `#[serde(rename_all = "camelCase")]` where needed:
- `SarifLog` — top-level with `#[serde(rename = "$schema")]` for schema field, `version: &str`, `runs: Vec<SarifRun>`
- `SarifRun` — `tool: SarifTool`, `results: Vec<SarifResult>`
- `SarifTool` — `driver: SarifDriver`
- `SarifDriver` — `name`, `version`, `information_uri` (renamed to camelCase), `rules: Vec<SarifRule>`
- `SarifRule` — `id`, `short_description` (renamed), `full_description` (renamed), `help_uri` (renamed), `default_configuration` (renamed) containing `level`
- `SarifResult` — `rule_id` (renamed), `rule_index` (renamed), `level`, `message: SarifMessage`, `locations: Vec<SarifLocation>`, optional `related_locations`
- `SarifLocation` — `physical_location` (renamed) containing `artifact_location` (renamed) with `uri`, and `region` with `start_line`, `start_column`, `end_line` (all renamed to camelCase)
- `SarifMessage` — `text: String`

Constants (from 19-RESEARCH.md):
- SARIF_SCHEMA URL, SARIF_VERSION "2.1.0"
- TOOL_NAME "ComplexityGuard", TOOL_VERSION from env!("CARGO_PKG_VERSION")
- TOOL_INFO_URI "https://github.com/benvds/complexity-guard"

Include all 11 rule definitions matching the Zig source exactly (from 19-RESEARCH.md):
- Rules 0-10: cyclomatic, cognitive, halstead-volume, halstead-difficulty, halstead-effort, halstead-bugs, line-count, param-count, nesting-depth, health-score, duplication
- Each rule has: id (e.g., "complexity-guard/cyclomatic"), shortDescription, fullDescription, helpUri, defaultConfiguration with level ("warning" or "error")

Implement `pub fn render_sarif(files: &[FileAnalysisResult], duplication: Option<&DuplicationResult>, config: &ResolvedConfig) -> anyhow::Result<String>`:
1. Build the driver with all 11 rules
2. For each file, for each function, check each metric against thresholds
3. Create a SarifResult for each violation with: correct rule_id, rule_index (matching the rule array index), level ("warning" or "error"), location with file URI and line/column region
4. Serialize to pretty JSON via `serde_json::to_string_pretty`

Read the Zig source at `src/output/sarif_output.zig` during implementation to match rule descriptions and default levels exactly.

Update `rust/src/output/mod.rs` to export sarif_output.

Add unit tests:
- Verify SARIF output parses as valid JSON
- Verify `$schema` field is present and correct
- Verify version is "2.1.0"
- Verify all 11 rules are in the driver
- Verify camelCase field names (startLine, ruleIndex, physicalLocation, etc.)
- Verify results are generated for functions exceeding thresholds
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test output::sarif -- --nocapture 2>&1 | tail -20</automated>
  </verify>
  <done>SARIF 2.1.0 output has correct schema URL, version, all 11 rules, camelCase field names, and generates results for threshold violations. Output parses as valid JSON.</done>
</task>

<task type="auto">
  <name>Task 2: Implement self-contained HTML report with embedded CSS/JS and minijinja template</name>
  <files>
    rust/Cargo.toml
    rust/src/output/html_output.rs
    rust/src/output/assets/report.css
    rust/src/output/assets/report.js
    rust/src/output/assets/report.html
    rust/src/output/mod.rs
    rust/src/main.rs
  </files>
  <action>
Add minijinja dependency to Cargo.toml:
```toml
minijinja = "2"
```

Extract CSS and JS from the Zig source (`src/output/html_output.zig`) into separate asset files:
- `rust/src/output/assets/report.css` — extract the full CSS string constant (~235 lines) from the Zig source verbatim
- `rust/src/output/assets/report.js` — extract the full JS string constant from the Zig source verbatim (includes sortTable, SVG treemap rendering, bar chart functions)
- `rust/src/output/assets/report.html` — create a minijinja template that produces the same HTML structure as the Zig source:
  - DOCTYPE html with embedded `<style>{{ css }}</style>` and `<script>{{ js }}</script>`
  - Header with title and summary stats
  - File table with sortable columns
  - Function details per file
  - Conditional duplication section (only rendered when duplication data present)
  - Health score display with color coding

Create `rust/src/output/html_output.rs`:
```rust
const CSS: &str = include_str!("assets/report.css");
const JS: &str = include_str!("assets/report.js");
const TEMPLATE: &str = include_str!("assets/report.html");
```

Implement `pub fn render_html(files: &[FileAnalysisResult], duplication: Option<&DuplicationResult>, config: &ResolvedConfig, elapsed_ms: u64) -> anyhow::Result<String>`:
1. Create minijinja Environment, add template
2. Build context with css, js, files data, summary stats, duplication data, health scores
3. Render template and return HTML string

The HTML report must be fully self-contained — no external CSS, JS, font, or image requests. Verify by checking the output contains no `http://` or `https://` URLs in link/script/img tags.

Update `rust/src/output/mod.rs` to export html_output and complete the full format dispatch (console, json, sarif, html).

Wire all four formats into `rust/src/main.rs` format dispatch — when `--output` is specified, write to file instead of stdout.

Add unit tests:
- Verify HTML output contains `<!DOCTYPE html>`
- Verify CSS is embedded (contains `<style>` block with actual CSS content)
- Verify JS is embedded (contains `<script>` block with actual JS content)
- Verify no external URL references in link/script/img tags
- Verify duplication section present when duplication data provided
- Verify duplication section absent when no duplication data
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test output::html -- --nocapture 2>&1 | tail -20</automated>
  </verify>
  <done>HTML report is fully self-contained with embedded CSS/JS. Duplication section conditionally rendered. No external requests. Template renders correctly via minijinja.</done>
</task>

</tasks>

<verification>
1. `cargo build` compiles without warnings
2. `cargo test` — all tests pass including SARIF and HTML output tests
3. SARIF output has valid structure with camelCase fields and all 11 rules
4. HTML output is self-contained (no external URLs)
5. `--format sarif` and `--format html` dispatch correctly
6. `--output filename` writes to file instead of stdout
</verification>

<success_criteria>
- SARIF 2.1.0 output has correct schema, version, all 11 rules, camelCase field names
- SARIF output would pass GitHub Code Scanning schema validation
- HTML report is self-contained with same embedded JS/CSS as Zig version
- Duplication section renders conditionally in HTML
- All four output formats dispatch correctly via --format flag
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/19-cli-config-and-output-formats/19-03-SUMMARY.md`
</output>
