---
phase: 03-file-discovery-parsing
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - build.zig
  - build.zig.zon
  - vendor/tree-sitter/
  - vendor/tree-sitter-typescript/
  - vendor/tree-sitter-javascript/
  - src/parser/tree_sitter.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tree-sitter C sources compile as part of zig build"
    - "Zig code can call tree-sitter C API functions via @cImport"
    - "TypeScript, TSX, and JavaScript parsers are available as language functions"
  artifacts:
    - path: "vendor/tree-sitter/"
      provides: "Tree-sitter core C library source"
    - path: "vendor/tree-sitter-typescript/"
      provides: "TypeScript and TSX grammar C sources"
    - path: "vendor/tree-sitter-javascript/"
      provides: "JavaScript grammar C source"
    - path: "build.zig"
      provides: "C compilation steps for tree-sitter"
      contains: "linkLibC"
    - path: "src/parser/tree_sitter.zig"
      provides: "Zig bindings wrapping tree-sitter C API"
      exports: ["Parser", "Language", "Tree"]
  key_links:
    - from: "build.zig"
      to: "vendor/tree-sitter/"
      via: "addCSourceFile and addIncludePath"
      pattern: "addCSourceFile"
    - from: "src/parser/tree_sitter.zig"
      to: "tree_sitter/api.h"
      via: "@cImport"
      pattern: "@cImport"
---

<objective>
Vendor tree-sitter C libraries as git submodules, configure build.zig to compile them,
and create a thin Zig binding module that wraps the tree-sitter C API.

Purpose: Establish the C interop foundation that all parsing depends on. This is the
highest-risk task in Phase 3 (C/Zig boundary, linker configuration, header resolution)
so it is isolated to get fast feedback.

Output: vendor/ directory with tree-sitter sources, build.zig compiling C code,
src/parser/tree_sitter.zig with safe Zig wrappers around ts_parser_new/delete/parse.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-file-discovery-parsing/03-RESEARCH.md
@build.zig
@build.zig.zon
@src/main.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vendor tree-sitter and configure build.zig</name>
  <files>
    vendor/tree-sitter/
    vendor/tree-sitter-typescript/
    vendor/tree-sitter-javascript/
    build.zig
  </files>
  <action>
    1. Add tree-sitter repositories as git submodules:
       - `git submodule add https://github.com/tree-sitter/tree-sitter vendor/tree-sitter`
       - `git submodule add https://github.com/tree-sitter/tree-sitter-typescript vendor/tree-sitter-typescript`
       - `git submodule add https://github.com/tree-sitter/tree-sitter-javascript vendor/tree-sitter-javascript`

    2. Update build.zig to compile tree-sitter C sources. Add to BOTH the exe and unit_tests targets:
       - Call `linkLibC()` on both exe and unit_tests
       - Add include path: `vendor/tree-sitter/lib/include`
       - Add C source: `vendor/tree-sitter/lib/src/lib.c` with flags `&.{"-std=c11"}`
       - Add TypeScript parser: include path `vendor/tree-sitter-typescript/typescript/src`, C sources `parser.c` and `scanner.c` with `-std=c11`
       - Add TSX parser: include path `vendor/tree-sitter-typescript/tsx/src`, C sources `parser.c` and `scanner.c` with `-std=c11`
       - Add JavaScript parser: include path `vendor/tree-sitter-javascript/src`, C sources `parser.c` and `scanner.c` with `-std=c11`

    IMPORTANT: Apply the same addIncludePath/addCSourceFile calls to BOTH `exe` and `unit_tests`
    so tests can also use tree-sitter. Extract a helper function like `addTreeSitterSources(step)` to
    avoid duplication.

    NOTE: The tree-sitter lib.c file may need `-std=c11 -fno-sanitize=undefined` to avoid
    sanitizer issues. Add `-fno-sanitize=undefined` if compilation fails without it.

    NOTE: Some tree-sitter scanner files are C++ (.cc). Check if `scanner.c` exists; if the
    TypeScript scanner is actually `scanner.cc`, use `.flags = &.{"-std=c++14"}` for it instead.
    The JavaScript scanner.c should be standard C.
  </action>
  <verify>
    Run `zig build` -- must compile without errors including all tree-sitter C sources.
    Run `zig build test` -- must also compile and run existing tests without regressions.
  </verify>
  <done>
    `zig build` produces binary that links tree-sitter. `zig build test` passes all existing tests.
    vendor/ directory contains tree-sitter, tree-sitter-typescript, tree-sitter-javascript.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tree-sitter Zig bindings module</name>
  <files>
    src/parser/tree_sitter.zig
    src/main.zig
  </files>
  <action>
    Create `src/parser/tree_sitter.zig` that wraps the tree-sitter C API in safe Zig idioms:

    1. Import the C API via `@cImport`:
       ```
       const c = @cImport({
           @cInclude("tree_sitter/api.h");
       });
       ```

    2. Declare external language functions (these are provided by the compiled parser.c files):
       ```
       extern fn tree_sitter_typescript() *const c.TSLanguage;
       extern fn tree_sitter_tsx() *const c.TSLanguage;
       extern fn tree_sitter_javascript() *const c.TSLanguage;
       ```

    3. Create a `Language` enum: `typescript`, `tsx`, `javascript` with a method
       `toTSLanguage() -> *const c.TSLanguage` that calls the appropriate extern function.

    4. Create a `Tree` struct wrapping `*c.TSTree` with:
       - `rootNode() -> Node` returning the root node
       - `deinit()` calling `c.ts_tree_delete()`

    5. Create a `Node` struct wrapping `c.TSNode` with:
       - `hasError() -> bool` calling `c.ts_node_has_error()`
       - `childCount() -> u32` calling `c.ts_node_child_count()`
       - `nodeType() -> []const u8` from `c.ts_node_type()` using `std.mem.span()`
       - `startPoint() -> Point` and `endPoint() -> Point` for location info
       - `child(index: u32) -> ?Node` returning null if index out of bounds

    6. Create a `Point` struct with `row: u32` and `column: u32` fields.

    7. Create a `Parser` struct wrapping `*c.TSParser` with:
       - `init() -> !Parser` calling `c.ts_parser_new()`, returns error if null
       - `deinit()` calling `c.ts_parser_delete()`
       - `setLanguage(lang: Language) -> !void` calling `c.ts_parser_set_language()`
       - `parseString(source: []const u8) -> !Tree` calling `c.ts_parser_parse_string()`
         with null old_tree, casting source.ptr and source.len appropriately

    8. Add inline tests that verify:
       - Parser can be created and destroyed (memory test with testing.allocator)
       - Parser can set TypeScript language
       - Parser can parse a simple string like "const x = 1;" and get a root node
       - Root node of valid code has no errors
       - Root node type is "program"

    9. Update `src/main.zig` test block to import `@import("parser/tree_sitter.zig")` for test discovery.
  </action>
  <verify>
    Run `zig build test` -- all new tree_sitter.zig tests pass plus existing tests.
    Specifically verify: parser creation, language setting, string parsing, node traversal.
  </verify>
  <done>
    src/parser/tree_sitter.zig exists with Parser, Tree, Node, Language types.
    Tests prove: create parser, set language, parse "const x = 1;", get root node, root has no errors.
    All three language variants (typescript, tsx, javascript) can be set on a parser.
  </done>
</task>

</tasks>

<verification>
- `zig build` compiles successfully with tree-sitter C sources linked
- `zig build test` passes all tests (old and new)
- Tree-sitter Zig bindings parse a TypeScript string and produce a valid AST root node
- No memory leaks detected by std.testing.allocator in tests
</verification>

<success_criteria>
Tree-sitter C library is vendored, compiled by build.zig, and accessible from Zig code
via a clean binding module. Parser can parse TypeScript, TSX, and JavaScript strings
and return traversable AST nodes. All existing tests continue to pass.
</success_criteria>

<output>
After completion, create `.planning/phases/03-file-discovery-parsing/03-01-SUMMARY.md`
</output>
