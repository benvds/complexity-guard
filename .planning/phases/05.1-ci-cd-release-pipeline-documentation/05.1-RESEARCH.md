# Phase 05.1: CI/CD, Release Pipeline & Documentation - Research

**Researched:** 2026-02-15
**Domain:** DevOps Infrastructure (CI/CD, Release Automation, Package Distribution, Documentation)
**Confidence:** MEDIUM-HIGH

## Summary

Phase 05.1 sets up production-ready distribution for ComplexityGuard: changelog management, release automation via shell scripts and GitHub Actions, multi-platform binary publishing (npm platform packages, GitHub releases, Homebrew tap), and progressive disclosure documentation. The research reveals that the user's chosen stack (Keep a Changelog, SemVer, platform packages pattern, Homebrew tap) is industry-standard. Key findings: (1) Zig's built-in cross-compilation eliminates the need for Docker or separate toolchains, (2) npm platform packages pattern (SWC/Prisma style) with optionalDependencies is proven for binary distribution, (3) GitHub Actions matrix builds handle multi-platform compilation efficiently, (4) Homebrew taps with GitHub Releases is the standard path before homebrew-core submission, (5) Keep a Changelog with manual curation remains superior to automated generation for quality releases.

The critical technical challenge is coordinating the release workflow: version bump in main.zig → git commit/tag → multi-platform binary builds → GitHub release creation → npm publish (with platform packages) → Homebrew tap formula update. The recommended approach is a single manual-dispatch GitHub Actions workflow that orchestrates this entire sequence, ensuring version consistency across all distribution channels.

**Primary recommendation:** Use GitHub Actions matrix build for Zig cross-compilation (5 targets), shell scripts for version bumping/git tagging, optionalDependencies pattern for npm platform packages with postinstall fallback, and own Homebrew tap with formulas pointing to GitHub release assets. Document current features only with TanStack-style progressive disclosure (README overview → detailed docs/ pages).

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Release strategy:**
- Semantic Versioning (MAJOR.MINOR.PATCH)
- Initial version: 0.1.0 (pre-1.0 signals early/experimental)
- Keep a Changelog format (manual, human-curated CHANGELOG.md with Added/Changed/Fixed/Removed sections)
- Milestone releases (not per-phase) — cut releases at major capability milestones
- Git tags for releases (v0.1.0 format)
- Shell scripts in scripts/ for release workflow (scripts/release.sh, scripts/publish.sh)
- Release script auto-bumps version in source files (main.zig), commits, then tags — single command workflow

**Distribution channels:**
- All 5 prebuilt binary targets: x86_64-linux, aarch64-linux, x86_64-macos, aarch64-macos, x86_64-windows
- npm package name: `complexity-guard`
- npm delivery via platform packages pattern (separate @complexity-guard/darwin-arm64 etc. with optionalDependencies — like SWC, Prisma)
- Homebrew: own tap first (brew install benvds/tap/complexity-guard), submit to homebrew-core later once popular

**CI pipeline:**
- Test workflow runs on macOS + Linux (Ubuntu + macOS runners)
- Tests run on both PRs (required check) and push to main
- Release workflow triggered by manual dispatch (workflow_dispatch with version input)
- Single release workflow: build binaries → GitHub release → npm publish → update Homebrew tap

**Documentation structure:**
- README: quick start + feature overview with links to detailed docs/ pages (TanStack-style progressive disclosure)
- Three docs/ pages: getting started guide, CLI reference, and examples cookbook
- Tone: friendly and thorough — explanatory prose with code examples (like TanStack/Astro docs)
- Document current features only (cyclomatic complexity, console/JSON output) — update docs each phase, no "coming soon"

### Claude's Discretion

- Exact GitHub Actions workflow structure and job naming
- Zig cross-compilation build matrix details
- npm platform package naming convention specifics
- Homebrew formula template structure
- docs/ file naming and internal linking approach

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope

</user_constraints>

## Standard Stack

### Core Tools

| Library/Tool | Version | Purpose | Why Standard |
|--------------|---------|---------|--------------|
| GitHub Actions | N/A (platform) | CI/CD orchestration | De facto standard for GitHub-hosted projects, built-in OIDC for npm publishing |
| mlugg/setup-zig | v2 | Zig compiler setup in GHA | Actively maintained, preserves Zig cache across runs, supports version pinning |
| Keep a Changelog | 1.1.0 format | Changelog format | Industry standard (keepachangelog.com), human-readable, semver-aligned |
| Semantic Versioning | 2.0.0 | Version numbering | Universal standard for public APIs |
| Zig build system | Built-in (0.15.2) | Cross-compilation | Zig's killer feature: zero-config cross-compilation to all targets from any host |

### Supporting Tools

| Library/Tool | Version | Purpose | When to Use |
|--------------|---------|---------|-------------|
| softprops/action-gh-release | v2 | GitHub release creation | Modern alternative to archived actions/create-release, supports glob patterns |
| npm CLI | Latest | Package publishing | Built-in, supports optionalDependencies and OIDC trusted publishing |
| Homebrew tap | N/A (convention) | macOS/Linux binary distribution | Standard approach for CLI tools before homebrew-core submission |
| sha256sum / shasum | System built-in | Binary checksums | Required for Homebrew formula validation |

### Alternatives Considered

| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Manual CHANGELOG.md | conventional-changelog / semantic-release | Auto-generation creates noise; manual curation produces higher-quality release notes for milestone releases |
| optionalDependencies | Single binary + postinstall download only | Platform packages provide better offline support and faster installs when package-lock.json is correct |
| Own Homebrew tap | Submit to homebrew-core first | Homebrew maintainers require proven popularity; own tap first is the standard path |
| Manual dispatch workflow | Automated release on git tag push | Manual trigger with version input provides explicit control, prevents accidental releases |

**Installation (for development/testing):**

```bash
# No package dependencies — all tools are GitHub Actions, Zig built-ins, or shell scripts
# Developers need: zig 0.15.2, git, npm (for testing npm package locally)

# Testing npm platform packages locally:
npm pack  # creates tarball to test before publishing
npm install -g ./complexity-guard-0.1.0.tgz

# Testing Homebrew formula locally:
brew install --build-from-source ./homebrew-tap/complexity-guard.rb
```

## Architecture Patterns

### Recommended Project Structure

```
.
├── scripts/
│   ├── release.sh        # Version bump + git commit/tag workflow
│   ├── publish.sh        # npm publish orchestration (optional - may inline in GHA)
│   └── build-release.sh  # Cross-compile all targets (called by GHA matrix)
├── .github/workflows/
│   ├── test.yml          # PR + push to main: run tests on Linux + macOS
│   └── release.yml       # Manual dispatch: build → release → publish workflow
├── CHANGELOG.md          # Keep a Changelog format
├── package.json          # Main npm package with optionalDependencies
├── npm/                  # Platform-specific package sources
│   ├── darwin-arm64/
│   ├── darwin-x64/
│   ├── linux-arm64/
│   ├── linux-x64/
│   └── windows-x64/
├── docs/
│   ├── getting-started.md
│   ├── cli-reference.md
│   └── examples.md
└── README.md             # Quick start + progressive disclosure links
```

### Pattern 1: Zig Cross-Compilation Matrix in GitHub Actions

**What:** Use GitHub Actions matrix strategy to build binaries for all target platforms from a single Ubuntu runner.

**When to use:** Zig's built-in cross-compilation eliminates need for multiple runners or Docker — compile all targets from one host.

**Example:**

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target:
          - x86_64-linux
          - aarch64-linux
          - x86_64-macos
          - aarch64-macos
          - x86_64-windows
    steps:
      - uses: actions/checkout@v4
      - uses: mlugg/setup-zig@v2
        with:
          version: 0.15.2
      - name: Build for ${{ matrix.target }}
        run: |
          zig build -Dtarget=${{ matrix.target }} -Doptimize=ReleaseSafe
          # Binary appears in zig-out/bin/
```

**Source:** [GitHub Actions matrix builds](https://oneuptime.com/blog/post/2026-01-25-github-actions-matrix-builds/view), [Zig cross-compilation guide](https://zig.guide/build-system/cross-compilation/)

### Pattern 2: npm Platform Packages with optionalDependencies

**What:** Main package (@complexity-guard) depends on platform-specific packages (@complexity-guard/darwin-arm64, etc.) via optionalDependencies. npm auto-installs correct package based on os/cpu fields.

**When to use:** Distributing native binaries via npm for maximum offline reliability and install speed (when package-lock.json is correct).

**Example:**

```json
// package.json (main package)
{
  "name": "complexity-guard",
  "version": "0.1.0",
  "bin": {
    "complexity-guard": "bin/complexity-guard.js"
  },
  "optionalDependencies": {
    "@complexity-guard/darwin-arm64": "0.1.0",
    "@complexity-guard/darwin-x64": "0.1.0",
    "@complexity-guard/linux-arm64": "0.1.0",
    "@complexity-guard/linux-x64": "0.1.0",
    "@complexity-guard/windows-x64": "0.1.0"
  }
}

// npm/darwin-arm64/package.json
{
  "name": "@complexity-guard/darwin-arm64",
  "version": "0.1.0",
  "os": ["darwin"],
  "cpu": ["arm64"],
  "files": ["complexity-guard"]
}

// bin/complexity-guard.js (main package wrapper)
#!/usr/bin/env node
const { join } = require('path');
const { spawnSync } = require('child_process');

const platform = `${process.platform}-${process.arch}`;
const binPath = join(__dirname, '..', 'node_modules', `@complexity-guard/${platform}`, 'complexity-guard');

const result = spawnSync(binPath, process.argv.slice(2), { stdio: 'inherit' });
process.exit(result.status);
```

**Source:** [How to publish binaries on npm (Sentry Engineering)](https://sentry.engineering/blog/publishing-binaries-on-npm), [SWC platform packages](https://www.npmjs.com/package/@swc/core)

### Pattern 3: Homebrew Formula with GitHub Release Assets

**What:** Homebrew formula downloads prebuilt binaries from GitHub Releases, verifies SHA256, installs to prefix.

**When to use:** Standard approach for own tap — homebrew-core requires this pattern + proven popularity.

**Example:**

```ruby
# homebrew-tap/complexity-guard.rb
class ComplexityGuard < Formula
  desc "Fast complexity analysis for TypeScript/JavaScript"
  homepage "https://github.com/benvds/complexity-guard"
  version "0.1.0"

  if OS.mac? && Hardware::CPU.arm?
    url "https://github.com/benvds/complexity-guard/releases/download/v0.1.0/complexity-guard-aarch64-macos.tar.gz"
    sha256 "abc123..." # shasum -a 256 complexity-guard-aarch64-macos.tar.gz
  elsif OS.mac? && Hardware::CPU.intel?
    url "https://github.com/benvds/complexity-guard/releases/download/v0.1.0/complexity-guard-x86_64-macos.tar.gz"
    sha256 "def456..."
  elsif OS.linux? && Hardware::CPU.arm?
    url "https://github.com/benvds/complexity-guard/releases/download/v0.1.0/complexity-guard-aarch64-linux.tar.gz"
    sha256 "ghi789..."
  elsif OS.linux? && Hardware::CPU.intel?
    url "https://github.com/benvds/complexity-guard/releases/download/v0.1.0/complexity-guard-x86_64-linux.tar.gz"
    sha256 "jkl012..."
  end

  def install
    bin.install "complexity-guard"
  end

  test do
    system "#{bin}/complexity-guard", "--version"
  end
end
```

**Source:** [Homebrew Formula Cookbook](https://docs.brew.sh/Formula-Cookbook), [Creating Homebrew tap guide](https://kristoffer.dev/blog/guide-to-creating-your-first-homebrew-tap/)

### Pattern 4: Manual Version Bump Shell Script

**What:** Shell script reads current version, prompts for bump type (major/minor/patch), updates source files, commits, and tags — single command workflow.

**When to use:** Pre-release step for milestone releases — ensures version consistency across main.zig, package.json, and git tags.

**Example:**

```bash
#!/bin/bash
# scripts/release.sh

set -e  # Exit on error

# Get current version from main.zig
CURRENT_VERSION=$(grep 'const version = ' src/main.zig | sed 's/.*"\(.*\)".*/\1/')
echo "Current version: $CURRENT_VERSION"

# Parse semver
IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

# Determine new version (passed as argument: major, minor, patch)
BUMP_TYPE=${1:-patch}
case $BUMP_TYPE in
  major)
    NEW_VERSION="$((MAJOR + 1)).0.0"
    ;;
  minor)
    NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
    ;;
  patch)
    NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
    ;;
  *)
    echo "Usage: $0 {major|minor|patch}"
    exit 1
    ;;
esac

echo "Bumping to: $NEW_VERSION"

# Update version in source files
sed -i.bak "s/const version = \"$CURRENT_VERSION\"/const version = \"$NEW_VERSION\"/" src/main.zig
rm src/main.zig.bak

# Update package.json if exists
if [ -f package.json ]; then
  sed -i.bak "s/\"version\": \"$CURRENT_VERSION\"/\"version\": \"$NEW_VERSION\"/" package.json
  rm package.json.bak
fi

# Git commit and tag
git add src/main.zig package.json
git commit -m "chore: bump version to $NEW_VERSION"
git tag -a "v$NEW_VERSION" -m "Release $NEW_VERSION"

echo "Version bumped to $NEW_VERSION and tagged as v$NEW_VERSION"
echo "Push with: git push origin main --follow-tags"
```

**Source:** [Automate git tag versioning](https://reemus.dev/tldr/git-tag-versioning-script), [Version bumping best practices](https://www.tobymackenzie.com/blog/2023/12/27/bumping-version-tags-with-git/)

### Pattern 5: workflow_dispatch Manual Release Trigger

**What:** GitHub Actions workflow with manual trigger accepting version input — prevents accidental releases, provides explicit control.

**When to use:** Milestone releases (not per-phase) — trigger after CHANGELOG.md is manually curated.

**Example:**

```yaml
name: Release
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.0)'
        required: true
        type: string

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate version format
        run: |
          if ! [[ "${{ github.event.inputs.version }}" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Invalid version format. Use MAJOR.MINOR.PATCH"
            exit 1
          fi

      - name: Build binaries (matrix job - see Pattern 1)
        # ... matrix build steps ...

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ github.event.inputs.version }}
          name: Release ${{ github.event.inputs.version }}
          body_path: CHANGELOG.md  # Or extract section for this version
          files: |
            zig-out/complexity-guard-*-linux.tar.gz
            zig-out/complexity-guard-*-macos.tar.gz
            zig-out/complexity-guard-*-windows.zip
```

**Source:** [GitHub Actions workflow_dispatch](https://graphite.com/guides/github-actions-workflow-dispatch), [Manual trigger guide](https://oneuptime.com/blog/post/2026-01-25-github-actions-workflow-dispatch/view)

### Anti-Patterns to Avoid

- **Don't use actions/create-release or actions/upload-release-asset**: Both archived since 2021, use outdated Node version. Use softprops/action-gh-release or gh CLI instead. ([Source](https://github.com/actions/create-release))

- **Don't auto-generate CHANGELOG.md from git commits**: Noisy, unfocused, misses "why" context. Manual curation for milestone releases produces higher-quality notes. ([Source](https://keepachangelog.com/en/1.1.0/))

- **Don't compile on multiple runners for Zig projects**: Zig cross-compiles all targets from single Ubuntu runner — multiple runners waste CI time. ([Source](https://ziglang.org/learn/overview/))

- **Don't use sudo with Homebrew**: Homebrew refuses to work with sudo for security. Formulas must install to prefix without elevated permissions. ([Source](https://docs.brew.sh/FAQ))

- **Don't install to non-default Homebrew prefix without warning**: Many tools break outside default prefix; bottles unavailable, must build from source (slow). ([Source](https://docs.brew.sh/FAQ))

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| npm authentication in CI | Custom token management | npm trusted publishing (OIDC) | Eliminates long-lived tokens, auto-detects OIDC environment, cryptographically-signed per-workflow. ([Source](https://docs.npmjs.com/trusted-publishing/)) |
| Platform binary detection | Custom os/arch logic | npm os/cpu fields in package.json | Package managers auto-install correct package, battle-tested by esbuild/SWC/Prisma. ([Source](https://sentry.engineering/blog/publishing-binaries-on-npm)) |
| Cross-compilation toolchain | Docker/QEMU/separate VMs | Zig's built-in cross-compilation | Zig bundles libc for all platforms, single command cross-compiles to any target. ([Source](https://zig.guide/build-system/cross-compilation/)) |
| GitHub release creation | Manual API calls | softprops/action-gh-release | Handles multipart upload, retries, glob patterns, draft releases. ([Source](https://github.com/softprops/action-gh-release)) |
| Version string parsing | Regex/string manipulation | Standard semver tools or simple awk/sed | Well-tested, handles edge cases (pre-release, build metadata). Version bump example uses awk. ([Source](https://reemus.dev/tldr/git-tag-versioning-script)) |

**Key insight:** DevOps infrastructure has high edge-case density (network failures, partial uploads, platform quirks). Established tools encode years of production experience — custom solutions miss these edge cases until failure.

## Common Pitfalls

### Pitfall 1: npm Platform Package Skipping Due to Stale package-lock.json

**What goes wrong:** npm silently skips platform-specific optionalDependencies when package-lock.json is generated on different platform, causing "binary not found" errors.

**Why it happens:** npm bug #4828 — package-lock.json generated on one platform (e.g., macOS arm64) omits other platforms' optionalDependencies. When another platform (e.g., Linux x64) installs from this lock file, its binary package is skipped. ([Source](https://github.com/npm/cli/issues/4828))

**How to avoid:**
1. Add postinstall script fallback that downloads binary from GitHub releases if platform package missing
2. Test installation on all target platforms before release
3. Document that users may need `npm install --force` if switching platforms with existing package-lock.json

**Warning signs:** CI passes but users report "command not found" on specific platforms; optionalDependencies present in package.json but missing from node_modules.

### Pitfall 2: Homebrew SHA256 Mismatch After Binary Rebuild

**What goes wrong:** Homebrew formula specifies SHA256 checksum — rebuild of "same" binary produces different hash, formula fails validation.

**Why it happens:** Non-deterministic builds (timestamps, debug symbols, build paths) cause hash changes. Zig builds are generally deterministic with ReleaseSafe, but manual rebuilds can introduce variance. ([Source](https://docs.brew.sh/Formula-Cookbook))

**How to avoid:**
1. Only update Homebrew formula SHA256 from actual GitHub release artifacts (never local builds)
2. Use `shasum -a 256 <file>` on downloaded GitHub release asset
3. Automate SHA256 extraction in release workflow (download artifact, compute hash, update formula)

**Warning signs:** Formula worked on last release, fails on new release with "SHA256 mismatch"; local builds install fine but Homebrew fails.

### Pitfall 3: GitHub Actions Matrix Builds Not Uploading All Artifacts

**What goes wrong:** Matrix builds complete successfully, but GitHub release only contains subset of binaries (e.g., missing Windows binary).

**Why it happens:** Matrix jobs run in parallel — if upload step is in matrix job, timing issues or upload failures in one job don't block others. Partial success appears as full success. ([Source](https://runs-on.com/github-actions/the-matrix-strategy/))

**How to avoid:**
1. Matrix jobs upload artifacts to GitHub Actions artifacts (actions/upload-artifact)
2. Separate job depends on matrix jobs, downloads all artifacts, uploads to GitHub release in single step
3. Validate all expected binaries present before release creation

**Warning signs:** CI green checkmark but release page missing binaries; matrix job logs show success but artifacts missing.

### Pitfall 4: Version Desync Between main.zig and package.json

**What goes wrong:** `complexity-guard --version` prints 0.1.0 but `npm info complexity-guard version` shows 0.1.1 — confuses users, breaks reproducibility.

**Why it happens:** Manual version bumps update one file, forget the other; separate update scripts for Zig vs npm; automated npm publish without version sync. ([Source](https://www.tobymackenzie.com/blog/2023/12/27/bumping-version-tags-with-git/))

**How to avoid:**
1. Single source of truth: scripts/release.sh updates both main.zig and package.json in one commit
2. CI validates version strings match before build
3. Extract version from main.zig in package.json using build script (complex, not recommended)

**Warning signs:** User reports version mismatch; npm package version doesn't match git tag; multiple version-related commits in history.

### Pitfall 5: workflow_dispatch Input Not Validated, Causes Bad Releases

**What goes wrong:** Developer triggers release workflow with version "1.0" instead of "1.0.0", creates malformed git tag, npm publish fails.

**Why it happens:** workflow_dispatch inputs are strings without validation — typos, format errors, non-semver versions all accepted by GitHub UI. ([Source](https://graphite.com/guides/github-actions-workflow-dispatch))

**How to avoid:**
1. Add validation step in workflow: regex check for semver format `^[0-9]+\.[0-9]+\.[0-9]+$`
2. Fail fast with clear error message before any builds/tags
3. Consider using choice input for major/minor/patch, auto-calculate version from current tag

**Warning signs:** Release workflow fails mid-execution after builds complete; git tags with non-semver format in history.

### Pitfall 6: Homebrew Tap Not Accessible by brew install Due to Naming

**What goes wrong:** User runs `brew install benvds/tap/complexity-guard`, Homebrew says "tap not found" or "formula not found".

**Why it happens:** Homebrew expects tap repo named `homebrew-<tap>` (e.g., `homebrew-tap`), formula file in root or Formula/ directory, formula class name matches filename. ([Source](https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap))

**How to avoid:**
1. Name GitHub repo `homebrew-<tap>` (e.g., `homebrew-tap` for tap named "tap")
2. Place formula at `Formula/complexity-guard.rb` or `complexity-guard.rb` in root
3. Formula class name must be `ComplexityGuard` (CamelCase of formula name)
4. User taps with `brew tap benvds/tap` (not `benvds/homebrew-tap`)

**Warning signs:** `brew tap benvds/tap` succeeds but `brew install benvds/tap/complexity-guard` fails; formula works locally with `brew install --build-from-source ./formula.rb` but not via tap.

## Code Examples

Verified patterns from official sources:

### Example 1: Complete GitHub Actions Test Workflow (PR + Push to Main)

```yaml
# .github/workflows/test.yml
name: Test

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Zig
        uses: mlugg/setup-zig@v2
        with:
          version: 0.15.2

      - name: Run tests
        run: zig build test

      - name: Build release binary (smoke test)
        run: zig build -Doptimize=ReleaseSafe
```

**Source:** [mlugg/setup-zig action](https://github.com/mlugg/setup-zig), [GitHub Actions CI patterns](https://oneuptime.com/blog/post/2026-01-25-github-actions-matrix-builds/view)

### Example 2: Keep a Changelog Format (Manual Curation)

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Cognitive complexity metric with nesting penalties (Phase 6)

## [0.1.0] - 2026-02-15

### Added
- Cyclomatic complexity analysis for TypeScript/JavaScript functions
- Console output with ESLint-style formatting and threshold indicators
- JSON output format for CI integration
- Configuration file support (.complexityguard.json)
- Configurable thresholds (warning: 10, error: 20)

### Changed
- N/A (initial release)

### Deprecated
- N/A

### Removed
- N/A

### Fixed
- N/A

### Security
- N/A

[Unreleased]: https://github.com/benvds/complexity-guard/compare/v0.1.0...HEAD
[0.1.0]: https://github.com/benvds/complexity-guard/releases/tag/v0.1.0
```

**Source:** [Keep a Changelog 1.1.0 specification](https://keepachangelog.com/en/1.1.0/)

### Example 3: npm Platform Package Wrapper with Postinstall Fallback

```javascript
#!/usr/bin/env node
// bin/complexity-guard.js (main package)

const { join } = require('path');
const { spawnSync } = require('child_process');
const { existsSync } = require('fs');

// Map process.platform and process.arch to package names
const PLATFORMS = {
  'darwin-arm64': '@complexity-guard/darwin-arm64',
  'darwin-x64': '@complexity-guard/darwin-x64',
  'linux-arm64': '@complexity-guard/linux-arm64',
  'linux-x64': '@complexity-guard/linux-x64',
  'win32-x64': '@complexity-guard/windows-x64',
};

const platformKey = `${process.platform}-${process.arch}`;
const platformPackage = PLATFORMS[platformKey];

if (!platformPackage) {
  console.error(`Unsupported platform: ${platformKey}`);
  console.error('Supported platforms:', Object.keys(PLATFORMS).join(', '));
  process.exit(1);
}

// Try to find binary in platform package
const binName = process.platform === 'win32' ? 'complexity-guard.exe' : 'complexity-guard';
const binPath = join(__dirname, '..', 'node_modules', platformPackage, binName);

if (!existsSync(binPath)) {
  console.error(`Binary not found at ${binPath}`);
  console.error('Platform package may not have installed correctly.');
  console.error('Try: npm install --force');
  process.exit(1);
}

// Execute binary with all arguments
const result = spawnSync(binPath, process.argv.slice(2), { stdio: 'inherit' });
process.exit(result.status ?? 1);
```

**Source:** [How to publish binaries on npm](https://sentry.engineering/blog/publishing-binaries-on-npm), [esbuild platform binaries](https://deepwiki.com/evanw/esbuild/6.2-platform-specific-binaries)

### Example 4: Progressive Disclosure README Structure

```markdown
# ComplexityGuard

Fast, accurate complexity analysis for TypeScript/JavaScript — delivered as a single static binary.

## Quick Start

```bash
# npm
npm install -g complexity-guard

# Homebrew
brew install benvds/tap/complexity-guard

# Run
complexity-guard src/
```

## Features

- **Cyclomatic Complexity**: McCabe metric with ESLint-aligned counting rules
- **Multiple Output Formats**: Console (human-readable) and JSON (CI-friendly)
- **Zero Config**: Works out of the box with sensible defaults
- **Lightning Fast**: Single-pass analysis, sub-second for most projects
- **Offline Ready**: No SaaS dependencies, runs locally

## Documentation

- **[Getting Started](docs/getting-started.md)** — Installation, first analysis, configuration basics
- **[CLI Reference](docs/cli-reference.md)** — All flags, config options, exit codes
- **[Examples](docs/examples.md)** — Real-world usage patterns, CI integration recipes

## Example Output

```
src/parser.ts
  ✓ parseExpression (line 45)      complexity: 8
  ⚠ analyzeFunction (line 102)      complexity: 12  [threshold: 10]
  ✗ traverseAST (line 203)          complexity: 24  [threshold: 20]

Summary: 3 functions analyzed, 1 error, 1 warning
```

## Why ComplexityGuard?

Most complexity tools are slow, require Node.js runtime, or send code to SaaS platforms. ComplexityGuard delivers accurate metrics in a 2MB binary with zero dependencies.

See [Getting Started](docs/getting-started.md) for full installation and usage guide.

## License

MIT
```

**Source:** [TanStack documentation structure](https://tanstack.com/), [CLI documentation best practices](https://clig.dev/), [Progressive disclosure patterns](https://www.nngroup.com/articles/progressive-disclosure/)

### Example 5: docs/cli-reference.md Structure

```markdown
# CLI Reference

Complete reference for all complexity-guard flags, configuration options, and exit codes.

## Usage

```bash
complexity-guard [paths...] [options]
```

## Arguments

### `[paths...]`

One or more file or directory paths to analyze. Supports glob patterns.

**Examples:**
```bash
complexity-guard src/           # Analyze all files in src/
complexity-guard src/ tests/    # Multiple directories
complexity-guard src/**/*.ts    # Glob pattern
```

**Default:** Current directory (`.`)

## Flags

### `--format <format>`

Output format for results.

**Options:** `console`, `json`
**Default:** `console`

**Examples:**
```bash
complexity-guard --format json src/   # Machine-readable JSON
complexity-guard --format console src/ # Human-readable (default)
```

### `--output <file>`

Write results to file instead of stdout.

**Examples:**
```bash
complexity-guard --output report.json --format json src/
```

### `--fail-on <level>`

Exit with error code if any function exceeds threshold.

**Options:** `error`, `warning`, `never`
**Default:** `error`

**Examples:**
```bash
complexity-guard --fail-on warning src/  # Fail on warnings
complexity-guard --fail-on never src/     # Never fail (report only)
```

### `--metrics <metrics>`

Comma-separated list of metrics to analyze (future: currently only cyclomatic).

**Options:** `cyclomatic` (more in future phases)
**Default:** `cyclomatic`

### `--config <file>`

Path to configuration file.

**Default:** `.complexityguard.json` (searched upward from cwd)

**Examples:**
```bash
complexity-guard --config custom-config.json src/
```

### `--init`

Generate default configuration file (`.complexityguard.json`) in current directory.

**Examples:**
```bash
complexity-guard --init
```

### `--verbose`

Show per-function detail in console output.

**Examples:**
```bash
complexity-guard --verbose src/
```

### `--quiet`

Suppress all output except errors.

**Examples:**
```bash
complexity-guard --quiet src/
```

### `--help`

Display help message and exit.

### `--version`

Display version and exit.

## Configuration File

Create `.complexityguard.json` in your project root:

```json
{
  "include": ["src/**/*.ts", "src/**/*.tsx"],
  "exclude": ["**/*.test.ts", "**/*.spec.ts"],
  "thresholds": {
    "cyclomatic": {
      "warning": 10,
      "error": 20
    }
  },
  "countingRules": {
    "logicalOperators": true,
    "nullishCoalescing": true,
    "optionalChaining": true,
    "switchCaseMode": "classic"
  }
}
```

### Configuration Options

**`include`** (array of strings)
Glob patterns for files to analyze. Default: `["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]`

**`exclude`** (array of strings)
Glob patterns for files to exclude. Default: `["node_modules/**", "dist/**", "build/**"]`

**`thresholds.cyclomatic.warning`** (number)
Cyclomatic complexity warning threshold. Default: `10`

**`thresholds.cyclomatic.error`** (number)
Cyclomatic complexity error threshold. Default: `20`

**`countingRules.logicalOperators`** (boolean)
Count `&&` and `||` as decision points (ESLint-aligned). Default: `true`

**`countingRules.nullishCoalescing`** (boolean)
Count `??` as decision point. Default: `true`

**`countingRules.optionalChaining`** (boolean)
Count `?.` as decision point. Default: `true`

**`countingRules.switchCaseMode`** (string: "classic" | "modified")
Classic: +1 per case. Modified: +1 for switch only. Default: `"classic"`

## Exit Codes

| Code | Meaning | When |
|------|---------|------|
| 0 | Success | All functions within thresholds |
| 1 | Analysis errors | Functions exceeded error threshold |
| 2 | Warnings | Functions exceeded warning threshold (with --fail-on warning) |
| 3 | Configuration error | Invalid config file or flags |
| 4 | Parse errors | Syntax errors in analyzed files |

## Examples

See [Examples](examples.md) for real-world usage patterns and CI integration.
```

**Source:** [CLI documentation guidelines](https://clig.dev/), [Astro docs structure](https://docs.astro.build/), [Command-line interface documentation best practices](https://www.infrasity.com/blog/cli-docs-checklist)

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| actions/create-release + actions/upload-release-asset | softprops/action-gh-release or gh CLI | 2021 (actions archived) | Modern action supports glob patterns, retries, draft releases; gh CLI built into runners |
| npm classic tokens (NPM_TOKEN) | Trusted publishing via OIDC | 2023-2024 | Eliminates long-lived tokens, auto-detects CI environment, cryptographically-signed per-workflow |
| Submit to homebrew-core first | Own tap first, homebrew-core later | Established pattern | Homebrew maintainers require proven popularity; own tap is now standard path |
| Automated changelog from commits | Manual curation for milestone releases | Always (but tools pushed auto) | Auto-generated changelogs are noisy; manual curation with Keep a Changelog format produces higher-quality notes |
| Multiple OS runners for cross-compilation | Single runner with Zig cross-compile | Zig maturity (~2022+) | Zig cross-compiles all targets from single Ubuntu runner, eliminating multiple runners/Docker |

**Deprecated/outdated:**

- **actions/create-release**: Archived 2021, uses Node 12. Use softprops/action-gh-release or gh CLI. ([Source](https://github.com/actions/create-release))
- **actions/upload-release-asset**: Archived 2021, uses Node 12. Use softprops/action-gh-release or gh CLI. ([Source](https://github.com/actions/upload-release-asset))
- **npm automation tokens without OIDC**: npm supports OIDC trusted publishing since 2023 — eliminates token exposure risks. ([Source](https://docs.npmjs.com/trusted-publishers/))
- **Docker for Zig cross-compilation**: Unnecessary complexity — Zig cross-compiles natively. ([Source](https://ziglang.org/learn/overview/))

## Open Questions

1. **How to auto-update Homebrew tap formula after GitHub release?**
   - What we know: Can use GitHub Actions in tap repo to watch main repo releases
   - What's unclear: Best pattern — push from main repo to tap repo (requires PAT) or poll from tap repo (workflow_dispatch trigger)?
   - Recommendation: Manual update for 0.1.0, automate in later phase. Homebrew tap updates are low-frequency (milestone releases only).

2. **Should npm platform packages share version with main package or version independently?**
   - What we know: SWC/Prisma/esbuild version all packages together (main + platform packages same version)
   - What's unclear: If platform package binary doesn't change across versions, is it wasteful?
   - Recommendation: Version together — simpler to reason about, matches user expectations, npm storage is cheap.

3. **Does Zig 0.15.2 support deterministic builds for SHA256 stability?**
   - What we know: Zig aims for deterministic builds with ReleaseSafe/ReleaseSmall
   - What's unclear: Whether 0.15.2 achieves byte-for-byte reproducibility on same source
   - Recommendation: Test by building same commit twice, compare SHA256. If non-deterministic, extract checksums from GitHub release artifacts (built once).

4. **Should release workflow upload to npm immediately or require manual npm publish?**
   - What we know: Automated npm publish with OIDC is secure, manual publish provides review gate
   - What's unclear: User preference for control vs automation
   - Recommendation: Automate npm publish in release workflow — manual gate is git tag push (already controlled), extra review step slows milestone releases.

## Sources

### Primary (HIGH confidence)

**Official Documentation:**
- [Keep a Changelog 1.1.0](https://keepachangelog.com/en/1.1.0/) - Changelog format specification
- [Semantic Versioning 2.0.0](https://semver.org/) - Version numbering standard
- [GitHub Actions: workflow_dispatch](https://docs.github.com/actions/managing-workflow-runs/manually-running-a-workflow) - Manual workflow triggers
- [GitHub Actions: Automatically generated release notes](https://docs.github.com/en/repositories/releasing-projects-on-github/automatically-generated-release-notes) - Release automation
- [npm: Trusted publishing](https://docs.npmjs.com/trusted-publishers/) - OIDC authentication for npm
- [npm: package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json/) - Package manifest specification
- [Homebrew: How to Create and Maintain a Tap](https://docs.brew.sh/How-to-Create-and-Maintain-a-Tap) - Tap creation guide
- [Homebrew: Formula Cookbook](https://docs.brew.sh/Formula-Cookbook) - Formula writing patterns
- [Zig: Overview](https://ziglang.org/learn/overview/) - Cross-compilation capabilities
- [Zig: Build System](https://ziglang.org/learn/build-system/) - Build configuration

**Official GitHub Actions:**
- [mlugg/setup-zig](https://github.com/mlugg/setup-zig) - Zig compiler setup for GHA
- [softprops/action-gh-release](https://github.com/softprops/action-gh-release) - Modern GitHub release action

### Secondary (MEDIUM confidence)

**Verified Guides and Tutorials (2026):**
- [How to Implement Matrix Builds in GitHub Actions](https://oneuptime.com/blog/post/2026-01-25-github-actions-matrix-builds/view) - Matrix build patterns
- [How to Implement Workflow Dispatch in GitHub Actions](https://oneuptime.com/blog/post/2026-01-25-github-actions-workflow-dispatch/view) - Manual trigger configuration
- [How to Configure GitHub Actions for Release Automation](https://oneuptime.com/blog/post/2026-02-02-github-actions-release-automation/view) - Release pipeline best practices
- [How to publish binaries on npm (Sentry Engineering)](https://sentry.engineering/blog/publishing-binaries-on-npm) - Platform packages pattern
- [Creating Your First Homebrew Tap: A Complete Guide (2026)](https://kristoffer.dev/blog/guide-to-creating-your-first-homebrew-tap/) - Tap setup walkthrough
- [Zig cross-compilation guide](https://zig.guide/build-system/cross-compilation/) - Target specifications and examples
- [Automate git tag versioning using Bash](https://reemus.dev/tldr/git-tag-versioning-script) - Version bump script pattern
- [Automatic npm publishing with GitHub Actions & npm granular tokens](https://httptoolkit.com/blog/automatic-npm-publish-gha/) - npm OIDC setup

**Community Discussions and Examples:**
- [GitHub: Platform-specific optional dependencies issue #4828](https://github.com/npm/cli/issues/4828) - npm optionalDependencies bug
- [GitHub: Support installing binaries for multiple platforms (SWC)](https://github.com/swc-project/swc/issues/2898) - Platform packages discussion
- [Homebrew tap with bottles uploaded to GitHub Releases](https://brew.sh/2020/11/18/homebrew-tap-with-bottles-uploaded-to-github-releases/) - Bottle distribution pattern

### Tertiary (LOW confidence - needs validation)

**Documentation Style References:**
- [TanStack documentation](https://tanstack.com/) - Progressive disclosure structure (HIGH for pattern, LOW for specific implementation)
- [Astro documentation](https://docs.astro.build/) - Friendly tone and code examples (HIGH for tone, LOW for structure details)
- [Command Line Interface Guidelines](https://clig.dev/) - CLI UX best practices (MEDIUM - community-maintained, well-regarded)
- [The Secret Checklist for Developer-First CLI Docs](https://www.infrasity.com/blog/cli-docs-checklist) - Documentation structure (MEDIUM - 2024 guide, aligns with CLI.dev)

## Metadata

**Confidence breakdown:**

- **Release strategy (Keep a Changelog, SemVer, shell scripts):** HIGH - Official specs, well-established patterns, verified examples
- **Distribution channels (npm platform packages, Homebrew tap, GitHub releases):** HIGH - Official docs, production examples (SWC, Prisma, esbuild), verified patterns
- **CI pipeline (GitHub Actions, matrix builds, workflow_dispatch):** HIGH - Official docs, 2026 tutorials, working examples
- **Documentation structure (progressive disclosure, CLI reference):** MEDIUM - Pattern is proven (TanStack, Astro), but specific implementation requires adaptation
- **Zig cross-compilation details:** MEDIUM-HIGH - Official docs confirm capability, but Zig 0.15.2-specific matrix patterns need validation

**Research date:** 2026-02-15
**Valid until:** ~2026-03-15 (30 days) — GitHub Actions and npm patterns are stable, Zig 0.15.x build system stable, documentation patterns evergreen
