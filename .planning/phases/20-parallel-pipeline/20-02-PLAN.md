---
phase: 20-parallel-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - 20-01
files_modified:
  - rust/src/main.rs
  - README.md
  - docs/getting-started.md
  - docs/cli-reference.md
  - docs/examples.md
autonomous: true
requirements:
  - PIPE-01
  - PIPE-02
  - PIPE-03

must_haves:
  truths:
    - "Running the binary against a directory discovers and analyzes all TS/TSX/JS/JSX files"
    - "Output files are sorted by path regardless of parallel completion order"
    - "Duplication detection runs as a post-parallel step when --duplication flag is set"
    - "Violation counts from analysis results drive the correct exit code"
    - "Default path is '.' when no positional args are provided"
    - "Documentation reflects parallel pipeline capabilities"
  artifacts:
    - path: "rust/src/main.rs"
      provides: "Full end-to-end pipeline wiring replacing placeholder"
      min_lines: 100
    - path: "README.md"
      provides: "Updated documentation noting Rust parallel pipeline"
    - path: "docs/getting-started.md"
      provides: "Getting started guide updated for pipeline"
  key_links:
    - from: "rust/src/main.rs"
      to: "rust/src/pipeline/mod.rs"
      via: "calls discover_files() then analyze_files_parallel()"
      pattern: "pipeline::discover_files|pipeline::analyze_files_parallel"
    - from: "rust/src/main.rs"
      to: "rust/src/metrics/duplication.rs"
      via: "calls detect_duplication() with collected tokens post-parallel"
      pattern: "detect_duplication"
    - from: "rust/src/main.rs"
      to: "rust/src/output/exit_codes.rs"
      via: "counts violations from results, passes to determine_exit_code()"
      pattern: "determine_exit_code.*error_count.*warning_count"
---

<objective>
Wire the pipeline into main.rs, replacing the placeholder stub with real end-to-end file discovery, parallel analysis, duplication detection, violation counting, and correct exit codes.

Purpose: Make the binary functional end-to-end — running `complexity-guard .` should discover files, analyze them in parallel, render output, and return the correct exit code. Also update documentation per project rules.

Output: Working binary that analyzes real files. Updated README.md and docs pages.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-parallel-pipeline/20-RESEARCH.md
@.planning/phases/20-parallel-pipeline/20-01-SUMMARY.md
@rust/src/main.rs
@rust/src/pipeline/mod.rs
@rust/src/output/console.rs
@rust/src/output/exit_codes.rs
@rust/src/metrics/duplication.rs
@rust/src/cli/config.rs
@rust/src/cli/args.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace main.rs placeholder with full pipeline wiring</name>
  <files>rust/src/main.rs</files>
  <action>
Replace the placeholder block in main.rs (lines ~84-155, from `let paths: Vec<String>` through `std::process::exit(exit_code as i32)`) with the real pipeline wiring:

**1. Default paths:**
```rust
let input_paths: Vec<std::path::PathBuf> = if args.paths.is_empty() {
    vec![std::path::PathBuf::from(".")]
} else {
    args.paths.clone()
};
```

**2. Extract include/exclude patterns from merged config:**
```rust
let include_patterns: Vec<String> = config.files.as_ref()
    .and_then(|f| f.include.clone())
    .unwrap_or_default();
let exclude_patterns: Vec<String> = config.files.as_ref()
    .and_then(|f| f.exclude.clone())
    .unwrap_or_default();
// Also append CLI --exclude patterns (already merged into config.files by merge_args_into_config)
```

**3. Discover files:**
```rust
let discovered = match complexity_guard::pipeline::discover_files(
    &input_paths, &include_patterns, &exclude_patterns,
) {
    Ok(files) => files,
    Err(e) => {
        eprintln!("Error discovering files: {}", e);
        std::process::exit(ExitCode::ConfigError as i32);
    }
};
```

**4. Build AnalysisConfig from resolved config:**
Create `AnalysisConfig` from `resolved` — map resolved threshold values to AnalysisConfig fields. The existing `AnalysisConfig::default()` is close; override `cyclomatic.warning_threshold`, `cyclomatic.error_threshold`, `cognitive.warning_threshold`, `cognitive.error_threshold` from resolved values. For scoring weights, check if `config.weights` has values and construct ScoringWeights accordingly.

**5. Parallel analysis:**
```rust
let start = std::time::Instant::now();
let analysis_config = build_analysis_config(&config, &resolved);
let (mut files, has_parse_errors) = complexity_guard::pipeline::analyze_files_parallel(
    &discovered, &analysis_config, resolved.threads,
);
let elapsed_ms = start.elapsed().as_millis() as u64;
```

Add a helper function `build_analysis_config(config: &Config, resolved: &ResolvedConfig) -> AnalysisConfig` that maps config/resolved values into the AnalysisConfig struct. Use defaults where values are not specified.

**6. Duplication detection (post-parallel, gated by flag):**
```rust
let duplication_result: Option<DuplicationResult> = {
    let dup_enabled = config.analysis.as_ref()
        .and_then(|a| a.duplication_enabled)
        .unwrap_or(false);
    let no_dup = config.analysis.as_ref()
        .and_then(|a| a.no_duplication)
        .unwrap_or(false);

    if dup_enabled && !no_dup {
        let file_tokens: Vec<Vec<Token>> = files.iter()
            .enumerate()
            .map(|(i, f)| {
                f.tokens.iter().map(|t| Token {
                    kind: t.kind.clone(),
                    start_byte: t.start_byte,
                    end_byte: t.end_byte,
                    file_index: i,
                }).collect()
            })
            .collect();
        Some(complexity_guard::metrics::duplication::detect_duplication(
            &file_tokens, &analysis_config.duplication,
        ))
    } else {
        None
    }
};
```

**7. Count violations for exit code:**
Use `function_violations()` from output::console (already pub) to count warnings and errors:
```rust
use complexity_guard::output::console::{function_violations, Severity};

let (mut error_count, mut warning_count): (u32, u32) = (0, 0);
for file in &files {
    for func in &file.functions {
        let violations = function_violations(func, &resolved);
        for v in &violations {
            match v.severity {
                Severity::Error => error_count += 1,
                Severity::Warning => warning_count += 1,
            }
        }
    }
}
```

**8. Render output:**
Keep the existing match on `resolved.format` but pass `duplication_result.as_ref()` instead of `None` to all renderers. Remove the `paths` variable and the `analyze_paths` message — the console renderer handles its own output. Keep the version/analyzing message only in verbose mode.

**9. Exit code:**
```rust
let exit_code = determine_exit_code(
    has_parse_errors,
    error_count,
    warning_count,
    args.fail_on.as_deref(),
    false, // baseline enforcement deferred
);
std::process::exit(exit_code as i32);
```

Add necessary imports at top of main.rs:
- `use complexity_guard::types::{AnalysisConfig, DuplicationResult, Token};`
- `use complexity_guard::output::console::{function_violations, Severity};`
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo build 2>&1 | tail -5 && cargo run -- ../tests/fixtures/typescript/simple_function.ts 2>&1 | head -20</automated>
  </verify>
  <done>Binary compiles and produces real analysis output when run against fixture files. Exit code reflects actual violations. Duplication runs when --duplication flag is set. Default path "." works when no args provided.</done>
</task>

<task type="auto">
  <name>Task 2: Update README.md and docs pages for parallel pipeline</name>
  <files>
    README.md
    docs/getting-started.md
    docs/cli-reference.md
    docs/examples.md
  </files>
  <action>
Update documentation to reflect the Rust binary now has a working parallel pipeline. These are minimal updates (Rust binary not yet shipped — full rewrite deferred to Phase 22 per previous decisions).

**README.md:**
- In the Rust rewrite notes section (added in Phase 19), update to note Phase 20 (Parallel Pipeline) is complete — the binary now discovers files, analyzes them in parallel using rayon, and produces sorted deterministic output.
- No changes to the main feature list (already mentions parallel analysis from Zig v1.0).

**docs/getting-started.md:**
- Add a brief note in the Rust rewrite section (if present) that the Rust binary can now analyze directories end-to-end.

**docs/cli-reference.md:**
- Add a note that `--threads`, `--include`, `--exclude` flags are functional in the Rust binary.

**docs/examples.md:**
- Add a note that the Rust binary now supports directory analysis examples.

Keep changes minimal — full documentation rewrite is Phase 22. Do NOT update publication READMEs (deferred to Phase 22 per prior decision).
  </action>
  <verify>
    <automated>grep -c "Phase 20\|parallel pipeline\|rayon" README.md docs/getting-started.md docs/cli-reference.md docs/examples.md 2>/dev/null</automated>
    <manual>Verify docs mention Phase 20 parallel pipeline completion</manual>
  </verify>
  <done>README.md and docs pages updated with Phase 20 parallel pipeline notes. Publication READMEs intentionally not updated (deferred to Phase 22).</done>
</task>

</tasks>

<verification>
```bash
# Build and run against fixtures
cd /Users/benvds/code/complexity-guard/rust && cargo build 2>&1 | tail -3
cd /Users/benvds/code/complexity-guard/rust && cargo run -- ../tests/fixtures/typescript/ 2>&1 | head -40
cd /Users/benvds/code/complexity-guard/rust && cargo run -- ../tests/fixtures/typescript/simple_function.ts -f json 2>&1 | head -20

# Verify deterministic output
cd /Users/benvds/code/complexity-guard/rust && diff <(cargo run -- ../tests/fixtures/typescript/ -f json 2>/dev/null) <(cargo run -- ../tests/fixtures/typescript/ -f json 2>/dev/null)

# Verify exit code behavior
cd /Users/benvds/code/complexity-guard/rust && cargo run -- ../tests/fixtures/typescript/ --fail-on warning; echo "Exit: $?"

# All existing tests still pass
cd /Users/benvds/code/complexity-guard/rust && cargo test 2>&1 | tail -5
```
</verification>

<success_criteria>
- Binary analyzes real files when pointed at a directory or file path
- Output is deterministic across multiple runs
- Exit code reflects actual violation counts
- Duplication detection works when --duplication flag is passed
- All existing tests continue to pass
- Documentation updated per CLAUDE.md GSD workflow rules
</success_criteria>

<output>
After completion, create `.planning/phases/20-parallel-pipeline/20-02-SUMMARY.md`
</output>
