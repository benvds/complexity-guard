---
phase: 08-composite-health-score
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
requirements: [COMP-01, COMP-02, COMP-03, COMP-04]
files_modified:
  - src/cli/config.zig
  - src/main.zig
  - src/output/console.zig
  - src/output/json_output.zig
  - src/output/exit_codes.zig
  - src/metrics/cyclomatic.zig
autonomous: true

must_haves:
  truths:
    - "Tool computes health score per function and attaches to ThresholdResult"
    - "Console output shows color-coded 'Health: N' line in project summary"
    - "JSON output includes health_score (f64) per function and in summary"
    - "JSON output includes score breakdown per function showing weighted metric contributions"
    - "Score is always computed (not gated by --metrics flag)"
    - "Config baseline field is parsed from .complexityguard.json"
    - "No letter grades appear anywhere in output (COMP-04 override)"
    - "health_score placeholder in FunctionOutput changed from ?f64 to f64"
  artifacts:
    - path: "src/metrics/cyclomatic.zig"
      provides: "ThresholdResult with health_score field"
      contains: "health_score: f64"
    - path: "src/cli/config.zig"
      provides: "Config with baseline field"
      contains: "baseline: ?f64"
    - path: "src/main.zig"
      provides: "Score computation wired after all metric passes"
      contains: "scoring.computeFunctionScore"
    - path: "src/output/console.zig"
      provides: "Health score display in summary"
      contains: "Health:"
    - path: "src/output/json_output.zig"
      provides: "health_score populated in FunctionOutput and Summary"
      contains: "health_score: f64"
    - path: "src/output/exit_codes.zig"
      provides: "Baseline check in exit code determination"
      contains: "baseline_failed"
  key_links:
    - from: "src/main.zig"
      to: "src/metrics/scoring.zig"
      via: "calls computeFunctionScore for each ThresholdResult"
      pattern: "scoring\\.computeFunctionScore"
    - from: "src/main.zig"
      to: "src/output/console.zig"
      via: "passes project_score to formatSummary"
      pattern: "project_score"
    - from: "src/main.zig"
      to: "src/output/json_output.zig"
      via: "passes project_score to buildJsonOutput"
      pattern: "project_score"
    - from: "src/output/exit_codes.zig"
      to: "baseline comparison"
      via: "determineExitCode checks baseline_failed"
      pattern: "baseline_failed"
---

<objective>
Wire the scoring module into the full pipeline: config changes, main.zig integration, console display, JSON output, and exit code baseline check.

Purpose: This connects the pure scoring math (Plan 01) to every touchpoint in the tool. After this plan, running `complexity-guard` on any codebase will compute and display health scores.

Output: All pipeline files updated. Score flows from metrics -> scoring -> output. Baseline ratchet works via exit code.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-composite-health-score/08-CONTEXT.md
@.planning/phases/08-composite-health-score/08-RESEARCH.md
@.planning/phases/08-composite-health-score/08-01-SUMMARY.md
@src/metrics/scoring.zig (from Plan 01)
@src/metrics/cyclomatic.zig (ThresholdResult struct)
@src/cli/config.zig (Config, WeightsConfig, defaults)
@src/main.zig (full pipeline)
@src/output/console.zig (formatSummary, OutputConfig, AnsiCode)
@src/output/json_output.zig (JsonOutput, FunctionOutput, Summary, buildJsonOutput)
@src/output/exit_codes.zig (ExitCode, determineExitCode)
@src/cli/args.zig (CliArgs — fail_health_below, baseline fields)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config + ThresholdResult + exit code changes</name>
  <files>src/cli/config.zig, src/metrics/cyclomatic.zig, src/output/exit_codes.zig</files>
  <action>
    **config.zig changes:**
    1. Add `baseline: ?f64 = null` field to Config struct (after `overrides`).
    2. In `defaults()`, ensure baseline stays null (no default baseline).
    3. This field is parsed automatically by std.json.parseFromSlice since Config uses optional fields. Verify the JSON parser won't reject an unknown `baseline` key — check if `ignore_unknown_fields` is set. If not, the field being present in the struct suffices.

    **cyclomatic.zig changes:**
    1. Add `health_score: f64 = 0.0` field to ThresholdResult struct (after nesting_depth_status). This follows the pattern of halstead/structural fields added in Phase 7.
    2. No other changes needed — existing tests use struct literals with defaults, so adding a defaulted field is backward compatible.

    **exit_codes.zig changes:**
    1. Add `baseline_failed` variant to ExitCode enum with value 1 (same as errors_found — both are exit code 1). Actually, per CONTEXT.md, baseline failure causes exit code 1. Since `errors_found` is already exit code 1, we don't need a separate enum value. Instead, modify `determineExitCode` to accept a new `baseline_failed: bool` parameter.
    2. Update `determineExitCode` signature: add `baseline_failed: bool` parameter.
    3. Add baseline check in priority order: parse_error > baseline_failed > errors_found > warnings_found > success. Baseline failure should be priority 2 (before individual metric errors, after parse errors). This means if baseline fails, exit 1 regardless of individual function violations.
    4. Update ALL existing tests for `determineExitCode` to pass `false` for the new `baseline_failed` parameter (backward compatible — no behavior change when false).
    5. Add new test: `determineExitCode(false, 0, 0, false, true)` returns `.errors_found` (exit code 1).
    6. Add new test: baseline_failed + parse_error: parse_error wins priority.
  </action>
  <verify>`zig build test` — all existing exit_codes tests pass with updated signatures, new baseline tests pass, config and ThresholdResult changes compile.</verify>
  <done>Config has baseline field. ThresholdResult has health_score field. determineExitCode supports baseline_failed parameter. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Main pipeline + console + JSON output wiring</name>
  <files>src/main.zig, src/output/console.zig, src/output/json_output.zig</files>
  <action>
    **main.zig wiring:**
    1. Import scoring module: `const scoring = @import("metrics/scoring.zig");`
    2. After all four metric analysis passes (cyclomatic, cognitive, halstead, structural) are merged into cycl_results, add scoring pass. For each file's results:
       a. Build MetricThresholds from the config objects (cycl_config, cog_config, hal_config, str_config). Map threshold fields to MetricThresholds struct.
       b. Call `scoring.resolveEffectiveWeights(cfg.weights)` once before the file loop.
       c. For each ThresholdResult in cycl_results: call `scoring.computeFunctionScore(tr.*, weights, thresholds)` and set `tr.health_score = breakdown.total` (or whatever field holds the final score).
    3. After computing per-function scores, compute file scores and project score:
       a. Track file_scores and function_counts using ArrayLists.
       b. For each file: collect function health_scores into a temp slice, call `scoring.computeFileScore(scores)`.
       c. After all files: call `scoring.computeProjectScore(file_scores, function_counts)`.
    4. Pass `project_score` to both console formatSummary and json_output buildJsonOutput.
    5. Handle baseline check: after computing project_score, check `cfg.baseline`. Also check `cli_args.fail_health_below` (parsed as ?[]const u8, needs std.fmt.parseFloat to convert). If either baseline exists and project_score < baseline - 0.5, set `baseline_failed = true`.
    6. Pass `baseline_failed` to `determineExitCode` call.
    7. If baseline failed, print message to stderr: `"Health score {d:.1} is below baseline {d:.1}\n"`.
    8. Score computation must NOT be gated by --metrics flag — it always runs using all available metric data.

    **console.zig changes:**
    1. Update `formatSummary` signature to accept `project_score: f64` parameter.
    2. After the "Analyzed N files, N functions" line, add health score display:
       - Format: `"Health: {d:.0}\n"` (rounds to integer per CONTEXT.md "Health: 73")
       - Color-coded: green if score >= 80, yellow if score >= 50, red if score < 50.
       - Use existing AnsiCode.green/yellow/red and config.use_color check.
    3. No per-file score display in console (scores appear in JSON; console shows project summary only).

    **json_output.zig changes:**
    1. Change `FunctionOutput.health_score` from `?f64` to `f64` (always populated after Phase 8).
    2. Add `score_breakdown` field to FunctionOutput: struct with `cyclomatic_sub_score: f64`, `cognitive_sub_score: f64`, `halstead_sub_score: f64`, `structural_sub_score: f64`, `effective_weights` sub-object. Use a `ScoreBreakdownOutput` struct matching the scoring.ScoreBreakdown fields. Make this `?ScoreBreakdownOutput = null` — only populated when --verbose or in JSON mode.
    3. Add `health_score: f64` to Summary struct.
    4. Update `buildJsonOutput` signature to accept `project_score: f64` and set it in summary.
    5. Update FunctionOutput population in buildJsonOutput: set `health_score` from `result.health_score` instead of `null`.
    6. Update all existing tests that construct FunctionOutput or call buildJsonOutput — add the new health_score parameter where needed.

    **Important:** Do NOT add letter grades anywhere. COMP-04 is overridden: numeric score only.
  </action>
  <verify>`zig build test` — all tests pass. `zig build run -- --format json tests/fixtures/` produces JSON with `health_score` values in function output and summary. Console output shows `Health: NN` line.</verify>
  <done>Running the tool on any codebase shows health scores. JSON has health_score per function and in summary. Console shows color-coded health line. Baseline ratchet exits 1 when score drops below baseline. No letter grades anywhere.</done>
</task>

</tasks>

<verification>
1. `zig build test` — all tests pass (no regressions)
2. `zig build run -- tests/fixtures/` — console shows "Health: NN" line in summary (color-coded)
3. `zig build run -- --format json tests/fixtures/` — JSON output has:
   - `summary.health_score` as a number (not null)
   - Each function has `health_score` as a number (not null)
4. Score is between 0-100
5. No letter grades in any output
6. `zig build run -- --format json tests/fixtures/ 2>&1 | grep -i grade` — no results
</verification>

<success_criteria>
- Health score computed for every function, file, and project
- Console summary shows "Health: NN" with color coding (green/yellow/red)
- JSON output has health_score (f64, not null) in both summary and per-function
- Baseline comparison works: score below baseline exits 1
- Score always computed regardless of --metrics flag
- All existing tests pass with no regressions
- No letter grades appear in output
</success_criteria>

<output>
After completion, create `.planning/phases/08-composite-health-score/08-02-SUMMARY.md`
</output>
