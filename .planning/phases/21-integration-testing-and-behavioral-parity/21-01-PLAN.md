---
phase: 21-integration-testing-and-behavioral-parity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rust/src/cli/config.rs
  - rust/src/metrics/cognitive.rs
  - rust/src/output/json_output.rs
  - rust/src/types.rs
autonomous: true
requirements:
  - METR-02
  - METR-03
  - METR-05
  - METR-06
  - OUT-02

must_haves:
  truths:
    - "Health scores match Zig v1.0 output within float tolerance for all fixtures"
    - "Cognitive complexity for async_patterns.ts fetchUserData returns 15 (matching Zig)"
    - "JSON duplication output uses Zig schema with enabled, project_duplication_pct, project_status, clone_groups with locations, and per-file array"
  artifacts:
    - path: "rust/src/cli/config.rs"
      provides: "Corrected cognitive_error default of 25 in ResolvedConfig"
      contains: "cognitive_error: 25"
    - path: "rust/src/metrics/cognitive.rs"
      provides: "Fixed arrow callback visitor using visitNode-equivalent for body"
      contains: "visit_node_cognitive"
    - path: "rust/src/output/json_output.rs"
      provides: "Duplication JSON matching Zig schema"
      contains: "project_duplication_pct"
    - path: "rust/src/types.rs"
      provides: "Updated duplication types with per-file info and clone locations"
      contains: "DuplicationFileInfo"
  key_links:
    - from: "rust/src/cli/config.rs"
      to: "rust/src/main.rs"
      via: "build_analysis_config uses resolved.cognitive_error for scoring_thresholds"
      pattern: "cognitive_error.*25"
    - from: "rust/src/metrics/cognitive.rs"
      to: "rust/src/pipeline/parallel.rs"
      via: "analyze_file calls cognitive::analyze_functions"
      pattern: "cognitive::analyze_functions"
---

<objective>
Fix confirmed metric and data bugs that cause Rust output to diverge from Zig v1.0 baseline.

Purpose: Three bugs produce incorrect values that would cause all integration tests to fail: (1) health score threshold default mismatch, (2) cognitive complexity over-counting arrow callbacks in async patterns, (3) duplication JSON schema completely different from Zig. Fixing these first enables Plan 03 to record correct baselines.

Output: All metric values and JSON schema fields match Zig v1.0 output. Existing unit tests still pass. New unit tests pin the corrected values.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-integration-testing-and-behavioral-parity/21-RESEARCH.md
@rust/src/cli/config.rs
@rust/src/metrics/cognitive.rs
@rust/src/output/json_output.rs
@rust/src/types.rs
@rust/src/main.rs
@src/metrics/cognitive.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix health score threshold default and cognitive complexity arrow callback bug</name>
  <files>
    rust/src/cli/config.rs
    rust/src/metrics/cognitive.rs
  </files>
  <action>
**Bug 1 — Health score threshold default (one-line fix):**

In `rust/src/cli/config.rs`, `ResolvedConfig::default()`, change `cognitive_error: 30` to `cognitive_error: 25`. This makes the scoring sigmoid use the same k-value as Zig (k = ln(4)/(25-15) = 0.1386), producing matching health scores.

**Bug 2 — Cognitive complexity async_patterns.ts over-counting (root cause fix):**

The Rust `visit_arrow_callback()` in `rust/src/metrics/cognitive.rs` calls `visit_node_with_arrows()` for the arrow body children. This means nested arrow functions inside a callback are treated as ADDITIONAL callbacks (structural increments). The Zig `visitArrowCallback()` calls `visitNode()` (NOT `visitNodeWithArrows()`), which treats nested arrows as scope boundaries (stops traversal).

Fix: In `visit_arrow_callback()`, when visiting children of the arrow body:
- For `statement_block` children: iterate child statements and call a NEW function `visit_node_cognitive()` (equivalent to Zig's `visitNode()`) that does NOT have arrow-callback awareness — it treats arrow_function nodes as scope boundaries and stops.
- For expression body arrows: also call `visit_node_cognitive()` instead of `visit_node_with_arrows()`.

Create `visit_node_cognitive()` as a copy of the structural/control flow logic from `visit_node_with_arrows()` but where `arrow_function` nodes are handled by `is_function_node()` check (stop traversal). Specifically:
- `visit_node_cognitive()` checks `is_function_node(kind)` at the top and returns (stops) for ALL function nodes including arrow_function
- It has the same if/else/for/while/switch/ternary/catch/binary_expression/call_expression/break/continue logic
- It recurses with `visit_node_cognitive()` (not `visit_node_with_arrows()`)

Update the existing `visit_arrow_callback()` to call `visit_node_cognitive()` for body children instead of `visit_node_with_arrows()`.

The `visit_node_with_arrows()` function remains unchanged — it is used for the top-level function body traversal where arrows ARE callbacks.

Add a unit test for async_patterns.ts fixture pinning `fetchUserData` cognitive complexity to 15.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test --lib -- cognitive --test-threads=1</automated>
    <manual>Verify async_patterns.ts fetchUserData = 15 (was 18)</manual>
  </verify>
  <done>cognitive_error default is 25; async_patterns.ts fetchUserData cognitive complexity returns 15; all existing cognitive tests pass</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite duplication JSON output to match Zig schema</name>
  <files>
    rust/src/types.rs
    rust/src/output/json_output.rs
    rust/src/main.rs
  </files>
  <action>
The Zig duplication JSON schema is:
```json
{
  "duplication": {
    "enabled": true,
    "project_duplication_pct": 81.99,
    "project_status": "error",
    "clone_groups": [{"token_count": 25, "locations": [{"file": "path", "start_line": 1, "end_line": 10}]}],
    "files": [{"path": "...", "total_tokens": 211, "cloned_tokens": 173, "duplication_pct": 81.99, "status": "error"}]
  }
}
```

The current Rust schema uses `total_tokens`, `cloned_tokens`, `duplication_percentage` at the top level with `clone_groups.instances` instead of `clone_groups.locations`.

**Changes needed:**

1. In `rust/src/output/json_output.rs`, replace `JsonDuplicationOutput` with a struct matching Zig schema exactly:
   - `enabled: bool`
   - `project_duplication_pct: f64`
   - `project_status: String` (compute from duplication thresholds — "ok", "warning", "error")
   - `clone_groups: Vec<JsonCloneGroup>` where each has `token_count: u32` and `locations: Vec<JsonCloneLocation>` with `file: String`, `start_line: usize`, `end_line: usize`
   - `files: Vec<JsonDuplicationFileInfo>` where each has `path: String`, `total_tokens: usize`, `cloned_tokens: usize`, `duplication_pct: f64`, `status: String`

2. In `render_json()`, update the duplication mapping to populate these new structs. The `render_json` function already receives `files: &[FileAnalysisResult]` and `duplication: Option<&DuplicationResult>` — use file paths from `files` and clone group data from `duplication`.

3. Add necessary intermediate types: `JsonCloneGroup`, `JsonCloneLocation`, `JsonDuplicationFileInfo`.

4. For `project_status` and per-file `status`: use hardcoded default thresholds (file_warning: 3.0, file_error: 5.0, project_warning: 3.0, project_error: 5.0) matching Zig defaults, since ResolvedConfig doesn't currently carry duplication thresholds. Status logic: value >= error_threshold → "error", value >= warning_threshold → "warning", else "ok".

5. For clone group `locations`: map from `CloneInstance` which has `file_index`, `start_line`, `end_line` — use `files[instance.file_index].path` for the file path string.

6. For per-file duplication stats: iterate files, count tokens and cloned tokens per file from the DuplicationResult clone groups. If this is too complex, compute per-file stats from the existing `FileAnalysisResult.tokens` array and clone group instances.

7. Update existing json_output tests to reflect new duplication schema field names.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test --lib -- json_output --test-threads=1</automated>
    <manual>Run binary with --format json --duplication on a fixture directory and verify duplication field has enabled, project_duplication_pct, project_status, clone_groups with locations, files array</manual>
  </verify>
  <done>JSON duplication output matches Zig schema (enabled, project_duplication_pct, project_status, clone_groups.locations, files array); existing JSON tests pass with updated assertions</done>
</task>

</tasks>

<verification>
1. `cd /Users/benvds/code/complexity-guard/rust && cargo test` — all unit tests pass
2. `cd /Users/benvds/code/complexity-guard/rust && cargo build --release` — binary builds
3. Run: `./rust/target/release/complexity-guard --format json tests/fixtures/typescript/async_patterns.ts` — verify fetchUserData cognitive=15
4. Run: `./rust/target/release/complexity-guard --format json tests/fixtures/typescript/simple_function.ts` — verify health_score is closer to Zig's 82.71 (not 79.38)
</verification>

<success_criteria>
- cognitive_error default changed from 30 to 25 in ResolvedConfig
- fetchUserData cognitive complexity is 15 (was 18)
- All existing unit tests pass
- JSON duplication schema matches Zig field names and structure
- Health scores are within 1e-6 tolerance of Zig values
</success_criteria>

<output>
After completion, create `.planning/phases/21-integration-testing-and-behavioral-parity/21-01-SUMMARY.md`
</output>
