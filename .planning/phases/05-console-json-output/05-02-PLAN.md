---
phase: 05-console-json-output
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/output/json_output.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tool outputs valid JSON with version, timestamp, summary, and files sections"
    - "JSON includes per-function metrics with threshold status"
    - "JSON uses camelCase field naming and includes null for uncomputed metrics"
    - "Tool exits with appropriate codes (0=pass, 1=errors, 2=warnings, 4=parse errors)"
    - "main.zig uses --format flag to select console vs json output"
    - "main.zig uses --verbose and --quiet flags for verbosity control"
    - "Double-analysis pattern eliminated - analyze once, format from stored results"
  artifacts:
    - path: "src/output/json_output.zig"
      provides: "JSON output envelope with metadata, summary, and per-file results"
      contains: "JsonOutput"
    - path: "src/main.zig"
      provides: "Restructured pipeline with format selection, verbosity modes, exit codes"
      contains: "output_mod"
  key_links:
    - from: "src/output/json_output.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "ThresholdResult for per-function data"
      pattern: "cyclomatic\\.ThresholdResult"
    - from: "src/output/json_output.zig"
      to: "src/core/json.zig"
      via: "serializeResultPretty for JSON serialization"
      pattern: "json_mod\\.serializeResultPretty"
    - from: "src/main.zig"
      to: "src/output/console.zig"
      via: "Console formatting in default output path"
      pattern: "console\\.format"
    - from: "src/main.zig"
      to: "src/output/json_output.zig"
      via: "JSON formatting when --format json"
      pattern: "json_output\\.buildAndSerialize"
    - from: "src/main.zig"
      to: "src/output/exit_codes.zig"
      via: "Exit code at end of pipeline"
      pattern: "exit_codes\\.determineExitCode"
---

<objective>
Create JSON output format and restructure main.zig to integrate all output modules.

Purpose: Complete the Phase 5 output layer by adding machine-readable JSON output for CI pipelines and restructuring main.zig to use the output modules from Plan 01 (console formatter, exit codes) plus the new JSON formatter. Eliminates the double-analysis pattern by storing results once and formatting from stored data.

Output: New `src/output/json_output.zig` module and fully restructured `src/main.zig` with format selection, verbosity modes, and exit codes.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-console-json-output/05-RESEARCH.md
@.planning/phases/05-console-json-output/05-CONTEXT.md
@.planning/phases/05-console-json-output/05-01-SUMMARY.md
@src/output/console.zig
@src/output/exit_codes.zig
@src/metrics/cyclomatic.zig
@src/core/types.zig
@src/core/json.zig
@src/cli/args.zig
@src/cli/help.zig
@src/main.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON output module</name>
  <files>src/output/json_output.zig, src/main.zig</files>
  <action>
Create `src/output/json_output.zig` with JSON output envelope generation.

Per CONTEXT.md and RESEARCH.md decisions:
- camelCase field naming (matches JavaScript convention, ESLint JSON output)
- Explicit null for uncomputed metrics (forward compatibility)
- Version + timestamp metadata envelope
- Summary with aggregated counts

**Types for JSON output (using Zig struct serialization):**

Since std.json.Stringify serializes Zig struct fields using their Zig names (snake_case), and the user decision requires camelCase in JSON, we need to use `pub const json_field_names` or custom serialization.

Zig 0.15.2's std.json supports field name customization via `pub const @"jsonStringify"` or field renaming. Check if std.json.Stringify respects Zig's snake_case field names as-is. If so, use snake_case field names in the struct (matching existing core/types.zig convention) since the existing codebase already uses snake_case in JSON (see core/json.zig tests: `"start_line"`, `"function_count"`). This maintains consistency.

**Decision: Use snake_case field names in JSON** to match existing codebase convention (core/types.zig, core/json.zig). The camelCase suggestion from research is overridden by codebase consistency. All existing JSON output uses snake_case (`start_line`, `function_count`, `files_analyzed`).

**JsonOutput struct:**
```
pub const JsonOutput = struct {
    version: []const u8,          // "1.0.0"
    timestamp: i64,                // Unix timestamp (seconds)
    summary: Summary,
    files: []const FileOutput,

    pub const Summary = struct {
        files_analyzed: u32,
        total_functions: u32,
        warnings: u32,
        errors: u32,
        status: []const u8,       // "pass", "warning", "error"
    };

    pub const FileOutput = struct {
        path: []const u8,
        functions: []const FunctionOutput,
    };

    pub const FunctionOutput = struct {
        name: []const u8,
        start_line: u32,
        end_line: u32,
        start_col: u32,
        cyclomatic: ?u32,
        cognitive: ?u32,           // null - Phase 6
        halstead_volume: ?f64,     // null - Phase 7
        halstead_difficulty: ?f64, // null - Phase 7
        halstead_effort: ?f64,     // null - Phase 7
        nesting_depth: u32,
        line_count: u32,
        params_count: u32,
        health_score: ?f64,        // null - Phase 8
        status: []const u8,        // "ok", "warning", "error"
    };
};
```

**buildJsonOutput function:**
```
pub fn buildJsonOutput(
    allocator: Allocator,
    file_results: []const console.FileThresholdResults,
    warning_count: u32,
    error_count: u32,
) !JsonOutput
```

- Sets `version` to "1.0.0"
- Sets `timestamp` to `std.time.timestamp()` (seconds since Unix epoch)
- Computes summary from counts
- Converts FileThresholdResults to FileOutput/FunctionOutput arrays
- Status: "error" if errors > 0, "warning" if warnings > 0, "pass" otherwise
- For each ThresholdResult, populate FunctionOutput with available data (cyclomatic from complexity field, all other metrics null, structural fields as 0 matching current toFunctionResults pattern)

**serializeJsonOutput function:**
```
pub fn serializeJsonOutput(
    allocator: Allocator,
    output: JsonOutput,
) ![]u8
```

Uses `std.json.Stringify.valueAlloc(allocator, output, .{ .whitespace = .indent_2 })` for pretty-printed JSON.

**Tests (below `// TESTS` comment):**
- buildJsonOutput produces correct version and status fields
- buildJsonOutput counts warnings/errors in summary correctly
- buildJsonOutput converts file/function data correctly
- serializeJsonOutput produces valid JSON (parse it back with std.json.parseFromSlice)
- JSON includes null fields for uncomputed metrics (cognitive, halstead, health_score)
- Empty results produce valid JSON with zero counts and "pass" status

Add test import in main.zig test block: `_ = @import("output/json_output.zig");`

Import console module: `const console = @import("console.zig");` (for FileThresholdResults type)
Import cyclomatic: `const cyclomatic = @import("../metrics/cyclomatic.zig");`
Import json_mod: `const json_mod = @import("../core/json.zig");` (or use std.json directly)
  </action>
  <verify>`zig build test` passes with all JSON output tests green</verify>
  <done>JSON output module produces valid, pretty-printed JSON with version, timestamp, summary, per-file/per-function results, null for uncomputed metrics, all tests passing</done>
</task>

<task type="auto">
  <name>Task 2: Restructure main.zig pipeline with output integration</name>
  <files>src/main.zig</files>
  <action>
Restructure main.zig to replace the current ad-hoc output with the new output modules. This eliminates the double-analysis pattern noted in Phase 4 summary.

**Imports to add:**
```
const console = @import("output/console.zig");
const json_output = @import("output/json_output.zig");
const exit_codes = @import("output/exit_codes.zig");
```

**Pipeline restructure after parsing (replace everything from "// Run cyclomatic complexity analysis" through end of main):**

Step 1 - Analyze all files once and store results:
```
var file_results_list = std.ArrayList(console.FileThresholdResults).empty;
defer file_results_list.deinit(arena_allocator);

var total_warnings: u32 = 0;
var total_errors: u32 = 0;
var total_functions: u32 = 0;

for (parse_summary.results) |result| {
    const threshold_results = try cyclomatic.analyzeFile(
        arena_allocator, result, cycl_config,
    );

    total_functions += @intCast(threshold_results.len);

    const violations = exit_codes.countViolations(threshold_results);
    total_warnings += violations.warnings;
    total_errors += violations.errors;

    try file_results_list.append(arena_allocator, console.FileThresholdResults{
        .path = result.path,
        .results = threshold_results,
    });
}

const file_results = file_results_list.items;
```

Step 2 - Determine output format from config:
```
const format = if (cfg.output) |out| (out.format orelse "console") else "console";
```

Also check `cli_args.format` override (it takes priority from merge.zig):
```
const effective_format = cli_args.format orelse (if (cfg.output) |out| (out.format orelse "console") else "console");
```

Step 3 - Determine verbosity:
```
const verbosity: console.Verbosity = if (cli_args.quiet)
    .quiet
else if (cli_args.verbose)
    .verbose
else
    .default;
```

Step 4 - Determine color:
```
const use_color = help.shouldUseColor(cli_args.color, cli_args.no_color);
```

Step 5 - Output based on format:

**If format is "json":**
```
const json_result = try json_output.buildJsonOutput(
    arena_allocator, file_results, total_warnings, total_errors,
);
const json_str = try json_output.serializeJsonOutput(arena_allocator, json_result);
defer arena_allocator.free(json_str);
try stdout.writeAll(json_str);
try stdout.writeAll("\n");
```

If `cli_args.output_file` is set, also write to file (use std.fs.cwd().createFile, write, close).

**If format is "console" (default):**
```
const output_config = console.OutputConfig{
    .use_color = use_color,
    .verbosity = verbosity,
};

// Display per-file results
for (file_results) |fr| {
    _ = try console.formatFileResults(
        stdout, arena_allocator, fr.path, fr.results, output_config,
    );
}

// Display summary (unless quiet mode handles it internally)
try console.formatSummary(
    stdout, arena_allocator,
    @intCast(parse_summary.results.len),
    total_functions,
    total_warnings, total_errors,
    file_results, output_config,
);
```

Step 6 - Determine and apply exit code:
```
const fail_on_warnings = if (cli_args.fail_on) |fo|
    std.mem.eql(u8, fo, "warning")
else if (cfg.analysis) |analysis|
    false  // Could check config fail_on field if it exists
else
    false;

const exit_code = exit_codes.determineExitCode(
    parse_summary.failed_parses > 0,
    total_errors,
    total_warnings,
    fail_on_warnings,
);

if (exit_code != .success) {
    stdout.flush() catch {};
    std.process.exit(exit_code.toInt());
}
```

**Remove** the old output code (lines ~129-218 in current main.zig) -- the `// Print summary` section and `// Print detailed results if verbose` section are entirely replaced by the new output pipeline.

**Keep** the config error handling with `std.process.exit(3)` that already exists in main.zig (config_error exit code).

**Test block update** - ensure all output modules are imported:
```
_ = @import("output/exit_codes.zig");
_ = @import("output/console.zig");
_ = @import("output/json_output.zig");
```
  </action>
  <verify>
1. `zig build test` -- all tests pass
2. `zig build` -- compiles without errors
3. `zig build run -- --help` -- still works
4. `zig build run -- tests/fixtures/` -- shows ESLint-style console output
5. `zig build run -- --format json tests/fixtures/` -- shows JSON output
6. `zig build run -- --verbose tests/fixtures/` -- shows all functions
7. `zig build run -- --quiet tests/fixtures/` -- shows only errors
  </verify>
  <done>
main.zig restructured: single analysis pass, format selection (console/json), verbosity modes (default/verbose/quiet), color support, exit codes (0-4), file output support. Double-analysis pattern eliminated. All existing and new tests pass.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` -- all tests pass (existing + new)
2. `zig build` -- project compiles without errors
3. Run with console output (default): `zig build run -- tests/fixtures/` shows ESLint-style grouped output
4. Run with JSON output: `zig build run -- --format json tests/fixtures/` shows valid JSON with version, timestamp, summary
5. Run with verbose: `zig build run -- --verbose tests/fixtures/` shows all functions including clean ones
6. Run with quiet: `zig build run -- --quiet tests/fixtures/` shows only errors and verdict
7. Exit code is 0 when all checks pass, non-zero when violations exist
8. JSON output contains null for uncomputed metrics (cognitive, halstead, health_score)
9. Color output disabled when piped or --no-color flag used
</verification>

<success_criteria>
- src/output/json_output.zig exists with JsonOutput struct, buildJsonOutput, serializeJsonOutput, all tests passing
- main.zig restructured with single analysis pass, format selection, verbosity modes, exit codes
- `zig build run -- tests/fixtures/` produces ESLint-style console output
- `zig build run -- --format json tests/fixtures/` produces valid JSON output
- Exit codes match CI-01 through CI-05 requirements
- Double-analysis pattern eliminated
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-console-json-output/05-02-SUMMARY.md`
</output>
