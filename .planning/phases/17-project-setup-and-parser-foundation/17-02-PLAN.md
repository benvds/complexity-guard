---
phase: 17-project-setup-and-parser-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - "17-01"
files_modified:
  - rust/src/parser/mod.rs
  - rust/src/main.rs
  - rust/tests/parser_tests.rs
autonomous: true
requirements:
  - PARSE-01
  - PARSE-02
  - PARSE-03
  - PARSE-04
  - PARSE-05

must_haves:
  truths:
    - "TypeScript fixture files parse without errors and extract function names"
    - "TSX fixture files parse without errors and extract function names"
    - "JavaScript fixture files parse without errors and extract function names"
    - "JSX fixture files parse without errors and extract function names"
    - "Extracted functions have correct name, 1-indexed start_line, and 0-indexed start_column"
  artifacts:
    - path: "rust/src/parser/mod.rs"
      provides: "Language selection, file parsing, and DFS function extraction"
      exports: ["select_language", "parse_file"]
      min_lines: 80
    - path: "rust/tests/parser_tests.rs"
      provides: "Integration tests for all four language grammars against real fixture files"
      min_lines: 60
  key_links:
    - from: "rust/src/parser/mod.rs"
      to: "rust/src/types.rs"
      via: "returns ParseResult with FunctionInfo vec"
      pattern: "ParseResult"
    - from: "rust/src/parser/mod.rs"
      to: "tree-sitter-typescript"
      via: "LANGUAGE_TYPESCRIPT and LANGUAGE_TSX constants"
      pattern: "LANGUAGE_TYPESCRIPT|LANGUAGE_TSX"
    - from: "rust/src/parser/mod.rs"
      to: "tree-sitter-javascript"
      via: "LANGUAGE constant for JS and JSX"
      pattern: "tree_sitter_javascript::LANGUAGE"
    - from: "rust/tests/parser_tests.rs"
      to: "tests/fixtures/"
      via: "relative path to existing Zig fixture files"
      pattern: "fixtures"
---

<objective>
Implement the parser module with language selection, file parsing, and function extraction using TDD against the existing fixture files. All four languages (TS, TSX, JS, JSX) must parse and extract function declarations.

Purpose: The parser is the foundation every metric module depends on. Verifying correct parsing and function extraction against real fixtures ensures the Rust rewrite produces the same AST structure the Zig version uses.
Output: Working parser module + integration test suite covering all four languages.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-project-setup-and-parser-foundation/17-RESEARCH.md
@.planning/phases/17-project-setup-and-parser-foundation/17-01-SUMMARY.md
@tests/fixtures/typescript/simple_function.ts
@tests/fixtures/typescript/react_component.tsx
@tests/fixtures/javascript/express_middleware.js
@tests/fixtures/javascript/jsx_component.jsx
</context>

<feature>
  <name>Parser: language selection, file parsing, and function extraction</name>
  <files>rust/src/parser/mod.rs, rust/tests/parser_tests.rs</files>
  <behavior>
  The parser must:

  1. **Language selection** (`select_language`):
     - `.ts` → tree_sitter_typescript::LANGUAGE_TYPESCRIPT
     - `.tsx` → tree_sitter_typescript::LANGUAGE_TSX
     - `.js` → tree_sitter_javascript::LANGUAGE
     - `.jsx` → tree_sitter_javascript::LANGUAGE
     - Other/no extension → ParseError

  2. **File parsing** (`parse_file`):
     - Read file from disk as bytes
     - Select language by extension
     - Create Parser, set language, parse source
     - Return ParseResult with owned data only (no Node/Tree references outside scope)

  3. **Function extraction** (`extract_functions`):
     - DFS traversal of the CST using TreeCursor
     - Match function node kinds: `function_declaration`, `method_definition`, `arrow_function` (when assigned to variable via `variable_declarator` or `lexical_declaration`)
     - For each function, extract: name (String), start_line (1-indexed), start_column (0-indexed), end_line (1-indexed)
     - Arrow functions assigned to const/let/var: get name from the variable declarator's name child
     - Anonymous arrow functions (e.g., callbacks): skip or use empty name — they will be handled in metric phases

  Test cases (against existing fixtures):

  - `simple_function.ts` → parse OK, extracts function "greet" at line 5
  - `react_component.tsx` → parse OK, extracts "Greeting" function + "Badge" const arrow
  - `express_middleware.js` → parse OK, extracts "errorHandler" and "rateLimiter" functions
  - `jsx_component.jsx` → parse OK, extracts "Card" function + "List" const arrow
  - `class_with_methods.ts` → parse OK, extracts class methods
  - Unsupported extension → returns ParseError::UnsupportedExtension
  </behavior>
  <implementation>
  Follow TDD: RED (write tests first, confirm they fail) → GREEN (implement parser to pass) → REFACTOR.

  **RED phase:**
  Create `rust/tests/parser_tests.rs` with integration tests for all four fixture types. Tests import `complexity_guard::parser::parse_file` and `complexity_guard::types::ParseResult`. Tests assert: no parse errors, correct function count, correct function names, correct line numbers. These tests MUST fail initially because `parser/mod.rs` doesn't exist yet.

  To make the parser module accessible from integration tests, add `pub mod parser;` to `main.rs` and also create `rust/src/lib.rs` that re-exports: `pub mod types; pub mod parser;`. Integration tests in `rust/tests/` can only access the crate through `lib.rs`.

  **GREEN phase:**
  Implement `rust/src/parser/mod.rs`:
  - `pub fn select_language(path: &Path) -> Result<tree_sitter::Language, ParseError>` — match on extension
  - `pub fn parse_file(path: &Path) -> Result<ParseResult, ParseError>` — read, parse, extract
  - `fn extract_functions(root: tree_sitter::Node, source: &[u8]) -> Vec<FunctionInfo>` — DFS with TreeCursor

  The DFS traversal pattern:
  ```
  loop {
      let node = cursor.node();
      check if node is a function kind → extract info
      if cursor.goto_first_child() { continue; }
      if cursor.goto_next_sibling() { continue; }
      loop {
          if !cursor.goto_parent() { return; }
          if cursor.goto_next_sibling() { break; }
      }
  }
  ```

  For arrow functions assigned to variables, when encountering `variable_declarator` with an `arrow_function` value child, extract the name from the `variable_declarator`'s `name` field and the position from the `arrow_function` node.

  For `method_definition` nodes inside classes, extract the name from the `name` field child.

  Fixture paths in tests: use `Path::new("../tests/fixtures/typescript/simple_function.ts")` etc. (relative from `rust/` working directory).

  **REFACTOR phase:**
  Clean up, ensure all doc comments on public items, run `cargo clippy`.
  </implementation>
</feature>

<verification>
1. `cd rust && cargo test` — all parser integration tests pass
2. `cd rust && cargo test -- --nocapture` — shows function names extracted from each fixture
3. TypeScript: parse simple_function.ts → "greet" function found
4. TSX: parse react_component.tsx → "Greeting" and "Badge" found
5. JavaScript: parse express_middleware.js → "errorHandler" and "rateLimiter" found
6. JSX: parse jsx_component.jsx → "Card" and "List" found
7. Function line numbers are 1-indexed (first line = 1, not 0)
8. Function columns are 0-indexed
</verification>

<success_criteria>
- All four language grammars parse their respective fixture files without errors
- Function extraction finds named functions, methods, and const arrow functions
- FunctionInfo contains correct name, 1-indexed start_line, 0-indexed start_column, 1-indexed end_line
- All integration tests pass via `cargo test`
- No tree-sitter Node or Tree references leak outside the parse_file function scope
</success_criteria>

<output>
After completion, create `.planning/phases/17-project-setup-and-parser-foundation/17-02-SUMMARY.md`
</output>
