---
phase: 18-core-metrics-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - rust/Cargo.toml
  - rust/src/lib.rs
  - rust/src/types.rs
  - rust/src/metrics/mod.rs
  - rust/src/metrics/cyclomatic.rs
  - rust/src/metrics/structural.rs
autonomous: true
requirements: [METR-01, METR-04]

must_haves:
  truths:
    - "Cyclomatic complexity values match Zig output for fixture files (cyclomatic_cases.ts, complex_nested.ts)"
    - "Structural metrics (function_length, params_count, nesting_depth) match Zig output for structural_cases.ts"
    - "Parameter counting includes both formal_parameters and type_parameters, excluding punctuation"
    - "Logical line counting skips blank lines, comments, and standalone brace lines"
    - "Function boundary isolation (is_function_node) prevents nested function metrics leaking to parent"
  artifacts:
    - path: "rust/src/metrics/mod.rs"
      provides: "Metrics module root with shared types and utilities"
      contains: "is_function_node"
    - path: "rust/src/metrics/cyclomatic.rs"
      provides: "Cyclomatic complexity calculation"
      exports: ["analyze_functions"]
    - path: "rust/src/metrics/structural.rs"
      provides: "Structural metrics calculation"
      exports: ["analyze_functions", "analyze_file"]
    - path: "rust/src/types.rs"
      provides: "Extended types for metric results"
      contains: "CyclomaticConfig"
  key_links:
    - from: "rust/src/metrics/cyclomatic.rs"
      to: "rust/src/metrics/mod.rs"
      via: "is_function_node guard"
      pattern: "is_function_node"
    - from: "rust/src/metrics/structural.rs"
      to: "rust/src/metrics/mod.rs"
      via: "is_function_node guard"
      pattern: "is_function_node"
---

<objective>
Establish the metrics module foundation with shared types, utilities, and the two simplest metric families: cyclomatic complexity and structural metrics.

Purpose: Creates the module structure, config types, and shared is_function_node guard that all subsequent metric modules depend on. Implements the two metrics that have the most straightforward tree-sitter traversal patterns, validating the approach before tackling cognitive and Halstead.

Output: `rust/src/metrics/` module with cyclomatic and structural metrics producing correct values against Zig fixture output.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-core-metrics-pipeline/18-RESEARCH.md
@rust/src/types.rs
@rust/src/parser/mod.rs
@rust/src/lib.rs
@rust/Cargo.toml
@src/metrics/cyclomatic.zig
@src/metrics/structural.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics module foundation with shared types and Cargo dependencies</name>
  <files>
    rust/Cargo.toml
    rust/src/lib.rs
    rust/src/types.rs
    rust/src/metrics/mod.rs
  </files>
  <action>
**Add dependencies to rust/Cargo.toml:**
```toml
rustc-hash = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

**Create rust/src/metrics/mod.rs** with:
1. Module declarations: `pub mod cyclomatic;` and `pub mod structural;`
2. Shared `is_function_node()` function matching Zig's exact node type list:
   - `function_declaration`, `function`, `function_expression`, `arrow_function`, `method_definition`, `generator_function`, `generator_function_declaration`
3. Shared `PUNCTUATION` const: `&[",", "(", ")", "<", ">", ";"]` (used by structural param counting)

**Extend rust/src/types.rs** with:
1. `CyclomaticConfig` struct with fields matching Zig's `CyclomaticConfig`:
   - `count_logical_operators: bool` (default true)
   - `count_nullish_coalescing: bool` (default true)
   - `count_optional_chaining: bool` (default true)
   - `count_ternary: bool` (default true)
   - `count_default_params: bool` (default true)
   - `switch_case_mode: SwitchCaseMode` (default Classic)
   - `warning_threshold: u32` (default 10)
   - `error_threshold: u32` (default 20)
2. `SwitchCaseMode` enum: `Classic`, `Modified`
3. `CyclomaticResult` struct: `name: String`, `complexity: u32`, `start_line: usize`, `end_line: usize`, `start_col: usize`
4. `StructuralResult` struct: `name: String`, `function_length: u32`, `params_count: u32`, `nesting_depth: u32`, `start_line: usize`, `end_line: usize`, `start_col: usize`
5. `FileStructuralResult` struct: `file_length: u32`, `export_count: u32`
6. Implement `Default` for `CyclomaticConfig` with the documented defaults.
7. Add `#[derive(Debug, Clone, serde::Serialize)]` to all result types.

**Update rust/src/lib.rs** to add `pub mod metrics;`.

Do NOT create stub implementations in cyclomatic.rs or structural.rs yet — those are Task 2 and Task 3.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo build 2>&1</automated>
    <manual>Verify metrics module compiles with new types and shared utilities</manual>
  </verify>
  <done>Metrics module foundation exists with shared types, is_function_node guard, and Cargo dependencies. Code compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Implement cyclomatic complexity with tests</name>
  <files>
    rust/src/metrics/cyclomatic.rs
  </files>
  <action>
**Create rust/src/metrics/cyclomatic.rs** porting the algorithm from `src/metrics/cyclomatic.zig` (the Zig source is the authoritative spec).

**Core function:** `pub fn analyze_functions(root: tree_sitter::Node, source: &[u8], config: &CyclomaticConfig) -> Vec<CyclomaticResult>`

The function must:
1. Walk the AST using DFS, finding all function nodes (using `is_function_node()` from mod.rs)
2. For each function, extract name (handling variable_declarator parents for arrow functions), start/end lines, column
3. Call `count_decision_points()` on the function body
4. Return base complexity 1 + decision point count

**`count_decision_points(node, source, config)` must count exactly:**
- `if_statement`, `while_statement`, `do_statement`, `for_statement`, `for_in_statement`, `catch_clause` → +1 each
- `ternary_expression` → +1 if `config.count_ternary`
- `switch_statement` → +1 if `config.switch_case_mode == Modified`
- `switch_case` → +1 if Classic mode AND has a non-punctuation expression child (not bare `default`)
- `binary_expression` children `&&`/`||` → +1 each if `config.count_logical_operators`
- `binary_expression` children `??` → +1 each if `config.count_nullish_coalescing`
- `augmented_assignment_expression` children `&&=`/`||=` → +1 each if `config.count_logical_operators`
- `member_expression`/`call_expression`/`subscript_expression` with `?.` child → +1 if `config.count_optional_chaining`
- **CRITICAL:** Stop recursion at nested function nodes (call `is_function_node()` at top of recursive function)

**Function name extraction pattern** (must match Zig behavior exactly):
- `function_declaration` / `method_definition` → `child_by_field_name("name")`
- `variable_declarator` parent with arrow_function child → name from declarator's `name` field
- `generator_function` / `generator_function_declaration` → `child_by_field_name("name")`
- Fallback: `"<anonymous>"`

**Tests** (add at bottom of file in `#[cfg(test)] mod tests`):
- Test `count_decision_points` on `tests/fixtures/typescript/cyclomatic_cases.ts` — compare function names and complexity values against Zig binary output. Run the Zig binary first: `./zig-out/bin/complexity-guard --format json tests/fixtures/typescript/cyclomatic_cases.ts` to obtain the expected values.
- Test `count_decision_points` on `tests/fixtures/typescript/complex_nested.ts` to validate nested function isolation.
- Test with `SwitchCaseMode::Modified` to verify the switch counting difference.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test metrics::cyclomatic -- --nocapture 2>&1</automated>
  </verify>
  <done>Cyclomatic complexity values match Zig output for cyclomatic_cases.ts and complex_nested.ts fixture files. Both Classic and Modified switch modes work correctly.</done>
</task>

<task type="auto">
  <name>Task 3: Implement structural metrics with tests</name>
  <files>
    rust/src/metrics/structural.rs
  </files>
  <action>
**Create rust/src/metrics/structural.rs** porting the algorithm from `src/metrics/structural.zig`.

**Two public functions:**

1. `pub fn analyze_functions(root: tree_sitter::Node, source: &[u8]) -> Vec<StructuralResult>` — per-function metrics
2. `pub fn analyze_file(source: &[u8], root: tree_sitter::Node) -> FileStructuralResult` — file-level metrics

**Per-function analysis must compute:**
- `function_length`: Logical line count via `count_logical_lines()` (see exact algorithm in research doc Pattern 9):
  - Skip blank lines, `//` comment lines, block comment interiors, standalone brace lines (`{`, `}`, `};`, `},`)
  - Special case: arrow functions without `statement_block` → `function_length = 1`
- `params_count`: Count via `count_parameters()` (research doc Pattern 10):
  - Count children of `formal_parameters` and `type_parameters` nodes
  - Exclude punctuation tokens: `","`, `"("`, `")"`, `"<"`, `">"`, `";"`
- `nesting_depth`: Maximum nesting depth within function body
  - Nesting constructs: `if_statement`, `while_statement`, `do_statement`, `for_statement`, `for_in_statement`, `switch_statement`, `try_statement`
  - Stop at nested function boundaries (`is_function_node()`)

**File-level analysis:**
- `file_length`: Total logical lines for entire file using `count_logical_lines(source, 0, source.len())`
- `export_count`: Count `export_statement` nodes in root children

**Function name extraction:** Same pattern as cyclomatic (variable_declarator → name for arrows, child_by_field_name("name") for declarations/methods).

**Tests** (in `#[cfg(test)] mod tests`):
- Test against `tests/fixtures/typescript/structural_cases.ts` — run `./zig-out/bin/complexity-guard --format json tests/fixtures/typescript/structural_cases.ts` to get expected values.
- Test `count_logical_lines` with inline strings covering: blank lines, comment lines, block comments, brace-only lines.
- Test `count_parameters` with a fixture that has both formal and generic type parameters.
- Test arrow functions without block body → `function_length == 1`.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test metrics::structural -- --nocapture 2>&1</automated>
  </verify>
  <done>Structural metrics match Zig output for structural_cases.ts. Logical line counting correctly handles all skip cases. Parameter counting includes type parameters.</done>
</task>

</tasks>

<verification>
```bash
# All metrics tests pass
cd /Users/benvds/code/complexity-guard/rust && cargo test metrics:: -q

# No compiler warnings
cd /Users/benvds/code/complexity-guard/rust && cargo clippy -- -D warnings

# Verify module structure exists
ls rust/src/metrics/mod.rs rust/src/metrics/cyclomatic.rs rust/src/metrics/structural.rs
```
</verification>

<success_criteria>
1. `cargo test metrics::cyclomatic` passes with correct values for cyclomatic_cases.ts and complex_nested.ts
2. `cargo test metrics::structural` passes with correct values for structural_cases.ts
3. `is_function_node()` correctly gates all 7 function node types
4. `CyclomaticConfig` defaults match Zig defaults exactly
5. All code compiles without warnings under `cargo clippy`
</success_criteria>

<output>
After completion, create `.planning/phases/18-core-metrics-pipeline/18-01-SUMMARY.md`
</output>
