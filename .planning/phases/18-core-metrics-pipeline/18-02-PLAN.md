---
phase: 18-core-metrics-pipeline
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - rust/src/metrics/mod.rs
  - rust/src/metrics/cognitive.rs
  - rust/src/metrics/halstead.rs
autonomous: true
requirements: [METR-02, METR-03]

must_haves:
  truths:
    - "Cognitive complexity values match Zig output including per-operator &&/||/?? counting deviation from SonarSource"
    - "Each && || ?? inside binary_expression counts as +1 flat individually, not grouped by same-operator sequences"
    - "Halstead metrics (volume, difficulty, effort, bugs) match Zig output within 1e-6 float tolerance"
    - "Halstead type-only nodes (18 TypeScript types) are skipped, preventing inflated counts for .ts files"
    - "Nesting depth increments apply to cognitive complexity increment calculation"
  artifacts:
    - path: "rust/src/metrics/cognitive.rs"
      provides: "Cognitive complexity calculation with per-operator deviation"
      exports: ["analyze_functions"]
    - path: "rust/src/metrics/halstead.rs"
      provides: "Halstead metrics calculation with type-node skipping"
      exports: ["analyze_functions"]
  key_links:
    - from: "rust/src/metrics/cognitive.rs"
      to: "rust/src/metrics/mod.rs"
      via: "is_function_node guard for nested function isolation"
      pattern: "is_function_node"
    - from: "rust/src/metrics/halstead.rs"
      to: "rust/src/metrics/mod.rs"
      via: "is_function_node guard"
      pattern: "is_function_node"
---

<objective>
Implement the two more complex per-function metric families: cognitive complexity (with the critical per-operator counting deviation) and Halstead metrics (with type-only node skipping).

Purpose: These are the highest-risk metrics for parity failures. Cognitive complexity has a documented deviation from SonarSource's spec that must be replicated exactly. Halstead requires precise operator/operand classification and TypeScript type-node skipping.

Output: `cognitive.rs` and `halstead.rs` producing correct values validated against Zig binary output for all fixture files.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-core-metrics-pipeline/18-RESEARCH.md
@.planning/phases/18-core-metrics-pipeline/18-01-SUMMARY.md
@rust/src/types.rs
@rust/src/metrics/mod.rs
@src/metrics/cognitive.zig
@src/metrics/halstead.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement cognitive complexity with per-operator deviation</name>
  <files>
    rust/src/metrics/cognitive.rs
    rust/src/types.rs
    rust/src/metrics/mod.rs
  </files>
  <action>
**Add to rust/src/types.rs:**
- `CognitiveResult` struct: `name: String`, `complexity: u32`, `start_line: usize`, `end_line: usize`, `start_col: usize` (with `#[derive(Debug, Clone, serde::Serialize)]`)
- `CognitiveConfig` struct: `warning_threshold: u32` (default 15), `error_threshold: u32` (default 30). Implement `Default`.

**Add to rust/src/metrics/mod.rs:** `pub mod cognitive;`

**Create rust/src/metrics/cognitive.rs** porting from `src/metrics/cognitive.zig`.

**Core function:** `pub fn analyze_functions(root: tree_sitter::Node, source: &[u8]) -> Vec<CognitiveResult>`

Walk the AST finding function nodes, then for each function call `visit_node()` with nesting_level=0.

**`visit_node(node, source, nesting_level)` must implement:**

1. **Guard:** if `is_function_node(node.kind())`, return 0 (stop at nested functions)
2. **Increment nodes** (complexity += 1 + nesting_level):
   - `if_statement`, `while_statement`, `do_statement`, `for_statement`, `for_in_statement`, `catch_clause`
   - These also increment nesting for their children
3. **Nesting-only nodes** (increase nesting but don't add to complexity):
   - `switch_statement`, `ternary_expression`
4. **Else handling:**
   - `else_clause` → check if its first child is `if_statement` (else-if continuation = +1 flat, no nesting increment)
   - `else_clause` without if child → +1 flat (no nesting increment)
5. **CRITICAL per-operator deviation (Pitfall 1 from research):**
   - `binary_expression` → iterate children:
     - `&&`, `||`, `??` → each counts as +1 FLAT (no nesting increment)
     - Non-operator children → recurse with `visit_node`
   - EARLY RETURN after handling binary_expression children (don't recurse again)
6. **Recursion detection:** If a function calls itself by name → +1 (check `call_expression` whose function child matches current function name)
7. **Arrow callback handling:** Arrow functions inside `arguments` or `call_expression` → increment nesting

**Function name extraction:** Same pattern as cyclomatic (delegated to the shared walk-and-name pattern).

**Tests** (in `#[cfg(test)] mod tests`):
- Test against `tests/fixtures/typescript/cognitive_cases.ts` — use these expected values (from Zig binary output):
  ```
  baseline:                  cognitive=0
  singleIf:                  cognitive=1
  ifElseChain:               cognitive=4
  nestedIfInLoop:            cognitive=6
  logicalOps:                cognitive=3
  mixedLogicalOps:           cognitive=4
  factorial:                 cognitive=2
  topLevelArrow:             cognitive=1
  withCallback:              cognitive=3
  switchStatement:           cognitive=1
  tryCatch:                  cognitive=1
  ternaryNested:             cognitive=3
  MyClass.classMethod:       cognitive=3
  deeplyNested:              cognitive=10
  labeledBreak:              cognitive=7
  noIncrement:               cognitive=0
  ```
- Test against `tests/fixtures/typescript/complex_nested.ts` — expected:
  ```
  processData:               cognitive=35
  ```
- **MANDATORY:** Include a test specifically for `binary_expression` with multiple `&&`/`||` operators to verify each operator counts as +1 individually, NOT grouped.
- Test `else if` continuation (should be +1 flat, not nested).
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test metrics::cognitive -- --nocapture 2>&1</automated>
  </verify>
  <done>Cognitive complexity values match Zig output for cognitive_cases.ts and complex_nested.ts. Per-operator && / || / ?? counting verified as +1 each individually.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Halstead metrics with type-node skipping</name>
  <files>
    rust/src/metrics/halstead.rs
    rust/src/types.rs
    rust/src/metrics/mod.rs
  </files>
  <action>
**Add to rust/src/types.rs:**
- `HalsteadResult` struct: `name: String`, `volume: f64`, `difficulty: f64`, `effort: f64`, `time: f64`, `bugs: f64`, `start_line: usize`, `end_line: usize`, `start_col: usize` (with `#[derive(Debug, Clone, serde::Serialize)]`)

**Add to rust/src/metrics/mod.rs:** `pub mod halstead;`

**Create rust/src/metrics/halstead.rs** porting from `src/metrics/halstead.zig`.

**Core function:** `pub fn analyze_functions(root: tree_sitter::Node, source: &[u8]) -> Vec<HalsteadResult>`

Walk AST finding function nodes, then for each function classify all leaf nodes.

**Internal struct** `HalsteadContext` using `rustc_hash::FxHashMap`:
```rust
struct HalsteadContext {
    operators: FxHashMap<&'static str, u32>,   // node kind -> count
    operands: FxHashMap<String, u32>,           // source text -> count
    n1_total: u32,  // total operator occurrences
    n2_total: u32,  // total operand occurrences
}
```

Note: Use `String` for operand keys (source text slices need to be owned for safe HashMap usage).

**Deriving Halstead counts from HalsteadContext:**
- `n1` (distinct operators) = `operators.len()`
- `n2` (distinct operands) = `operands.len()`
- `N1` (total operator occurrences) = `n1_total` (incremented on each operator token encounter)
- `N2` (total operand occurrences) = `n2_total` (incremented on each operand token encounter)
- The map value (`u32`) is the occurrence count per unique token; `len()` gives the distinct count.

**`classify_node(node, source, ctx)` recursive classifier:**

1. **Guard:** if `is_function_node(node.kind())`, return (stop at nested functions)
2. **Type-only skip (Pitfall 7):** if `is_type_only_node(node.kind())`, return immediately. The 18 type-only node kinds:
   `type_annotation`, `type_identifier`, `generic_type`, `type_parameters`, `type_parameter`, `predefined_type`, `union_type`, `intersection_type`, `array_type`, `object_type`, `tuple_type`, `function_type`, `readonly_type`, `type_query`, `as_expression`, `satisfies_expression`, `interface_declaration`, `type_alias_declaration`
3. **Leaf node classification** (node.child_count() == 0):
   - Check `is_operator_token(kind)` → insert/increment in operators map, n1_total += 1
   - Check `is_operand_token(kind)` → insert/increment in operands map (key = source text), n2_total += 1
   - Ternary special case: `"ternary_expression"` node → count as operator `"?:"` (this is NOT a leaf, handle separately)
4. **Non-leaf:** recurse into children

**`is_operator_token()` — exact 42 tokens from research doc.** Use the full list from the Code Examples section.

**`is_operand_token()` — exact 11 tokens:** `identifier`, `number`, `string`, `template_string`, `regex`, `true`, `false`, `null`, `undefined`, `this`, `property_identifier`

**Halstead formulas (all f64):**
```
n1 = distinct operators count
n2 = distinct operands count
N1 = total operator occurrences
N2 = total operand occurrences
N = N1 + N2 (program length)
n = n1 + n2 (vocabulary)
volume = N * log2(n)           — if n == 0, volume = 0
difficulty = (n1 / 2) * (N2 / n2) — if n2 == 0, difficulty = 0
effort = volume * difficulty
time = effort / 18
bugs = volume / 3000
```

**Tests** (in `#[cfg(test)] mod tests`):
- Test against `tests/fixtures/typescript/halstead_cases.ts` — use these expected values (from Zig binary output). **Use float tolerance:** `assert!((actual - expected).abs() < 1e-6)` for all f64 comparisons.
  ```
  simpleAssignment:          volume=18.094737505048094, difficulty=2.0,   effort=36.18947501009619,   bugs=0.006031579168349364
  withTypeAnnotations:       volume=8.0,               difficulty=1.0,   effort=8.0,                 bugs=0.0026666666666666666
  emptyFunction:             volume=0.0,               difficulty=0.0,   effort=0.0,                 bugs=0.0
  singleExpressionArrow:     volume=4.754887502163468,  difficulty=0.5,   effort=2.377443751081734,   bugs=0.001584962500721156
  complexLogic:              volume=65.72920075410865,  difficulty=6.125, effort=402.59135461891543,  bugs=0.02190973358470288
  ServiceClass.processValue: volume=31.69925001442312,  difficulty=2.4,   effort=76.07820003461549,   bugs=0.010566416671474373
  withNullishAndOptional:    volume=8.0,               difficulty=1.0,   effort=8.0,                 bugs=0.0026666666666666666
  withTernary:               volume=11.60964047443681,  difficulty=1.5,   effort=17.414460711655217,  bugs=0.0038698801581456034
  ```
- Test that TypeScript type annotations do NOT inflate operator/operand counts (`withTypeAnnotations` has volume=8.0, same as plain JS equivalent — types are skipped).
- Test against a JS fixture to verify no type-skipping is triggered for plain JavaScript.
  </action>
  <verify>
    <automated>cd /Users/benvds/code/complexity-guard/rust && cargo test metrics::halstead -- --nocapture 2>&1</automated>
  </verify>
  <done>Halstead metrics match Zig output within 1e-6 tolerance for halstead_cases.ts. Type-only nodes are correctly skipped for TypeScript files.</done>
</task>

</tasks>

<verification>
```bash
# All cognitive and halstead tests pass
cd /Users/benvds/code/complexity-guard/rust && cargo test metrics::cognitive -q && cargo test metrics::halstead -q

# All prior tests still pass
cd /Users/benvds/code/complexity-guard/rust && cargo test -q

# No compiler warnings
cd /Users/benvds/code/complexity-guard/rust && cargo clippy -- -D warnings
```
</verification>

<success_criteria>
1. `cargo test metrics::cognitive` passes with exact Zig-matching values for cognitive_cases.ts
2. Per-operator counting deviation verified: multiple `&&` in one expression each count as +1
3. `cargo test metrics::halstead` passes with values within 1e-6 of Zig output for halstead_cases.ts
4. TypeScript type annotations do not inflate Halstead counts
5. All 4 metric modules (cyclomatic, structural, cognitive, halstead) compile and pass tests together
</success_criteria>

<output>
After completion, create `.planning/phases/18-core-metrics-pipeline/18-02-SUMMARY.md`
</output>
