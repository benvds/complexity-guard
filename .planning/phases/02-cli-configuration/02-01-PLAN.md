---
phase: 02-cli-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - build.zig.zon
  - build.zig
  - src/cli/args.zig
  - src/cli/config.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "zig-clap, zig-toml, known-folders dependencies resolve and compile"
    - "Config struct types match the locked schema (output, analysis, files, weights, overrides)"
    - "CLI arg parser accepts all flags defined in CLI-01 through CLI-12"
    - "zig build test passes with new modules imported"
  artifacts:
    - path: "build.zig.zon"
      provides: "External dependency declarations"
      contains: "zig-clap"
    - path: "build.zig"
      provides: "Dependency wiring to exe and test modules"
      contains: "clap"
    - path: "src/cli/config.zig"
      provides: "Config struct types matching locked schema"
      contains: "OutputConfig"
    - path: "src/cli/args.zig"
      provides: "CLI argument parsing with zig-clap"
      contains: "parseArgs"
  key_links:
    - from: "build.zig"
      to: "build.zig.zon"
      via: "dependency resolution"
      pattern: "b\\.dependency"
    - from: "src/cli/args.zig"
      to: "zig-clap"
      via: "import"
      pattern: "@import.*clap"
    - from: "src/main.zig"
      to: "src/cli/args.zig"
      via: "test import block"
      pattern: "@import.*cli/args"
---

<objective>
Add external dependencies (zig-clap, zig-toml, known-folders), define the Config struct types matching the user's locked schema, and implement CLI argument parsing with all flags.

Purpose: Foundation for all Phase 2 work -- dependencies must compile and types must be defined before config loading or help output can be built.
Output: Compilable CLI module with arg parsing and config type definitions.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-configuration/02-CONTEXT.md
@.planning/phases/02-cli-configuration/02-RESEARCH.md
@build.zig
@build.zig.zon
@src/main.zig
@src/core/types.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add external dependencies and wire into build system</name>
  <files>build.zig.zon, build.zig</files>
  <action>
Add zig-clap, zig-toml (sam701), and known-folders to the project:

1. Run `zig fetch --save git+https://github.com/Hejsil/zig-clap` to add zig-clap to build.zig.zon
2. Run `zig fetch --save git+https://github.com/sam701/zig-toml` to add zig-toml
3. Run `zig fetch --save git+https://github.com/ziglibs/known-folders` to add known-folders

NOTE: Do NOT add glob.zig yet -- it's needed for Phase 3 file discovery, not Phase 2 config parsing.

4. Update build.zig to wire dependencies into both the exe and test modules:
   - For the exe module: add `clap`, `toml`, and `known_folders` as imports via `root_module.addImport()`
   - For the test module: add the same imports so tests can use these libraries
   - Each dependency is obtained via `b.dependency("zig_clap", .{...})` (or similar name from zon) then `.module("clap")` etc.

IMPORTANT: The exact dependency names in build.zig.zon are determined by `zig fetch --save` output. Read build.zig.zon after fetching to get the actual names. zig-clap typically exposes a module named "clap", zig-toml exposes "toml", known-folders exposes "known-folders".

IMPORTANT: Zig 0.15.2 API -- use `b.dependency(name, .{ .target = target, .optimize = optimize })` pattern. The module is obtained from the dependency, then added to the root_module via `exe.root_module.addImport("clap", clap_dep.module("clap"))`.

5. Verify with `zig build` that all dependencies resolve without errors.
  </action>
  <verify>
`zig build` succeeds without errors. `zig build test` succeeds. build.zig.zon contains entries for all three dependencies.
  </verify>
  <done>Three external dependencies (zig-clap, zig-toml, known-folders) are declared in build.zig.zon and wired into both exe and test targets in build.zig.</done>
</task>

<task type="auto">
  <name>Task 2: Define Config struct types matching locked schema</name>
  <files>src/cli/config.zig, src/main.zig</files>
  <action>
Create `src/cli/config.zig` with Config struct types that exactly match the user's locked schema decisions:

Top-level Config struct with optional fields:
```
Config {
    output: ?OutputConfig,
    analysis: ?AnalysisConfig,
    files: ?FilesConfig,
    weights: ?WeightsConfig,
    overrides: ?[]OverrideConfig,
}
```

OutputConfig:
```
OutputConfig {
    format: ?[]const u8,       // "console", "json", "sarif", "html"
    file: ?[]const u8,         // output file path
}
```

AnalysisConfig:
```
AnalysisConfig {
    metrics: ?[]const []const u8,  // ["cyclomatic", "cognitive", "halstead"]
    thresholds: ?ThresholdsConfig,
    no_duplication: ?bool,
    threads: ?u32,
}
```

ThresholdsConfig -- nested by metric per locked decision:
```
ThresholdsConfig {
    cyclomatic: ?ThresholdPair,
    cognitive: ?ThresholdPair,
    halstead_volume: ?ThresholdPair,
    halstead_difficulty: ?ThresholdPair,
    nesting_depth: ?ThresholdPair,
    line_count: ?ThresholdPair,
    params_count: ?ThresholdPair,
}

ThresholdPair {
    warning: ?u32,
    error_threshold: ?u32,   // "error" is Zig keyword, use error_threshold
}
```

NOTE: In the JSON/TOML config files, the field will be called "error" (not "error_threshold"). Use `@"error"` as the Zig field name since Zig allows quoted identifiers for keywords. This ensures std.json.parseFromSlice maps correctly. Example: `@"error": ?u32,`

FilesConfig:
```
FilesConfig {
    include: ?[]const []const u8,
    exclude: ?[]const []const u8,
}
```

WeightsConfig -- per locked decision (composite score weights):
```
WeightsConfig {
    cyclomatic: ?f64,
    cognitive: ?f64,
    duplication: ?f64,
    halstead: ?f64,
    structural: ?f64,
}
```

OverrideConfig -- ESLint-style per locked decision:
```
OverrideConfig {
    files: []const []const u8,     // glob patterns
    analysis: ?AnalysisConfig,     // reuses same struct
}
```

Also define a `defaults()` function that returns a Config with sensible defaults:
- output.format = "console"
- analysis.metrics = all metrics
- No thresholds (null = no limit)
- weights matching PROJECT.md defaults: cognitive 0.30, cyclomatic 0.20, duplication 0.20, halstead 0.15, structural 0.15

Add tests:
- Test that Config can be created with all null optional fields
- Test that defaults() returns expected default values
- Test that Config struct is compatible with std.json.parseFromSlice by serializing a default config to JSON and parsing it back

Add `_ = @import("cli/config.zig");` to main.zig test block.
  </action>
  <verify>
`zig build test` passes. Config struct types exist with all fields matching the locked schema.
  </verify>
  <done>Config types defined in src/cli/config.zig matching locked schema. Defaults function provides sensible starting values. Tests verify round-trip JSON compatibility.</done>
</task>

<task type="auto">
  <name>Task 3: Implement CLI argument parsing with zig-clap</name>
  <files>src/cli/args.zig, src/main.zig</files>
  <action>
Create `src/cli/args.zig` implementing CLI argument parsing using zig-clap.

Define all flags matching CLI-01 through CLI-12 and the locked flag conventions:

```
-h, --help                  Display this help and exit
    --version               Display version information
-f, --format <str>          Output format (console, json, sarif, html)
-o, --output <str>          Write report to file
-c, --config <str>          Path to config file
    --fail-on <str>         Failure level (warning, error, none)
    --fail-health-below <str>  Exit non-zero if health score below N
    --include <str>...      Include files matching glob (repeatable)
    --exclude <str>...      Exclude files matching glob (repeatable)
    --metrics <str>         Comma-separated metrics list
    --no-duplication        Skip duplication analysis
    --threads <str>         Thread count
    --baseline <str>        Compare against baseline report
-v, --verbose               Show detailed output
-q, --quiet                 Suppress non-error output
    --color                 Force color output
    --no-color              Disable color output
    --init                  Run interactive setup
<positional>...             Files/directories to analyze
```

NOTE on short aliases: Per locked decisions, only -f, -o, -v, -q, -c have short forms. -h is standard for help. Do NOT add -v for --version (it conflicts with --verbose). Use `--version` long-form only.

Create a `CliArgs` struct that holds the parsed result in a clean form:
```
CliArgs {
    help: bool,
    version: bool,
    init: bool,
    format: ?[]const u8,
    output_file: ?[]const u8,
    config_path: ?[]const u8,
    fail_on: ?[]const u8,
    fail_health_below: ?[]const u8,
    include: []const []const u8,
    exclude: []const []const u8,
    metrics: ?[]const u8,
    no_duplication: bool,
    threads: ?[]const u8,
    baseline: ?[]const u8,
    verbose: bool,
    quiet: bool,
    color: bool,
    no_color: bool,
    positional_paths: []const []const u8,
}
```

Implement `pub fn parseArgs(allocator: std.mem.Allocator) !CliArgs` that:
1. Uses zig-clap's `clap.parseParamsComptime` with the parameter string above
2. Parses process args via `clap.parse`
3. Extracts values into CliArgs struct
4. Returns the struct

Also implement `pub fn parseArgsFromSlice(allocator: std.mem.Allocator, args: []const []const u8) !CliArgs` for testing -- this takes an explicit arg slice instead of reading process args.

Add tests using parseArgsFromSlice:
- Test parsing `--format json` sets format to "json"
- Test parsing `--verbose` sets verbose to true
- Test parsing `-f json -o report.json` sets both format and output
- Test parsing positional paths `src/ lib/` captures both
- Test parsing with no args returns all defaults (false/null/empty)

Add `_ = @import("cli/args.zig");` to main.zig test block.

IMPORTANT: Read zig-clap's actual API carefully. The comptime param string format and the parse result access patterns must match the library's actual API. If the zig-clap import or API doesn't match research examples, adapt to the actual library API found in the fetched dependency.
  </action>
  <verify>
`zig build test` passes. All flag tests pass. `zig build run -- --help` shows zig-clap's auto-generated help (even if not yet styled to ripgrep format -- custom help comes in Plan 03).
  </verify>
  <done>CLI arg parser in src/cli/args.zig accepts all flags from CLI-01 through CLI-12 with correct short aliases. Tests verify flag parsing from arg slices. Module compiles with zig-clap dependency.</done>
</task>

</tasks>

<verification>
1. `zig build` compiles without errors (dependencies resolve)
2. `zig build test` passes all existing + new tests
3. `zig build run -- --help` produces help output (zig-clap auto-generated)
4. `zig build run -- --version` is parseable (even if not wired to display version yet)
5. Config types exist and are JSON-serializable
</verification>

<success_criteria>
- Three external dependencies added to build.zig.zon and wired in build.zig
- Config struct types match locked schema exactly (output, analysis, files, weights, overrides)
- CLI arg parser accepts all required flags with correct short aliases
- All tests pass including new modules
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-configuration/02-01-SUMMARY.md`
</output>
