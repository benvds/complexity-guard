---
phase: 02-cli-configuration
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/cli/config.zig
  - src/cli/discovery.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tool searches upward from CWD for config files, stopping at .git boundary"
    - "Tool checks four filenames in order: .complexityguard.json, complexityguard.config.json, .complexityguard.toml, complexityguard.config.toml"
    - "Tool falls back to ~/.config/complexityguard/ user config when no project config found"
    - "Project config wins entirely over user config (no merge)"
    - "--config flag overrides all discovery"
    - "JSON config files parse correctly into Config struct"
    - "TOML config files parse correctly into Config struct"
    - "Invalid config causes hard fail with exit code 3"
    - "Config validation catches domain errors (negative thresholds, unknown metrics)"
  artifacts:
    - path: "src/cli/discovery.zig"
      provides: "Config file discovery (upward search, XDG fallback)"
      exports: ["discoverConfigPath"]
    - path: "src/cli/config.zig"
      provides: "Config loading and validation"
      contains: "loadConfig"
  key_links:
    - from: "src/cli/discovery.zig"
      to: "known-folders"
      via: "import for XDG path"
      pattern: "@import.*known.folders"
    - from: "src/cli/config.zig"
      to: "std.json"
      via: "JSON parsing"
      pattern: "std\\.json\\.parseFromSlice"
    - from: "src/cli/config.zig"
      to: "zig-toml"
      via: "TOML parsing"
      pattern: "@import.*toml"
---

<objective>
Implement config file discovery (upward directory search with .git boundary, XDG fallback) and config loading from both JSON and TOML formats, with validation that hard-fails on invalid config.

Purpose: Users can place config files in their project root or home directory and the tool will find and load them automatically.
Output: Config discovery and loading modules with validation.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-configuration/02-CONTEXT.md
@.planning/phases/02-cli-configuration/02-RESEARCH.md
@.planning/phases/02-cli-configuration/02-01-SUMMARY.md
@src/cli/config.zig
@build.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement config file discovery with upward search and XDG fallback</name>
  <files>src/cli/discovery.zig, src/main.zig</files>
  <action>
Create `src/cli/discovery.zig` implementing config file discovery per locked decisions:

1. `pub fn discoverConfigPath(allocator: std.mem.Allocator, explicit_path: ?[]const u8) !?[]const u8`

   If explicit_path is non-null (--config flag), return it directly (after verifying file exists; if not, return an error that main can map to exit code 3).

   Otherwise, search upward from CWD:
   - Get CWD via `std.process.getCwdAlloc(allocator)`
   - In a loop (max 100 iterations per research pitfall guidance):
     a. Check for config files in current directory in this exact order (locked):
        1. `.complexityguard.json`
        2. `complexityguard.config.json`
        3. `.complexityguard.toml`
        4. `complexityguard.config.toml`
     b. If any found, return the full path
     c. Check if `.git` directory exists in current directory -- if yes, this is the boundary, stop searching
     d. Move to parent via `std.fs.path.dirname(current) orelse break`

   If project config not found, check user-level config:
   - Use known-folders library: `known_folders.getPath(allocator, .roaming_configuration)`
   - Check `{config_home}/complexityguard/config.json` then `{config_home}/complexityguard/config.toml`
   - Return first found, or null if neither exists

   Per locked decision: project config wins entirely over user config (no merge). This function returns at most one path.

2. Implement `pub fn detectConfigFormat(path: []const u8) ConfigFormat`
   - Returns `.json` if path ends with `.json`
   - Returns `.toml` if path ends with `.toml`
   - Define `pub const ConfigFormat = enum { json, toml };`

Add tests:
- Test that discoverConfigPath with explicit path returns that path
- Test detectConfigFormat returns .json for ".complexityguard.json"
- Test detectConfigFormat returns .toml for ".complexityguard.toml"
- Test upward search stops at .git boundary (create temp dirs with `std.testing.tmpDir()` -- set up a dir tree with .git marker and config file above it, verify the config above .git is NOT found)
- Test discovery returns null when no config files exist

Add `_ = @import("cli/discovery.zig");` to main.zig test block.
  </action>
  <verify>
`zig build test` passes. Discovery tests verify upward search, .git boundary, format detection, and explicit path override.
  </verify>
  <done>Config discovery searches upward to .git boundary checking all four filenames in locked order, falls back to XDG user config, and --config flag overrides all discovery.</done>
</task>

<task type="auto">
  <name>Task 2: Implement config loading (JSON + TOML) with validation</name>
  <files>src/cli/config.zig</files>
  <action>
Add config loading and validation to `src/cli/config.zig` (extending the types defined in Plan 01):

1. `pub fn loadConfig(allocator: std.mem.Allocator, path: []const u8, format: ConfigFormat) !Config`

   For JSON:
   - Read file contents via `std.fs.cwd().readFileAlloc(allocator, path, 1024 * 1024)` (1MB max)
   - Parse via `std.json.parseFromSlice(Config, allocator, data, .{ .allocate = .alloc_always, .ignore_unknown_fields = true })`
   - Use `.ignore_unknown_fields = true` so future config keys don't break old versions
   - Return parsed config value

   For TOML:
   - Import zig-toml: `const toml = @import("toml");`
   - Open file, parse via `toml.Parser(Config).init(allocator)` then `parser.parseFile(file)`
   - Return parsed config value

   On parse failure, return a descriptive error. The caller (main.zig in Plan 04) will catch this and print the error + exit with code 3.

2. `pub fn validate(config: Config) !void`

   Validate domain constraints per locked decisions (invalid config = hard fail):
   - If output.format is set, must be one of: "console", "json", "sarif", "html"
   - If weights are set, all values must be >= 0.0 and <= 1.0
   - If thresholds warning and error are both set for same metric, warning must be <= error
   - If analysis.threads is set, must be >= 1

   Return error.InvalidConfig on validation failure. Use a custom error type that includes a message field, OR return the error and let the caller check what went wrong. Simplest approach: return an error set `error{ InvalidFormat, InvalidWeights, InvalidThresholds, InvalidThreads }` with specific variants.

3. `pub fn defaults() Config` -- ensure the defaults function (from Plan 01) returns complete default values including:
   - output.format = "console"
   - weights: cognitive 0.30, cyclomatic 0.20, duplication 0.20, halstead 0.15, structural 0.15
   - All other fields null/empty

Add tests:
- Test loadConfig with a valid JSON string (write temp file, load it, verify fields)
- Test loadConfig with a valid TOML string (write temp file, load it, verify fields)
- Test validate passes for default config
- Test validate rejects invalid format ("xml")
- Test validate rejects negative weights
- Test validate rejects warning > error threshold
- Test JSON and TOML produce identical Config for equivalent content

IMPORTANT: When writing test fixtures, use `std.testing.tmpDir()` to create temporary directories and write config files there. Clean up with `defer tmp_dir.cleanup()`.
  </action>
  <verify>
`zig build test` passes. JSON and TOML config files load correctly into Config struct. Validation catches all domain constraint violations.
  </verify>
  <done>Config loading supports both JSON and TOML formats. Validation catches invalid format, weights, thresholds, and thread count. Invalid config returns specific errors for exit code 3 handling.</done>
</task>

</tasks>

<verification>
1. `zig build test` passes all tests
2. Config discovery finds files in correct priority order
3. Discovery stops at .git boundary
4. JSON configs load and parse correctly
5. TOML configs load and parse correctly
6. Validation rejects invalid configurations
7. --config flag path overrides discovery
</verification>

<success_criteria>
- Config discovery implements upward search with .git boundary per locked decision
- Four config filenames checked in locked order
- XDG user config fallback works via known-folders
- JSON and TOML both load into identical Config struct
- Validation hard-fails on invalid config values
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-configuration/02-02-SUMMARY.md`
</output>
