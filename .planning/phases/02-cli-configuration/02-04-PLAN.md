---
phase: 02-cli-configuration
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - src/cli/merge.zig
  - src/cli/init.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "CLI flags override config file values (CFG-07)"
    - "Bare 'complexityguard' with no args defaults to analyzing current directory"
    - "--init runs interactive setup and generates config file"
    - "Main function wires arg parsing, config discovery, config loading, validation, and merge into complete flow"
    - "Exit code 0 for success, 2 for usage errors, 3 for config errors"
  artifacts:
    - path: "src/cli/merge.zig"
      provides: "CLI flags override config values"
      exports: ["mergeArgsIntoConfig"]
    - path: "src/cli/init.zig"
      provides: "Interactive config file generation"
      exports: ["runInit"]
    - path: "src/main.zig"
      provides: "Complete CLI entry point with all Phase 2 wiring"
      contains: "parseArgs"
  key_links:
    - from: "src/cli/merge.zig"
      to: "src/cli/args.zig"
      via: "reads CliArgs"
      pattern: "CliArgs"
    - from: "src/cli/merge.zig"
      to: "src/cli/config.zig"
      via: "modifies Config"
      pattern: "Config"
    - from: "src/main.zig"
      to: "src/cli/args.zig"
      via: "parseArgs call"
      pattern: "args\\.parseArgs"
    - from: "src/main.zig"
      to: "src/cli/discovery.zig"
      via: "config discovery call"
      pattern: "discovery\\.discoverConfigPath"
    - from: "src/main.zig"
      to: "src/cli/config.zig"
      via: "config load and validate"
      pattern: "config\\.loadConfig"
    - from: "src/main.zig"
      to: "src/cli/merge.zig"
      via: "merge args into config"
      pattern: "merge\\.mergeArgsIntoConfig"
---

<objective>
Implement the merge logic (CLI flags override config), the --init interactive setup command, and wire everything into main.zig as the complete CLI entry point.

Purpose: This is the integration plan that makes the CLI actually work end-to-end. After this, `complexityguard --help`, `complexityguard --version`, `complexityguard --init`, and `complexityguard [paths]` all produce correct behavior.
Output: Fully wired main.zig with complete CLI flow.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-cli-configuration/02-CONTEXT.md
@.planning/phases/02-cli-configuration/02-RESEARCH.md
@.planning/phases/02-cli-configuration/02-01-SUMMARY.md
@.planning/phases/02-cli-configuration/02-02-SUMMARY.md
@.planning/phases/02-cli-configuration/02-03-SUMMARY.md
@src/cli/args.zig
@src/cli/config.zig
@src/cli/discovery.zig
@src/cli/help.zig
@src/cli/errors.zig
@src/main.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement merge logic and --init command</name>
  <files>src/cli/merge.zig, src/cli/init.zig, src/main.zig</files>
  <action>
**Part A: Create `src/cli/merge.zig`**

Implement `pub fn mergeArgsIntoConfig(args: CliArgs, config: *Config) void`

This function applies CLI flag values onto a Config struct, implementing CFG-07 (flags override config). The logic:

For each CLI flag that was explicitly set (non-null / non-default):
- args.format != null -> config.output.format = args.format
- args.output_file != null -> config.output.file = args.output_file
- args.fail_on != null -> set in config (store as a field, or handle in analysis config)
- args.fail_health_below != null -> parse to number, store in config
- args.include.len > 0 -> config.files.include = args.include
- args.exclude.len > 0 -> config.files.exclude = args.exclude
- args.metrics != null -> split on commas, set config.analysis.metrics
- args.no_duplication == true -> config.analysis.no_duplication = true
- args.threads != null -> parse to u32, set config.analysis.threads
- args.verbose == true -> set verbosity (add a `verbose: bool` and `quiet: bool` to Config or handle at call site)
- args.quiet == true -> set verbosity

For positional paths: if args.positional_paths.len > 0, those are the analysis targets. If empty, default to "." (current directory) per locked decision.

NOTE: The merge function does NOT handle --help, --version, --init, --color, --no-color. Those are handled directly in main.zig before merge runs.

Add tests:
- Test that merging args with format="json" onto default config results in format="json"
- Test that merging args with no flags onto config preserves config values
- Test that empty positional paths defaults to "."

**Part B: Create `src/cli/init.zig`**

Implement `pub fn runInit(allocator: std.mem.Allocator) !void`

Interactive setup per locked decision. Reads from stdin, writes to stdout:

1. Print welcome: "ComplexityGuard Configuration Setup\n"
2. Ask output format: "Output format (console/json/sarif/html) [console]: "
   - Read line, trim, default to "console" if empty
3. Ask threshold style: "Threshold strictness (relaxed/moderate/strict) [moderate]: "
   - relaxed: cyclomatic warning=15, error=25; cognitive warning=20, error=30
   - moderate: cyclomatic warning=10, error=20; cognitive warning=15, error=25
   - strict: cyclomatic warning=5, error=10; cognitive warning=8, error=15
4. Ask file patterns: "Exclude patterns (comma-separated, or enter for defaults) [node_modules,dist,build]: "
   - Default: ["node_modules", "dist", "build", ".git"]
5. Ask config format: "Config file format (json/toml) [json]: "

6. Generate config file:
   - If json: write `.complexityguard.json` with formatted JSON
   - If toml: write `.complexityguard.toml` with formatted TOML (hand-write the TOML string, don't use zig-toml serializer)
   - Include a few inline comments in the generated file explaining the options

7. Print success: "Created {filename}\n"

The interactive prompts use the stdin/stdout pattern from research. Read a line, trim whitespace, use default if empty.

Add tests (non-interactive -- test the config generation, not the prompts):
- Test that generating JSON config with moderate thresholds produces valid JSON
- Test that generating TOML config produces valid TOML format

**Part C: Update `src/main.zig`**

Rewrite main() to implement the full CLI flow:

```
1. Set up arena allocator (keep existing pattern)
2. Parse CLI args via args.parseArgs(arena_allocator)
   - On parse error: print error + did-you-mean suggestion via errors module, exit 2
3. If args.help: printHelp(stdout), exit 0
4. If args.version: printVersion(stdout), exit 0
5. If args.init: runInit(arena_allocator), exit 0
6. Discover config path via discovery.discoverConfigPath(arena_allocator, args.config_path)
7. If config path found:
   a. Detect format via discovery.detectConfigFormat(path)
   b. Load config via config.loadConfig(arena_allocator, path, format)
      - On error: print "Error: invalid config at {path}: {details}", exit 3
   c. Validate via config.validate(loaded_config)
      - On error: print validation error, exit 3
8. Else: use config.defaults()
9. Merge CLI args into config via merge.mergeArgsIntoConfig(args, &final_config)
10. Determine analysis paths (from positional args, or default ".")
11. Print summary of what would be analyzed (placeholder for Phase 3):
    "Analyzing {paths}... (analysis not yet implemented)"
    This makes the CLI useful for testing even before Phase 3 adds file discovery.
12. Exit 0
```

Ensure all cli modules are imported in the test block:
```zig
test {
    _ = @import("core/types.zig");
    _ = @import("core/json.zig");
    _ = @import("test_helpers.zig");
    _ = @import("cli/args.zig");
    _ = @import("cli/config.zig");
    _ = @import("cli/discovery.zig");
    _ = @import("cli/help.zig");
    _ = @import("cli/errors.zig");
    _ = @import("cli/merge.zig");
    _ = @import("cli/init.zig");
}
```

Exit codes per locked decisions:
- 0: success
- 2: usage error (bad flags)
- 3: config error (invalid config file)

Use `std.process.exit()` for non-zero exits. For exit 0, just return normally from main.

IMPORTANT: Remember to flush stdout before any exit (Zig 0.15+ buffered writers per research pitfall). Use `defer stdout_writer.flush()` at the top of main after obtaining the writer.

IMPORTANT: Results to stdout, diagnostics/errors to stderr (per locked decision). Use `std.io.getStdErr()` for error messages.
  </action>
  <verify>
Run these commands and verify behavior:
1. `zig build test` -- all tests pass
2. `zig build run -- --help` -- shows compact help with grouped flags
3. `zig build run -- --version` -- shows "complexityguard 0.1.0"
4. `zig build run` -- shows "Analyzing . ..." placeholder message (default path)
5. `zig build run -- src/` -- shows "Analyzing src/ ..."
6. `zig build run -- --format json src/` -- no error (flag accepted)
  </verify>
  <done>
Complete CLI flow wired in main.zig: --help shows grouped help, --version shows version, --init runs setup, config discovery + loading + validation + merge all work, bare invocation defaults to current directory, exit codes are correct.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes all tests
2. `zig build run -- --help` shows ripgrep-style grouped help
3. `zig build run -- --version` shows version
4. `zig build run` defaults to analyzing "."
5. `zig build run -- --format json` accepts the flag
6. Exit codes: 0 for normal, 2 for bad flags, 3 for bad config
7. Errors and diagnostics go to stderr, results to stdout
</verification>

<success_criteria>
- CLI flags override config values per CFG-07
- Bare invocation defaults to current directory per locked decision
- --init generates valid config file interactively
- Main function implements complete flow: parse -> discover -> load -> validate -> merge -> proceed
- All exit codes correct
- stdout/stderr separation correct
</success_criteria>

<output>
After completion, create `.planning/phases/02-cli-configuration/02-04-SUMMARY.md`
</output>
