---
phase: 07-halstead-structural-metrics
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/metrics/structural.zig
  - tests/fixtures/typescript/structural_cases.ts
autonomous: true
requirements:
  - STRC-01
  - STRC-02
  - STRC-03
  - STRC-04
  - STRC-05

must_haves:
  truths:
    - "Function length counts logical lines only (excludes blanks, comments, block comment bodies)"
    - "Single-expression arrow functions count as 1 logical line regardless of formatting"
    - "Parameter count includes both runtime params and generic type params"
    - "Nesting depth tracks max depth across nested control flow within a function body"
    - "File length uses same logical line counting as function length"
    - "Export count counts export_statement nodes at program root level"
  artifacts:
    - path: "src/metrics/structural.zig"
      provides: "Structural metric computation: logical lines, params, nesting, file length, exports"
      exports: ["StructuralConfig", "StructuralFunctionResult", "FileStructuralResult", "analyzeFunctions", "analyzeFile", "countLogicalLines", "countParameters", "maxNestingDepth", "countExports"]
    - path: "tests/fixtures/typescript/structural_cases.ts"
      provides: "Annotated test fixture for structural metric validation"
      min_lines: 40
  key_links:
    - from: "src/metrics/structural.zig"
      to: "src/parser/tree_sitter.zig"
      via: "tree_sitter.Node API for AST traversal"
      pattern: "tree_sitter\\.Node"
    - from: "src/metrics/structural.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "isFunctionNode, extractFunctionInfo for walkAndAnalyze pattern"
      pattern: "cyclomatic\\.isFunctionNode"
---

<objective>
Implement structural metrics core: function length (logical lines), parameter count (runtime + generic), maximum nesting depth, file length (logical lines), and export count per file.

Purpose: Structural metrics capture code shape properties that complement flow-based metrics. A function can have low cyclomatic complexity but still be hard to maintain due to excessive length, deep nesting, or too many parameters.
Output: `src/metrics/structural.zig` module with full TDD coverage, `tests/fixtures/typescript/structural_cases.ts` fixture.
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-halstead-structural-metrics/07-RESEARCH.md
@.planning/phases/07-halstead-structural-metrics/07-CONTEXT.md
@src/metrics/cyclomatic.zig
@src/metrics/cognitive.zig
@src/parser/tree_sitter.zig
</context>

<feature>
  <name>Structural Metrics Core</name>
  <files>src/metrics/structural.zig, tests/fixtures/typescript/structural_cases.ts</files>
  <behavior>
    **Function Length — Logical Lines (STRC-01):**
    Given a function node's body start/end byte range and source text, count lines that contain actual code:
    - Blank lines: SKIP (trimmed length == 0)
    - Single-line comments (// ...): SKIP
    - Block comment lines: SKIP (track in_block_comment state for /* ... */ spanning multiple lines)
    - Lines starting with * inside block comments: SKIP
    - All other lines: COUNT

    Special case (locked decision): Single-expression arrow functions (body is NOT a statement_block) count as 1 logical line regardless of formatting. Detect by checking if arrow_function body child is not "statement_block".

    Test cases:
    - 3-line function with code only -> 3
    - function with blank lines and comments -> only code lines counted
    - single-expression arrow `(x) => x + 1` -> 1
    - function with JSDoc block comment -> comment lines excluded
    - function with inline block comment `/* note */ code` -> line counts (has code after comment)

    **Parameter Count (STRC-02):**
    Count direct children of formal_parameters that are not punctuation (, ( )) PLUS count direct children of type_parameters that are not punctuation (, < >).
    Locked decision: total = runtime + generic.

    Test cases:
    - `function f(a, b, c)` -> 3
    - `function f<T, U>(a: T, b: U)` -> 4 (2 generic + 2 runtime)
    - `function f({a, b}: Props)` -> 1 (destructured is one param node)
    - `function f(...args)` -> 1 (rest is one param node)
    - `function f()` -> 0

    **Maximum Nesting Depth (STRC-03):**
    Walk function body tracking current depth. Increment for: if_statement, for_statement, for_in_statement, while_statement, do_statement, switch_statement, catch_clause, ternary_expression. Track max_depth seen. Stop at nested function boundaries (scope isolation).

    Test cases:
    - flat function (no control flow) -> 0
    - single if -> 1
    - if inside for -> 2
    - deeply nested if/for/while -> 3+
    - nested function body doesn't inflate outer depth

    **File Length — Logical Lines (STRC-04):**
    Same countLogicalLines algorithm applied to entire source text (start_byte=0, end_byte=source.len). Locked decision: same rules as function length.

    **Export Count (STRC-05):**
    Walk program root children. Count nodes where nodeType() is "export_statement". Each export_statement = +1 regardless of how many names it exports (one `export { a, b, c }` = 1 export count).

    Test cases:
    - file with 3 export statements -> 3
    - file with `export default` -> 1
    - file with no exports -> 0
    - `export * from './module'` -> 1

    **Per-function result struct:**
    StructuralFunctionResult { name, kind, start_line, end_line, start_col, function_length, params_count, nesting_depth }

    **Per-file result struct:**
    FileStructuralResult { file_length, export_count }
  </behavior>
  <implementation>
    1. Create `src/metrics/structural.zig` with:
       - StructuralConfig struct with threshold pairs: function_length (25/50), params_count (3/6), nesting_depth (3/5), file_length (300/600), export_count (15/30) — per locked user decisions and research recommendations
       - StructuralFunctionResult struct (name, kind, start_line, end_line, start_col, function_length, params_count, nesting_depth)
       - FileStructuralResult struct (file_length, file_length_status, export_count, export_count_status)
       - countLogicalLines(source: []const u8, start_byte: u32, end_byte: u32) -> u32
         Track in_block_comment state. For each line: skip blank, skip //, skip block comment interior, count the rest. Handle inline /* */ on same line (check if line has code after closing */). Handle /* that opens and closes on same line.
       - countParameters(function_node: tree_sitter.Node) -> u32
         Find formal_parameters child, count non-punctuation children. Find type_parameters child, count non-punctuation children. Return sum.
       - maxNestingDepth(function_body_node: tree_sitter.Node) -> u32
         Recursive walker with current_depth/max_depth context. Increment for nesting constructs. Stop at nested function nodes.
       - countExports(root: tree_sitter.Node) -> u32
         Iterate root children, count "export_statement" nodes.
       - analyzeFunctions(allocator, root, source) -> []StructuralFunctionResult
         Follow walkAndAnalyze pattern from cyclomatic.zig. For each function: compute function_length (check if arrow expression body -> 1, else countLogicalLines on statement_block), countParameters on function node, maxNestingDepth on function body.
       - analyzeFile(source: []const u8, root: tree_sitter.Node) -> FileStructuralResult
         countLogicalLines on full source, countExports on root.

    2. Create `tests/fixtures/typescript/structural_cases.ts` with annotated functions:
       - shortFunction (3 logical lines)
       - longFunctionWithComments (mixed code/comments/blanks, verify correct count)
       - singleExpressionArrow (1 logical line)
       - manyParams<T, U, V>(a: T, b: U, c: V, d: number) — 7 params (3 generic + 4 runtime)
       - deeplyNested (if > for > while > if — nesting depth 4)
       - flatFunction (nesting depth 0)
       - Multiple export statements at file level for export counting
       - destructuredParams({a, b}: Props, ...rest: any[]) — 2 params

    3. Write tests in structural.zig below // TESTS comment:
       - countLogicalLines with blank lines
       - countLogicalLines with single-line comments
       - countLogicalLines with multi-line block comments
       - countLogicalLines with mixed content
       - countParameters with runtime-only params
       - countParameters with runtime + generic params
       - countParameters with destructured params
       - countParameters with no params
       - maxNestingDepth flat function
       - maxNestingDepth nested control flow
       - maxNestingDepth stops at nested function boundary
       - countExports with mixed export types
       - Integration: parse fixture, verify structural metrics on known functions

    Memory: No allocator needed for pure computation functions (countLogicalLines, countParameters, maxNestingDepth, countExports). analyzeFunctions needs allocator for result array (use arena pattern from cyclomatic.zig).

    Import in main.zig test block: `_ = @import("metrics/structural.zig");`
  </implementation>
</feature>

<verification>
```bash
zig build test 2>&1 | head -20
# All tests pass, no memory leaks
```
- Logical line counting excludes blanks, comments, block comment interiors
- Single-expression arrows count as 1 logical line
- Parameter count includes generic type params (locked decision)
- Nesting depth respects function scope isolation
- Export count matches number of export_statement nodes
</verification>

<success_criteria>
- src/metrics/structural.zig exists with all structural metric functions
- countLogicalLines handles blank lines, single/multi-line comments correctly
- Single-expression arrow functions = 1 logical line (locked decision)
- Parameter count = runtime + generic type params (locked decision)
- Nesting depth tracks max depth with scope isolation
- countExports counts export_statement nodes at root level
- Tests pass with std.testing.allocator (no leaks)
- tests/fixtures/typescript/structural_cases.ts has annotated test cases
</success_criteria>

<output>
After completion, create `.planning/phases/07-halstead-structural-metrics/07-02-SUMMARY.md`
</output>
