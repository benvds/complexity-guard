---
phase: 06-cognitive-complexity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/fixtures/typescript/cognitive_cases.ts
  - src/metrics/cognitive.zig
  - src/metrics/cyclomatic.zig
autonomous: true
requirements:
  - COGN-01
  - COGN-02
  - COGN-03
  - COGN-04
  - COGN-05
  - COGN-06
  - COGN-07
  - COGN-08

must_haves:
  truths:
    - "Tool calculates cognitive complexity per function with correct structural increments (1 + nesting_level)"
    - "Tool tracks nesting level correctly across nested structures"
    - "Tool counts each logical operator (&&, ||, ??) as +1 flat (ComplexityGuard deviation from SonarSource)"
    - "Tool detects recursion when function calls itself by declared name"
    - "Tool counts each ?? (nullish coalescing) as +1 flat per user decision; ?. (optional chaining) does NOT increment (COGN-08)"
    - "Tool handles else if as continuation (not double-counted)"
    - "Top-level arrow function definitions do NOT add nesting"
    - "Arrow function callbacks DO increase nesting depth"
    - "Nested function bodies do NOT contribute to outer function cognitive complexity"
  artifacts:
    - path: "tests/fixtures/typescript/cognitive_cases.ts"
      provides: "Hand-crafted test fixture with annotated expected cognitive scores"
      contains: "cognitive"
    - path: "src/metrics/cognitive.zig"
      provides: "Cognitive complexity calculator with CognitiveConfig, analyzeFunctions, analyzeFile"
      exports: ["CognitiveConfig", "CognitiveFunctionResult", "analyzeFunctions", "analyzeFile"]
    - path: "src/metrics/cyclomatic.zig"
      provides: "Extended ThresholdResult with cognitive fields"
      contains: "cognitive_complexity"
  key_links:
    - from: "src/metrics/cognitive.zig"
      to: "src/parser/tree_sitter.zig"
      via: "tree_sitter.Node traversal"
      pattern: "tree_sitter\\.Node"
    - from: "src/metrics/cognitive.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "reuses isFunctionNode, extractFunctionInfo, validateThreshold"
      pattern: "cyclomatic\\."
---

<objective>
Implement the core SonarSource cognitive complexity algorithm for TypeScript/JavaScript, create the test fixture, and extend ThresholdResult to carry both metrics.

Purpose: This is the foundation for Phase 6 — the cognitive scoring algorithm, nesting tracking, and data model extension that all other plans depend on.
Output: `src/metrics/cognitive.zig` with full algorithm, `tests/fixtures/typescript/cognitive_cases.ts` fixture, extended `ThresholdResult` in `cyclomatic.zig`.

Note on COGN-05/COGN-06: The REQUIREMENTS.md text describes SonarSource's same-operator grouping behavior. Per locked user decision, ComplexityGuard deviates: each logical operator (&&, ||, ??) counts as +1 individually regardless of sequence. This plan implements the user's locked decision, not the SonarSource grouping. The deviation is documented in the cognitive complexity docs page (Plan 03).
</objective>

<execution_context>
@/Users/benvds/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benvds/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cognitive-complexity/06-CONTEXT.md
@.planning/phases/06-cognitive-complexity/06-RESEARCH.md
@src/metrics/cyclomatic.zig
@src/parser/tree_sitter.zig
@tests/fixtures/typescript/cyclomatic_cases.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cognitive complexity test fixture and extend ThresholdResult</name>
  <files>tests/fixtures/typescript/cognitive_cases.ts, src/metrics/cyclomatic.zig</files>
  <action>
1. Create `tests/fixtures/typescript/cognitive_cases.ts` with hand-annotated expected cognitive scores (ComplexityGuard rules). Include these cases:
   - `baseline()`: score 0 — simple function, no branches
   - `singleIf(x)`: score 1 — single if at nesting 0
   - `ifElseChain(x)`: score 4 — if (+1, nesting 0) + else if (+1 else flat, +1 if at nesting 0) + else (+1 flat) = 4
   - `nestedIfInLoop(items)`: score 6 — for-of (+1, nesting 0) + if (+1+1 nesting 1) + if (+1+2 nesting 2) = 6
   - `logicalOps(a, b, c)`: score 3 — if (+1 nesting 0) + && (+1 flat) + && (+1 flat) = 3. Note: ComplexityGuard deviation counts EACH operator
   - `mixedLogicalOps(a, b, c)`: score 4 — if (+1 nesting 0) + && (+1) + || (+1) + && (+1) = 4. Mixed operators also each count
   - `factorial(n)`: score 2 — if (+1 nesting 0) + recursion (+1 flat) = 2
   - `topLevelArrow`: score 1 — const fn = () => { if... } — the arrow does NOT add nesting (user decision: top-level arrows treated like function declarations), so if at nesting 0 = +1
   - `withCallback(items)`: score 3 — items.filter(x => { if... }) — the arrow callback IS structural (+1 at nesting 0), increases nesting, then if inside (+1+1 nesting 1) = 3
   - `switchStatement(x)`: score 1 — switch (+1 structural at nesting 0), individual cases do NOT increment
   - `tryCatch()`: score 1 — try no increment, catch (+1 structural at nesting 0)
   - `ternaryNested(x)`: score 3 — ternary (+1 nesting 0, increases nesting) + nested ternary (+1+1 nesting 1) = 3
   - `classMethod()`: score 3 — class methods start at nesting 0, for-of (+1 nesting 0) + if (+1+1 nesting 1) = 3
   - `deeplyNested()`: score demonstrating deep nesting penalty escalation
   - `labeledBreak()`: score includes +1 flat for labeled break
   - `noIncrement()`: score 0 — function with try/finally, throw, return — none increment

   Each function must have a comment `// Expected cognitive: N` with detailed breakdown.

2. Extend `ThresholdResult` in `src/metrics/cyclomatic.zig` to include cognitive fields:
   - Add `cognitive_complexity: u32` field (default 0)
   - Add `cognitive_status: ThresholdStatus` field (default .ok)

   Update ALL existing ThresholdResult literals in cyclomatic.zig tests to include the new fields (set to `.cognitive_complexity = 0, .cognitive_status = .ok`). Also update ALL ThresholdResult literals in `src/output/console.zig`, `src/output/json_output.zig`, and `src/output/exit_codes.zig` tests. This is critical — if any literal is missing the new fields, the build will fail.

   In the `analyzeFile` function in cyclomatic.zig, set the new fields to defaults:
   ```zig
   .cognitive_complexity = 0,
   .cognitive_status = .ok,
   ```
  </action>
  <verify>
    Run `zig build test` — all existing tests must pass with extended ThresholdResult. Verify `tests/fixtures/typescript/cognitive_cases.ts` exists and has at least 12 test functions with `// Expected cognitive:` annotations.
  </verify>
  <done>ThresholdResult has cognitive_complexity and cognitive_status fields. All existing tests pass. Test fixture exists with annotated expected scores.</done>
</task>

<task type="auto">
  <name>Task 2: Implement cognitive complexity algorithm</name>
  <files>src/metrics/cognitive.zig</files>
  <action>
Create `src/metrics/cognitive.zig` mirroring the pattern of `cyclomatic.zig`. Import `tree_sitter`, `cyclomatic` (for `isFunctionNode`, `extractFunctionInfo`, `validateThreshold`, `ThresholdStatus`), `parse`, and `std`.

**CognitiveConfig struct:**
```zig
pub const CognitiveConfig = struct {
    warning_threshold: u32 = 15,  // SonarSource default
    error_threshold: u32 = 25,    // SonarSource critical zone
    pub fn default() CognitiveConfig { return CognitiveConfig{}; }
};
```

**CognitiveFunctionResult struct:**
```zig
pub const CognitiveFunctionResult = struct {
    name: []const u8,
    kind: []const u8,
    complexity: u32,
    start_line: u32,
    end_line: u32,
    start_col: u32,
};
```

**CognitiveContext struct (internal):**
```zig
const CognitiveContext = struct {
    nesting_level: u32,
    function_name: []const u8,
    complexity: u32,
    source: []const u8,
};
```

**Core algorithm — `calculateCognitiveComplexity(node, source, function_name)`:**
- Find the function body (statement_block child, or expression body for arrow functions)
- Create CognitiveContext with nesting_level=0, given function_name, complexity=0
- Call visitNode recursively on the body
- Return ctx.complexity

**visitNode(ctx, node) — the recursive traversal:**
- If node is a function node (`isFunctionNode`): STOP — do not recurse (scope isolation)
- If node is `if_statement`: check if parent is `else_clause` — if NOT a child of else_clause, add structural increment (1 + nesting_level), increase nesting for children, recurse, decrease nesting, return
- If node is `else_clause`: add +1 flat. Check first meaningful child — if `if_statement`, visit it at CURRENT nesting level (continuation, no nesting increase). If `statement_block`, increase nesting, visit children, decrease nesting. Return.
- If node is `for_statement`, `for_in_statement`, `while_statement`, `do_statement`, `switch_statement`, `catch_clause`: structural increment (1 + nesting_level), increase nesting, visit children, decrease nesting, return
- If node is `ternary_expression`: structural increment (1 + nesting_level), increase nesting, visit children, decrease nesting, return
- If node is `arrow_function` (and we're inside the traversal, meaning it's nested): structural increment (1 + nesting_level), increase nesting, visit body children, decrease nesting, return. Note: top-level arrows are handled at the walkAndAnalyze level — they are treated as function entry points and start with nesting 0, so this case only fires for CALLBACK arrows nested inside another function.
- If node is `binary_expression`: check operator children for `&&`, `||`, `??` — each adds +1 flat. Then recurse into non-operator children.
- If node is `call_expression`: check for recursion — if callee is bare identifier matching ctx.function_name, add +1 flat. Then recurse into children.
- If node is `break_statement` or `continue_statement`: check for label child — if label exists, add +1 flat. Then recurse.
- Default: recurse into all children.

**CRITICAL implementation details:**
- `else if` handling: When visiting `else_clause`, add +1 flat for the else. Then check if first non-keyword child is `if_statement`. If yes, the `if_statement` gets its structural increment at the CURRENT nesting level (do NOT increment nesting for the else_clause wrapper). This prevents double-counting.
- Arrow function discrimination: In `walkAndAnalyze`, when encountering an `arrow_function` as a top-level function entry point (detected the same way cyclomatic.zig does — via `variable_declarator` parent), start a new context at nesting 0. Inside `visitNode`, any `arrow_function` encountered is by definition a nested callback, so it gets structural treatment.
- `??` (nullish coalescing) counts as +1 flat per operator (ComplexityGuard deviation — user decision). But `?.` (optional chaining) does NOT count (COGN-08). The `??` is a `binary_expression` operator; `?.` is handled in member_expression and is NOT counted.
- Logical operator counting implements COGN-05/COGN-06 via ComplexityGuard deviation: each `&&`, `||`, `??` is +1 flat regardless of whether adjacent operators are the same type. This is simpler than SonarSource's grouping and matches the locked user decision.
- Function scope isolation: `visitNode` returns immediately when hitting any function node. Each function is analyzed independently by `walkAndAnalyze`.

**analyzeFunctions(allocator, root, config, source):**
- Same walker pattern as cyclomatic.zig's `walkAndAnalyze`
- For each function node found, extract function info, calculate cognitive complexity, collect into CognitiveFunctionResult slice

**analyzeFile(allocator, parse_result, config):**
- If tree is null, return empty slice
- Call analyzeFunctions, then convert to ThresholdResult array (like cyclomatic's analyzeFile but setting cognitive fields)
- Note: This produces ThresholdResult with cognitive fields populated BUT cyclomatic fields at 0. The integration in main.zig (Plan 02) will merge both.

Write inline tests below `// TESTS` comment. Tests should cover:
- Simple function: cognitive = 0
- Single if: cognitive = 1
- if/else if/else chain: verify correct score (no double-counting)
- Nested if inside for loop: verify nesting penalties
- Logical operators: each && || ?? counts +1
- Recursion: +1 flat for self-call by name
- Top-level arrow: nesting 0 (if inside = +1 not +2)
- Callback arrow: increases nesting (if inside callback = +2)
- Switch: +1 structural, cases don't count
- Catch: +1 structural
- Ternary: +1 structural with nesting
- Nested function scope isolation: inner function doesn't inflate outer
- Integration test against cognitive_cases.ts fixture: parse file, run analyzeFunctions, verify each function's score matches annotation
  </action>
  <verify>
    Run `zig build test` — all cognitive.zig tests pass including the fixture integration test. Verify the fixture integration test checks at least 10 functions by name and expected score.
  </verify>
  <done>cognitive.zig implements the full SonarSource-based algorithm with ComplexityGuard deviations. All unit tests pass. Fixture integration test validates expected scores.</done>
</task>

<task type="auto">
  <name>Task 3: Register cognitive module in main.zig test block</name>
  <files>src/main.zig</files>
  <action>
Add `_ = @import("metrics/cognitive.zig");` to the test block in main.zig so that cognitive.zig's inline tests are discovered by `zig build test`.

Place it after the existing `_ = @import("metrics/cyclomatic.zig");` line for consistency.
  </action>
  <verify>Run `zig build test` — all tests pass including cognitive.zig tests (verify they appear in test output).</verify>
  <done>cognitive.zig tests are discovered and run as part of `zig build test`.</done>
</task>

</tasks>

<verification>
1. `zig build test` passes with zero failures
2. `tests/fixtures/typescript/cognitive_cases.ts` exists with 12+ annotated functions
3. `src/metrics/cognitive.zig` exists with CognitiveConfig, analyzeFunctions, analyzeFile exports
4. ThresholdResult in cyclomatic.zig has cognitive_complexity and cognitive_status fields
5. All existing console, json_output, and exit_codes tests still pass
</verification>

<success_criteria>
- Cognitive complexity algorithm correctly computes scores matching SonarSource spec with documented deviations
- ThresholdResult extended to carry both metrics without breaking existing code
- All tests pass including fixture integration test
- cognitive.zig module registered for test discovery
</success_criteria>

<output>
After completion, create `.planning/phases/06-cognitive-complexity/06-01-SUMMARY.md`
</output>
