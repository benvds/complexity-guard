---
phase: 04-cyclomatic-complexity
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/metrics/cyclomatic.zig
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tool applies configurable warning threshold (default 10) to each function's complexity"
    - "Tool applies configurable error threshold (default 20) to each function's complexity"
    - "Tool returns threshold status (ok/warning/error) per function"
    - "Tool populates FunctionResult.cyclomatic with computed complexity values"
    - "Tool reports function locations (file path, line number, column number) in results"
    - "Tool runs cyclomatic analysis on parsed files in the main pipeline"
  artifacts:
    - path: "src/metrics/cyclomatic.zig"
      provides: "Threshold validation and FunctionResult population"
      exports: ["ThresholdStatus", "ThresholdResult", "validateThreshold", "analyzeFile"]
    - path: "src/main.zig"
      provides: "Cyclomatic analysis integrated into parse pipeline"
      contains: "cyclomatic"
  key_links:
    - from: "src/metrics/cyclomatic.zig"
      to: "src/core/types.zig"
      via: "Populates FunctionResult.cyclomatic field"
      pattern: "types\\.FunctionResult"
    - from: "src/metrics/cyclomatic.zig"
      to: "src/parser/parse.zig"
      via: "Receives ParseResult with tree and source for analysis"
      pattern: "ParseResult"
    - from: "src/main.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "Calls analyzeFile on each parsed file"
      pattern: "cyclomatic\\.analyzeFile"
---

<objective>
Add threshold validation and integrate cyclomatic complexity into the main analysis pipeline.

Purpose: Completes Phase 4 by making cyclomatic complexity a live metric: functions are analyzed, thresholds are checked, and results populate the existing FunctionResult data structures. This enables Phase 8 (output formatting) to display complexity results.

Output: Threshold validation (ok/warning/error per function), FunctionResult population, and main.zig pipeline integration that runs cyclomatic analysis on all parsed files.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cyclomatic-complexity/04-RESEARCH.md
@.planning/phases/04-cyclomatic-complexity/04-01-SUMMARY.md
@src/metrics/cyclomatic.zig
@src/core/types.zig
@src/parser/parse.zig
@src/cli/config.zig
@src/main.zig
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add threshold validation and FunctionResult population</name>
  <files>src/metrics/cyclomatic.zig</files>
  <action>
Add the following to `src/metrics/cyclomatic.zig`:

**1. ThresholdStatus enum:**
```zig
pub const ThresholdStatus = enum {
    ok,      // Below warning threshold
    warning, // At or above warning, below error
    @"error",// At or above error threshold
};
```
Note: Use `@"error"` syntax since `error` is a Zig keyword.

**2. ThresholdResult struct:**
```zig
pub const ThresholdResult = struct {
    complexity: u32,
    status: ThresholdStatus,
    function_name: []const u8,
    start_line: u32,
    start_col: u32,
};
```

**3. validateThreshold function:**
```zig
pub fn validateThreshold(complexity: u32, warning: u32, err_level: u32) ThresholdStatus {
    if (complexity >= err_level) return .@"error";
    if (complexity >= warning) return .warning;
    return .ok;
}
```

**4. Add warning_threshold and error_threshold to CyclomaticConfig:**
Add two fields to the existing CyclomaticConfig struct:
- `warning_threshold: u32 = 10` -- default warning at 10 (academic McCabe standard)
- `error_threshold: u32 = 20` -- default error at 20 (ESLint standard)

**5. analyzeFile function:**
```zig
pub fn analyzeFile(
    allocator: Allocator,
    parse_result: parse.ParseResult,
    config: CyclomaticConfig,
) ![]ThresholdResult
```
Takes a ParseResult (which contains the tree and source), calls analyzeFunctions on the root node, then validates each function's complexity against thresholds. Returns a slice of ThresholdResult.

If `parse_result.tree` is null, return an empty slice.

**6. toFunctionResults function:**
```zig
pub fn toFunctionResults(
    allocator: Allocator,
    function_complexities: []const FunctionComplexity,
) ![]types.FunctionResult
```
Converts FunctionComplexity results to FunctionResult structs, populating the `.cyclomatic` field. Sets other metric fields (cognitive, halstead, etc.) to null. Sets structural fields (params_count, line_count, nesting_depth) to 0 for now (future phases will populate these during their own AST traversals).

Import types: `const types = @import("../core/types.zig");`
Import parse: `const parse = @import("../parser/parse.zig");`

**Inline tests to add:**
- Test validateThreshold: complexity 5 with defaults (10/20) => .ok
- Test validateThreshold: complexity 10 with defaults => .warning
- Test validateThreshold: complexity 15 with defaults => .warning
- Test validateThreshold: complexity 20 with defaults => .@"error"
- Test validateThreshold: complexity 25 with defaults => .@"error"
- Test validateThreshold with custom thresholds (5/15): complexity 5 => .warning, 15 => .@"error"
- Test CyclomaticConfig default thresholds are 10 and 20
- Test analyzeFile with a simple parsed file returns correct ThresholdResults
- Test toFunctionResults populates cyclomatic field correctly
  </action>
  <verify>
Run `zig build test` -- all tests pass. Verify threshold validation produces correct status for values below warning, between warning and error, and at/above error.
  </verify>
  <done>
ThresholdStatus, ThresholdResult, validateThreshold, analyzeFile, and toFunctionResults exist in cyclomatic.zig. Default thresholds are warning=10, error=20. Threshold validation correctly categorizes complexity values as ok/warning/error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate cyclomatic analysis into main.zig pipeline</name>
  <files>src/main.zig</files>
  <action>
Update `src/main.zig` to run cyclomatic complexity analysis on parsed files and display results.

**1. Import the cyclomatic module:**
Add `const cyclomatic = @import("metrics/cyclomatic.zig");` at the top with the other imports.

**2. After parsing, run cyclomatic analysis:**
After the existing `parseFiles` call and before printing the summary, add:

```zig
// Run cyclomatic complexity analysis
const cycl_config = cyclomatic.CyclomaticConfig.default();
var total_warnings: u32 = 0;
var total_errors: u32 = 0;
var total_functions_analyzed: u32 = 0;

for (parse_summary.results) |result| {
    const threshold_results = try cyclomatic.analyzeFile(
        arena_allocator,
        result,
        cycl_config,
    );

    total_functions_analyzed += @intCast(threshold_results.len);

    for (threshold_results) |tr| {
        switch (tr.status) {
            .warning => total_warnings += 1,
            .@"error" => total_errors += 1,
            .ok => {},
        }
    }
}
```

**3. Update the summary output** to include complexity results:
After the existing parse summary line, add:
```zig
try stdout.print("Analyzed {d} functions", .{total_functions_analyzed});
if (total_warnings > 0 or total_errors > 0) {
    try stdout.print(": {d} warnings, {d} errors", .{total_warnings, total_errors});
}
try stdout.writeAll("\n");
```

**4. Update verbose output** to show per-function complexity:
In the verbose block, after showing parsed files, add a section that re-runs analysis and prints per-function detail:
```zig
if (cli_args.verbose) {
    // ... existing file listing ...

    // Show complexity details
    try stdout.writeAll("\nComplexity analysis:\n");
    for (parse_summary.results) |result| {
        const threshold_results = try cyclomatic.analyzeFile(
            arena_allocator,
            result,
            cycl_config,
        );

        if (threshold_results.len > 0) {
            try stdout.print("  {s}:\n", .{result.path});
            for (threshold_results) |tr| {
                const status_str = switch (tr.status) {
                    .ok => "ok",
                    .warning => "WARN",
                    .@"error" => "ERROR",
                };
                try stdout.print("    {s} (line {d}): complexity {d} [{s}]\n", .{
                    tr.function_name,
                    tr.start_line,
                    tr.complexity,
                    status_str,
                });
            }
        }
    }
}
```

NOTE: The double-analysis (once for counts, once for verbose) is acceptable for now. In Phase 8 (output formatting), the pipeline will be restructured to analyze once and format differently.

**5. Verify the import in the test block** at bottom of main.zig includes `_ = @import("metrics/cyclomatic.zig");` (should have been added in Plan 01 Task 2, but confirm it exists).
  </action>
  <verify>
1. `zig build test` -- all tests pass
2. `zig build` -- compiles successfully
3. `zig build run -- tests/fixtures/typescript/` -- runs and shows function count with complexity summary
4. `zig build run -- --verbose tests/fixtures/typescript/` -- shows per-function complexity details
  </verify>
  <done>
Running `complexity-guard` on a directory now discovers files, parses them, analyzes cyclomatic complexity per function, and displays a summary with warning/error counts. Verbose mode shows per-function complexity with threshold status. FunctionResult.cyclomatic field is populated. All 9 CYCL requirements are met.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes with zero failures
2. `zig build` compiles successfully
3. `zig build run -- tests/fixtures/typescript/simple_function.ts` shows 1 function with complexity 1
4. `zig build run -- --verbose tests/fixtures/typescript/complex_nested.ts` shows function with high complexity
5. `zig build run -- --verbose tests/fixtures/typescript/cyclomatic_cases.ts` shows all functions with expected complexities
6. Default thresholds: warning=10, error=20
7. No memory leaks (std.testing.allocator catches these)
</verification>

<success_criteria>
- CYCL-09 implemented: configurable warning (default 10) and error (default 20) thresholds
- Threshold validation returns ok/warning/error status per function
- Main pipeline runs cyclomatic analysis on all parsed files
- Verbose output shows per-function complexity with locations and status
- FunctionResult.cyclomatic populated with computed values
- All Phase 4 requirements CYCL-01 through CYCL-09 complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-cyclomatic-complexity/04-02-SUMMARY.md`
</output>
