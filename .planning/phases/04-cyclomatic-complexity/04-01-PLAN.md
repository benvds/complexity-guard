---
phase: 04-cyclomatic-complexity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/metrics/cyclomatic.zig
  - tests/fixtures/typescript/cyclomatic_cases.ts
  - src/main.zig
autonomous: true

must_haves:
  truths:
    - "Tool identifies function boundaries (function_declaration, function, arrow_function, method_definition, generator_function, generator_function_declaration) in parsed ASTs"
    - "Tool counts all standard decision points: if, else if, while, do-while, for, for-in, for-of, switch case, catch, ternary"
    - "Tool counts modern JS decision points: logical && and ||, nullish coalescing ??, optional chaining ?."
    - "Tool starts each function at base complexity 1"
    - "Tool does NOT count nested function complexity toward parent function"
    - "CyclomaticConfig toggles control which optional constructs are counted"
  artifacts:
    - path: "src/metrics/cyclomatic.zig"
      provides: "Cyclomatic complexity calculator with config, function extraction, and recursive AST traversal"
      exports: ["CyclomaticConfig", "calculateComplexity", "FunctionComplexity", "analyzeFunction", "analyzeFunctions"]
    - path: "tests/fixtures/typescript/cyclomatic_cases.ts"
      provides: "Dedicated test fixture with functions of known cyclomatic complexity"
    - path: "src/main.zig"
      provides: "Test import for metrics/cyclomatic.zig"
      contains: "metrics/cyclomatic.zig"
  key_links:
    - from: "src/metrics/cyclomatic.zig"
      to: "src/parser/tree_sitter.zig"
      via: "import tree_sitter Node type for AST traversal"
      pattern: "@import.*tree_sitter"
    - from: "src/metrics/cyclomatic.zig"
      to: "src/parser/tree_sitter.zig"
      via: "Uses Node.nodeType(), Node.childCount(), Node.child(), Node.startPoint(), Node.endPoint()"
      pattern: "node\\.nodeType\\(\\)"
    - from: "src/main.zig"
      to: "src/metrics/cyclomatic.zig"
      via: "test import for discovery"
      pattern: "@import.*metrics/cyclomatic"
---

<objective>
Implement the cyclomatic complexity calculator that traverses tree-sitter ASTs to count decision points per function.

Purpose: This is the first metric the tool computes -- the vertical slice from AST traversal through complexity calculation. It establishes the `src/metrics/` module pattern that cognitive complexity (Phase 5) and Halstead metrics (Phase 6) will follow.

Output: `src/metrics/cyclomatic.zig` containing CyclomaticConfig, function extraction, and recursive decision-point counting with nested function scope isolation. A dedicated test fixture with known complexity values.
</objective>

<execution_context>
@/home/ben/.claude/get-shit-done/workflows/execute-plan.md
@/home/ben/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-cyclomatic-complexity/04-RESEARCH.md
@src/parser/tree_sitter.zig
@src/core/types.zig
@src/main.zig
@tests/fixtures/typescript/complex_nested.ts
@tests/fixtures/typescript/simple_function.ts
@tests/fixtures/typescript/class_with_methods.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cyclomatic complexity calculator module</name>
  <files>src/metrics/cyclomatic.zig</files>
  <action>
Create `src/metrics/cyclomatic.zig` with the following components:

**1. CyclomaticConfig struct** with fields:
- `count_logical_operators: bool = true` -- count && and || as decision points
- `count_nullish_coalescing: bool = true` -- count ?? as decision point
- `count_optional_chaining: bool = true` -- count ?. as decision point
- `count_ternary: bool = true` -- count ternary ? : as decision point
- `count_default_params: bool = true` -- count default parameter values as decision points
- `switch_case_mode: SwitchCaseMode = .classic` -- .classic = each case counts, .modified = switch counts once
- Inner enum `SwitchCaseMode { classic, modified }`
- `pub fn default() CyclomaticConfig` returning a config with all defaults

**2. FunctionComplexity struct** to hold per-function results:
- `name: []const u8` -- function name (extracted from AST)
- `complexity: u32` -- computed cyclomatic complexity
- `start_line: u32` -- 1-indexed (tree-sitter row + 1)
- `end_line: u32` -- 1-indexed
- `start_col: u32` -- 0-indexed (tree-sitter column as-is)

**3. Function identification** -- `isFunctionNode(node: tree_sitter.Node) bool`:
Returns true for these tree-sitter node types:
- `"function_declaration"` -- `function foo() {}`
- `"function"` -- function expression
- `"arrow_function"` -- `() => {}`
- `"method_definition"` -- class methods, getters, setters, constructors
- `"generator_function"` -- `function* gen() {}`
- `"generator_function_declaration"` -- named generator declaration

**4. Function name extraction** -- `extractFunctionName(node: tree_sitter.Node, source: []const u8) []const u8`:
Extract the function name from the AST node:
- For `function_declaration` and `generator_function_declaration`: look for child with type `"identifier"`
- For `method_definition`: look for child with type `"property_identifier"`
- For `arrow_function` and `function` (expressions): look at parent context -- if parent is `variable_declarator`, extract the `"identifier"` child of that parent. If no name found, return `"<anonymous>"`.
- NOTE: tree-sitter Node does not have a `.parent()` method in our wrapper. For arrow functions and function expressions assigned to variables, we cannot easily get the variable name from the function node itself. Use `"<anonymous>"` as fallback for these cases. The variable name extraction would require walking from the top down and tracking assignment context, which we'll do in Task 2's `analyzeFunctions`.

Actually, simplify: `extractFunctionName` takes the node and source, checks for `"identifier"` or `"property_identifier"` children. For function expressions and arrows, return `"<anonymous>"`. The top-level `analyzeFunctions` function (which walks the full tree) can track variable assignment context and override the name.

**5. Core complexity counting** -- `countDecisionPoints(node: tree_sitter.Node, config: CyclomaticConfig, source: []const u8) u32`:
Recursive function that traverses children and accumulates complexity. When it encounters a function node (isFunctionNode), it STOPS recursing into it (nested functions get their own scope).

Decision point node types that always count +1:
- `"if_statement"` -- counts for both `if` and `else if` (tree-sitter represents `else if` as an `if_statement` inside an else clause)
- `"while_statement"` -- while loop
- `"do_statement"` -- do-while loop
- `"for_statement"` -- for loop
- `"for_in_statement"` -- for-in and for-of loops (tree-sitter uses this type for both)
- `"catch_clause"` -- catch block

Configurable decision points:
- `"ternary_expression"` -- when `config.count_ternary` is true
- `"switch_case"` -- in `.classic` mode, count each case EXCEPT check if the case has no `"expression"` child (that would be `default:`, which should NOT count). In `.modified` mode, count `"switch_statement"` once instead.

For logical operators, check `"binary_expression"` nodes: iterate children looking for operator tokens `"&&"`, `"||"`. Count +1 for each. If `config.count_logical_operators` is false, skip `&&` and `||`. If `config.count_nullish_coalescing` is true, also count `"??"` operator tokens in binary_expression.

For `"augmented_assignment_expression"` nodes: check for `"&&="`, `"||="` operator tokens. Count +1 for each logical assignment when `config.count_logical_operators` is true.

For optional chaining: check for `"optional_chain_expression"` node type (tree-sitter wraps `?.` access in this). Count +1 when `config.count_optional_chaining` is true. NOTE: The exact tree-sitter node type for optional chaining may vary -- the research suggests checking `member_expression` children for `"?."` tokens. During implementation, parse a test snippet like `a?.b` and log the AST structure to determine the exact node type. Use whichever pattern tree-sitter actually produces.

For default parameters: check `"required_parameter"` or `"optional_parameter"` nodes in TypeScript grammar that have a child matching a default value pattern. Alternatively, look for assignment patterns in parameter lists. Count +1 per default param when `config.count_default_params` is true. NOTE: The exact tree-sitter representation varies between JS and TS grammars. Parse a test snippet and inspect. If too complex for this plan, defer default params to Plan 02 and document why.

**6. Top-level function** -- `calculateComplexity(node: tree_sitter.Node, config: CyclomaticConfig, source: []const u8) u32`:
Takes a function body node, returns base 1 + countDecisionPoints(body, config, source).

**7. Analyze all functions** -- `analyzeFunctions(allocator: Allocator, root: tree_sitter.Node, config: CyclomaticConfig, source: []const u8) ![]FunctionComplexity`:
Walks the entire AST from root, finds all function nodes, extracts name/location, calculates complexity for each. Returns allocated slice of FunctionComplexity results.

For variable-assigned functions (arrows, function expressions), implement name extraction by tracking context: when visiting a `"variable_declarator"` node, check if it has a function node as its value child. If so, use the identifier from the variable_declarator as the function name instead of `"<anonymous>"`.

Similarly for `"pair"` nodes in object literals (e.g., `{ handler: function() {} }`), use the key as the function name.

**Important Zig patterns:**
- Import tree_sitter as `const tree_sitter = @import("../parser/tree_sitter.zig");`
- Use `std.mem.eql(u8, node_type, "if_statement")` for string comparison
- Use `std.ArrayList(FunctionComplexity)` for collecting results
- Use Zig 0.15.2 ArrayList API: `ArrayList.empty` const, pass allocator to `append()` and `deinit()`
- All tests go below a `// TESTS` comment in the same file
- Use `std.testing.allocator` in tests

**Inline tests to include:**
- Test CyclomaticConfig.default() returns expected values
- Test isFunctionNode with various node types (parse small snippets and check)
- Test simple function: `function f() { return 1; }` => complexity 1
- Test if statement: `function f(x) { if (x) { return 1; } return 0; }` => complexity 2
- Test if/else if: `function f(x) { if (x > 0) {} else if (x < 0) {} }` => complexity 3
- Test for loop: `function f(arr) { for (let i = 0; i < arr.length; i++) {} }` => complexity 2
- Test while loop: `function f() { while (true) {} }` => complexity 2
- Test switch with 3 cases: `function f(x) { switch(x) { case 1: break; case 2: break; case 3: break; default: break; } }` => complexity 4 (base 1 + 3 cases, default doesn't count)
- Test catch clause: `function f() { try {} catch(e) {} }` => complexity 2
- Test ternary: `function f(x) { return x ? 1 : 0; }` => complexity 2
- Test logical AND: `function f(a, b) { if (a && b) {} }` => complexity 3 (if + &&)
- Test logical OR: `function f(a, b) { return a || b; }` => complexity 2 (base + ||)
- Test nullish coalescing: `function f(a) { return a ?? 0; }` => complexity 2
- Test nested functions: inner function complexity does NOT count toward outer
- Test analyzeFunctions returns correct count of functions
- Test with existing fixture `complex_nested.ts` parsed via tree-sitter
  </action>
  <verify>
Run `zig build test` -- all existing tests plus new cyclomatic tests pass. No memory leaks detected by std.testing.allocator.
  </verify>
  <done>
`src/metrics/cyclomatic.zig` exists with CyclomaticConfig, isFunctionNode, extractFunctionName, countDecisionPoints, calculateComplexity, and analyzeFunctions. All inline tests pass including: base complexity 1 for simple functions, correct counting of if/while/for/switch/catch/ternary/logical operators/nullish coalescing, and nested function scope isolation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create cyclomatic complexity test fixture and validate against known values</name>
  <files>tests/fixtures/typescript/cyclomatic_cases.ts, src/main.zig</files>
  <action>
**1. Create `tests/fixtures/typescript/cyclomatic_cases.ts`** -- a dedicated fixture file with functions of precisely known cyclomatic complexity. Include complexity annotations in comments.

```typescript
// Fixture: Cyclomatic complexity test cases
// Purpose: Validate cyclomatic complexity counting for all decision point types
// Each function has documented expected complexity

// Expected: 1 (no branches)
export function baseline(): number {
  return 42;
}

// Expected: 3 (if + else if)
export function simpleConditionals(x: number): string {
  if (x > 0) {
    return "positive";
  } else if (x < 0) {
    return "negative";
  }
  return "zero";
}

// Expected: 4 (for-of + 2 ifs + &&)
export function loopWithConditions(items: any[]): any[] {
  const result: any[] = [];
  for (const item of items) {
    if (item.active && item.valid) {
      if (item.score > 50) {
        result.push(item);
      }
    }
  }
  return result;
}

// Expected: 5 (switch with 4 cases, not counting default)
// In classic mode: base 1 + 4 cases = 5
export function switchStatement(status: string): number {
  switch (status) {
    case "active": return 1;
    case "pending": return 2;
    case "suspended": return 3;
    case "cancelled": return 4;
    default: return 0;
  }
}

// Expected: 3 (try/catch + if)
export function errorHandling(input: string): any {
  try {
    const parsed = JSON.parse(input);
    if (parsed.valid) {
      return parsed;
    }
    return null;
  } catch (e) {
    return { error: e };
  }
}

// Expected: 3 (ternary + ||)
export function ternaryAndLogical(a: any, b: any): any {
  const value = a || b;
  return value ? "truthy" : "falsy";
}

// Expected: 3 (2x ?? + base)
export function nullishCoalescing(a: any, b: any): any {
  return a ?? b ?? "default";
}

// Expected: complexity of outer does NOT include inner's branches
// Outer: 2 (if)
// Inner: 2 (if)
export function nestedFunctions(x: number): () => string {
  if (x > 0) {
    return () => {
      if (x > 10) {
        return "large";
      }
      return "small";
    };
  }
  return () => "negative";
}

// Arrow function: Expected 2 (if)
export const arrowFunc = (x: number): string => {
  if (x > 0) {
    return "positive";
  }
  return "non-positive";
};

// Expected: 4 (while + if + || + &&)
export function complexLogical(data: any): boolean {
  let found = false;
  while (data.hasNext()) {
    if (data.current.valid || data.current.forced && data.current.enabled) {
      found = true;
    }
  }
  return found;
}
```

Adjust exact expected values after implementation if tree-sitter produces slightly different AST structure than expected (document any adjustments).

**2. Add import to `src/main.zig`** test block:
Add `_ = @import("metrics/cyclomatic.zig");` to the test block in main.zig so the cyclomatic tests are discovered.

**3. Add integration test in cyclomatic.zig** that parses `tests/fixtures/typescript/cyclomatic_cases.ts` through tree-sitter, runs analyzeFunctions on it, and validates:
- Correct number of functions found
- Each function has expected complexity value (use the annotations from the fixture)
- Function names are correctly extracted
- Function locations (start_line) are correct (1-indexed)
  </action>
  <verify>
Run `zig build test` -- all tests pass including the fixture-based integration test. The integration test validates specific complexity values for each function in the fixture.
  </verify>
  <done>
`tests/fixtures/typescript/cyclomatic_cases.ts` exists with 10+ functions of documented expected complexity. `src/main.zig` imports `metrics/cyclomatic.zig` for test discovery. Integration test in `cyclomatic.zig` parses the fixture and validates complexity values, function names, and locations.
  </done>
</task>

</tasks>

<verification>
1. `zig build test` passes with zero failures
2. `zig build` compiles successfully
3. No memory leaks (std.testing.allocator catches these)
4. CyclomaticConfig defaults: count_logical_operators=true, count_nullish_coalescing=true, count_optional_chaining=true, count_ternary=true, switch_case_mode=.classic
5. Simple function (no branches) returns complexity 1
6. Each control flow construct (if, while, for, switch case, catch, ternary) adds exactly 1
7. Logical operators (&& and ||) each add 1
8. Nullish coalescing (??) adds 1
9. Nested functions do NOT inflate parent complexity
10. Switch default case does NOT count in classic mode
</verification>

<success_criteria>
- src/metrics/cyclomatic.zig exists and exports CyclomaticConfig, FunctionComplexity, calculateComplexity, analyzeFunctions
- All CYCL-01 through CYCL-08 requirements are addressed (CYCL-09 thresholds in Plan 02)
- Integration test validates complexity against fixture with known expected values
- All 50+ existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-cyclomatic-complexity/04-01-SUMMARY.md`
</output>
